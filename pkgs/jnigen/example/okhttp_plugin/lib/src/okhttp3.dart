// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

/// from: okio.AsyncTimeout$Companion
class AsyncTimeout_Companion extends jni.JObject {
  @override
  late final jni.JObjType<AsyncTimeout_Companion> $type = type;

  AsyncTimeout_Companion.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/AsyncTimeout$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $AsyncTimeout_CompanionType();
  static final _id_getLock = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"getLock", r"()Ljava/util/concurrent/locks/ReentrantLock;");

  /// from: public final java.util.concurrent.locks.ReentrantLock getLock()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getLock() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getLock, jni.JniCallType.objectType, []).object);
  }

  static final _id_getCondition = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getCondition",
      r"()Ljava/util/concurrent/locks/Condition;");

  /// from: public final java.util.concurrent.locks.Condition getCondition()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCondition() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getCondition, jni.JniCallType.objectType, []).object);
  }

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory AsyncTimeout_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return AsyncTimeout_Companion.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [defaultConstructorMarker.reference]).object);
  }
}

final class $AsyncTimeout_CompanionType
    extends jni.JObjType<AsyncTimeout_Companion> {
  const $AsyncTimeout_CompanionType();

  @override
  String get signature => r"Lokio/AsyncTimeout$Companion;";

  @override
  AsyncTimeout_Companion fromRef(jni.JObjectPtr ref) =>
      AsyncTimeout_Companion.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($AsyncTimeout_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($AsyncTimeout_CompanionType) &&
        other is $AsyncTimeout_CompanionType;
  }
}

/// from: okio.AsyncTimeout
class AsyncTimeout extends Timeout {
  @override
  late final jni.JObjType<AsyncTimeout> $type = type;

  AsyncTimeout.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/AsyncTimeout");

  /// The type which includes information such as the signature of this class.
  static const type = $AsyncTimeoutType();
  static final _id_Companion1 = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Companion",
    r"Lokio/AsyncTimeout$Companion;",
  );

  /// from: static public final okio.AsyncTimeout$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static AsyncTimeout_Companion get Companion1 =>
      const $AsyncTimeout_CompanionType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_Companion1, jni.JniCallType.objectType)
          .object);

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory AsyncTimeout() {
    return AsyncTimeout.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_enter =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"enter", r"()V");

  /// from: public final void enter()
  void enter() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_enter, jni.JniCallType.voidType, []).check();
  }

  static final _id_exit =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"exit", r"()Z");

  /// from: public final boolean exit()
  bool exit() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_exit, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_timedOut =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"timedOut", r"()V");

  /// from: protected void timedOut()
  void timedOut() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timedOut, jni.JniCallType.voidType, []).check();
  }

  static final _id_sink = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sink", r"(Lokio/Sink;)Lokio/Sink;");

  /// from: public final okio.Sink sink(okio.Sink sink)
  /// The returned object must be released after use, by calling the [release] method.
  Sink sink(
    Sink sink,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sink,
        jni.JniCallType.objectType,
        [sink.reference]).object);
  }

  static final _id_source = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"source", r"(Lokio/Source;)Lokio/Source;");

  /// from: public final okio.Source source(okio.Source source)
  /// The returned object must be released after use, by calling the [release] method.
  Source source(
    Source source,
  ) {
    return const $SourceType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_source,
        jni.JniCallType.objectType,
        [source.reference]).object);
  }

  static final _id_withTimeout = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"withTimeout",
      r"(Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;");

  /// from: public final T withTimeout(kotlin.jvm.functions.Function0 function0)
  /// The returned object must be released after use, by calling the [release] method.
  $T withTimeout<$T extends jni.JObject>(
    jni.JObject function0, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_withTimeout,
        jni.JniCallType.objectType,
        [function0.reference]).object);
  }

  static final _id_newTimeoutException = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"newTimeoutException",
      r"(Ljava/io/IOException;)Ljava/io/IOException;");

  /// from: protected java.io.IOException newTimeoutException(java.io.IOException iOException)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject newTimeoutException(
    jni.JObject iOException,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_newTimeoutException,
        jni.JniCallType.objectType,
        [iOException.reference]).object);
  }
}

final class $AsyncTimeoutType extends jni.JObjType<AsyncTimeout> {
  const $AsyncTimeoutType();

  @override
  String get signature => r"Lokio/AsyncTimeout;";

  @override
  AsyncTimeout fromRef(jni.JObjectPtr ref) => AsyncTimeout.fromRef(ref);

  @override
  jni.JObjType get superType => const $TimeoutType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($AsyncTimeoutType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($AsyncTimeoutType) &&
        other is $AsyncTimeoutType;
  }
}

/// from: okio.Buffer$UnsafeCursor
class Buffer_UnsafeCursor extends jni.JObject {
  @override
  late final jni.JObjType<Buffer_UnsafeCursor> $type = type;

  Buffer_UnsafeCursor.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Buffer$UnsafeCursor");

  /// The type which includes information such as the signature of this class.
  static const type = $Buffer_UnsafeCursorType();
  static final _id_buffer = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"buffer",
    r"Lokio/Buffer;",
  );

  /// from: public okio.Buffer buffer
  /// The returned object must be released after use, by calling the [release] method.
  Buffer get buffer => const $BufferType().fromRef(jni.Jni.accessors
      .getField(reference, _id_buffer, jni.JniCallType.objectType)
      .object);

  /// from: public okio.Buffer buffer
  /// The returned object must be released after use, by calling the [release] method.
  set buffer(Buffer value) =>
      jni.Jni.env.SetObjectField(reference, _id_buffer, value.reference);

  static final _id_readWrite = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"readWrite",
    r"Z",
  );

  /// from: public boolean readWrite
  bool get readWrite => jni.Jni.accessors
      .getField(reference, _id_readWrite, jni.JniCallType.booleanType)
      .boolean;

  /// from: public boolean readWrite
  set readWrite(bool value) =>
      jni.Jni.env.SetBooleanField(reference, _id_readWrite, value ? 1 : 0);

  static final _id_offset = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"offset",
    r"J",
  );

  /// from: public long offset
  int get offset => jni.Jni.accessors
      .getField(reference, _id_offset, jni.JniCallType.longType)
      .long;

  /// from: public long offset
  set offset(int value) =>
      jni.Jni.env.SetLongField(reference, _id_offset, value);

  static final _id_data = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"data",
    r"[B",
  );

  /// from: public byte[] data
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> get data =>
      const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
          .getField(reference, _id_data, jni.JniCallType.objectType)
          .object);

  /// from: public byte[] data
  /// The returned object must be released after use, by calling the [release] method.
  set data(jni.JArray<jni.jbyte> value) =>
      jni.Jni.env.SetObjectField(reference, _id_data, value.reference);

  static final _id_start = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"start",
    r"I",
  );

  /// from: public int start
  int get start => jni.Jni.accessors
      .getField(reference, _id_start, jni.JniCallType.intType)
      .integer;

  /// from: public int start
  set start(int value) => jni.Jni.env.SetIntField(reference, _id_start, value);

  static final _id_end = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"end",
    r"I",
  );

  /// from: public int end
  int get end => jni.Jni.accessors
      .getField(reference, _id_end, jni.JniCallType.intType)
      .integer;

  /// from: public int end
  set end(int value) => jni.Jni.env.SetIntField(reference, _id_end, value);

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Buffer_UnsafeCursor() {
    return Buffer_UnsafeCursor.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_next =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"next", r"()I");

  /// from: public final int next()
  int next() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_next, jni.JniCallType.intType, []).integer;
  }

  static final _id_seek =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"seek", r"(J)I");

  /// from: public final int seek(long j)
  int seek(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_seek, jni.JniCallType.intType, [j]).integer;
  }

  static final _id_resizeBuffer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"resizeBuffer", r"(J)J");

  /// from: public final long resizeBuffer(long j)
  int resizeBuffer(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_resizeBuffer, jni.JniCallType.longType, [j]).long;
  }

  static final _id_expandBuffer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"expandBuffer", r"(I)J");

  /// from: public final long expandBuffer(int i)
  int expandBuffer(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_expandBuffer,
        jni.JniCallType.longType, [jni.JValueInt(i)]).long;
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }
}

final class $Buffer_UnsafeCursorType extends jni.JObjType<Buffer_UnsafeCursor> {
  const $Buffer_UnsafeCursorType();

  @override
  String get signature => r"Lokio/Buffer$UnsafeCursor;";

  @override
  Buffer_UnsafeCursor fromRef(jni.JObjectPtr ref) =>
      Buffer_UnsafeCursor.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Buffer_UnsafeCursorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Buffer_UnsafeCursorType) &&
        other is $Buffer_UnsafeCursorType;
  }
}

/// from: okio.Buffer
class Buffer extends jni.JObject {
  @override
  late final jni.JObjType<Buffer> $type = type;

  Buffer.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Buffer");

  /// The type which includes information such as the signature of this class.
  static const type = $BufferType();
  static final _id_head = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"head",
    r"Lokio/Segment;",
  );

  /// from: public okio.Segment head
  /// The returned object must be released after use, by calling the [release] method.
  Segment get head => const $SegmentType().fromRef(jni.Jni.accessors
      .getField(reference, _id_head, jni.JniCallType.objectType)
      .object);

  /// from: public okio.Segment head
  /// The returned object must be released after use, by calling the [release] method.
  set head(Segment value) =>
      jni.Jni.env.SetObjectField(reference, _id_head, value.reference);

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Buffer() {
    return Buffer.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_size =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"size", r"()J");

  /// from: public final long size()
  int size() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_size, jni.JniCallType.longType, []).long;
  }

  static final _id_buffer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"buffer", r"()Lokio/Buffer;");

  /// from: public okio.Buffer buffer()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer buffer() {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_buffer, jni.JniCallType.objectType, []).object);
  }

  static final _id_getBuffer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getBuffer", r"()Lokio/Buffer;");

  /// from: public okio.Buffer getBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer getBuffer() {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getBuffer, jni.JniCallType.objectType, []).object);
  }

  static final _id_outputStream = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"outputStream", r"()Ljava/io/OutputStream;");

  /// from: public java.io.OutputStream outputStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject outputStream() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_outputStream, jni.JniCallType.objectType, []).object);
  }

  static final _id_emitCompleteSegments = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"emitCompleteSegments", r"()Lokio/Buffer;");

  /// from: public okio.Buffer emitCompleteSegments()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer emitCompleteSegments() {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_emitCompleteSegments,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_emit = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"emit", r"()Lokio/Buffer;");

  /// from: public okio.Buffer emit()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer emit() {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_emit, jni.JniCallType.objectType, []).object);
  }

  static final _id_exhausted =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"exhausted", r"()Z");

  /// from: public boolean exhausted()
  bool exhausted() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_exhausted, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_require =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"require", r"(J)V");

  /// from: public void require(long j)
  void require(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_require, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_request =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"request", r"(J)Z");

  /// from: public boolean request(long j)
  bool request(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_request, jni.JniCallType.booleanType, [j]).boolean;
  }

  static final _id_peek = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"peek", r"()Lokio/BufferedSource;");

  /// from: public okio.BufferedSource peek()
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSource peek() {
    return const $BufferedSourceType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_peek, jni.JniCallType.objectType, []).object);
  }

  static final _id_inputStream = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"inputStream", r"()Ljava/io/InputStream;");

  /// from: public java.io.InputStream inputStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject inputStream() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_inputStream, jni.JniCallType.objectType, []).object);
  }

  static final _id_copyTo = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"copyTo", r"(Ljava/io/OutputStream;JJ)Lokio/Buffer;");

  /// from: public final okio.Buffer copyTo(java.io.OutputStream outputStream, long j, long j1)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer copyTo(
    jni.JObject outputStream,
    int j,
    int j1,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_copyTo,
        jni.JniCallType.objectType,
        [outputStream.reference, j, j1]).object);
  }

  static final _id_copyTo1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"copyTo", r"(Lokio/Buffer;JJ)Lokio/Buffer;");

  /// from: public final okio.Buffer copyTo(okio.Buffer buffer, long j, long j1)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer copyTo1(
    Buffer buffer,
    int j,
    int j1,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_copyTo1,
        jni.JniCallType.objectType,
        [buffer.reference, j, j1]).object);
  }

  static final _id_copyTo2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"copyTo", r"(Lokio/Buffer;J)Lokio/Buffer;");

  /// from: public final okio.Buffer copyTo(okio.Buffer buffer, long j)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer copyTo2(
    Buffer buffer,
    int j,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_copyTo2,
        jni.JniCallType.objectType,
        [buffer.reference, j]).object);
  }

  static final _id_writeTo = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeTo", r"(Ljava/io/OutputStream;J)Lokio/Buffer;");

  /// from: public final okio.Buffer writeTo(java.io.OutputStream outputStream, long j)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeTo(
    jni.JObject outputStream,
    int j,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_writeTo,
        jni.JniCallType.objectType,
        [outputStream.reference, j]).object);
  }

  static final _id_readFrom = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readFrom", r"(Ljava/io/InputStream;)Lokio/Buffer;");

  /// from: public final okio.Buffer readFrom(java.io.InputStream inputStream)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer readFrom(
    jni.JObject inputStream,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readFrom,
        jni.JniCallType.objectType,
        [inputStream.reference]).object);
  }

  static final _id_readFrom1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readFrom", r"(Ljava/io/InputStream;J)Lokio/Buffer;");

  /// from: public final okio.Buffer readFrom(java.io.InputStream inputStream, long j)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer readFrom1(
    jni.JObject inputStream,
    int j,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readFrom1,
        jni.JniCallType.objectType,
        [inputStream.reference, j]).object);
  }

  static final _id_completeSegmentByteCount = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"completeSegmentByteCount", r"()J");

  /// from: public final long completeSegmentByteCount()
  int completeSegmentByteCount() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_completeSegmentByteCount, jni.JniCallType.longType, []).long;
  }

  static final _id_readByte =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readByte", r"()B");

  /// from: public byte readByte()
  int readByte() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readByte, jni.JniCallType.byteType, []).byte;
  }

  static final _id_getByte =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getByte", r"(J)B");

  /// from: public final byte getByte(long j)
  int getByte(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getByte, jni.JniCallType.byteType, [j]).byte;
  }

  static final _id_readShort =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readShort", r"()S");

  /// from: public short readShort()
  int readShort() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readShort, jni.JniCallType.shortType, []).short;
  }

  static final _id_readInt =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readInt", r"()I");

  /// from: public int readInt()
  int readInt() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readInt, jni.JniCallType.intType, []).integer;
  }

  static final _id_readLong =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readLong", r"()J");

  /// from: public long readLong()
  int readLong() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readLong, jni.JniCallType.longType, []).long;
  }

  static final _id_readShortLe =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readShortLe", r"()S");

  /// from: public short readShortLe()
  int readShortLe() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readShortLe, jni.JniCallType.shortType, []).short;
  }

  static final _id_readIntLe =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readIntLe", r"()I");

  /// from: public int readIntLe()
  int readIntLe() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readIntLe, jni.JniCallType.intType, []).integer;
  }

  static final _id_readLongLe =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readLongLe", r"()J");

  /// from: public long readLongLe()
  int readLongLe() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readLongLe, jni.JniCallType.longType, []).long;
  }

  static final _id_readDecimalLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readDecimalLong", r"()J");

  /// from: public long readDecimalLong()
  int readDecimalLong() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readDecimalLong, jni.JniCallType.longType, []).long;
  }

  static final _id_readHexadecimalUnsignedLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readHexadecimalUnsignedLong", r"()J");

  /// from: public long readHexadecimalUnsignedLong()
  int readHexadecimalUnsignedLong() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_readHexadecimalUnsignedLong, jni.JniCallType.longType, []).long;
  }

  static final _id_readByteString = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readByteString", r"()Lokio/ByteString;");

  /// from: public okio.ByteString readByteString()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString readByteString() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readByteString, jni.JniCallType.objectType, []).object);
  }

  static final _id_readByteString1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readByteString", r"(J)Lokio/ByteString;");

  /// from: public okio.ByteString readByteString(long j)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString readByteString1(
    int j,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readByteString1,
        jni.JniCallType.objectType,
        [j]).object);
  }

  static final _id_select = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"select", r"(Lokio/Options;)I");

  /// from: public int select(okio.Options options)
  int select(
    Options options,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_select,
        jni.JniCallType.intType, [options.reference]).integer;
  }

  static final _id_readFully = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readFully", r"(Lokio/Buffer;J)V");

  /// from: public void readFully(okio.Buffer buffer, long j)
  void readFully(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_readFully,
        jni.JniCallType.voidType, [buffer.reference, j]).check();
  }

  static final _id_readAll = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readAll", r"(Lokio/Sink;)J");

  /// from: public long readAll(okio.Sink sink)
  int readAll(
    Sink sink,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_readAll,
        jni.JniCallType.longType, [sink.reference]).long;
  }

  static final _id_readUtf8 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUtf8", r"()Ljava/lang/String;");

  /// from: public java.lang.String readUtf8()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf8, jni.JniCallType.objectType, []).object);
  }

  static final _id_readUtf81 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUtf8", r"(J)Ljava/lang/String;");

  /// from: public java.lang.String readUtf8(long j)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf81(
    int j,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf81, jni.JniCallType.objectType, [j]).object);
  }

  static final _id_readString = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readString",
      r"(Ljava/nio/charset/Charset;)Ljava/lang/String;");

  /// from: public java.lang.String readString(java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readString(
    jni.JObject charset,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readString,
        jni.JniCallType.objectType,
        [charset.reference]).object);
  }

  static final _id_readString1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readString",
      r"(JLjava/nio/charset/Charset;)Ljava/lang/String;");

  /// from: public java.lang.String readString(long j, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readString1(
    int j,
    jni.JObject charset,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readString1,
        jni.JniCallType.objectType,
        [j, charset.reference]).object);
  }

  static final _id_readUtf8Line = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readUtf8Line", r"()Ljava/lang/String;");

  /// from: public java.lang.String readUtf8Line()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8Line() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf8Line, jni.JniCallType.objectType, []).object);
  }

  static final _id_readUtf8LineStrict = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readUtf8LineStrict", r"()Ljava/lang/String;");

  /// from: public java.lang.String readUtf8LineStrict()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8LineStrict() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readUtf8LineStrict,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_readUtf8LineStrict1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readUtf8LineStrict", r"(J)Ljava/lang/String;");

  /// from: public java.lang.String readUtf8LineStrict(long j)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8LineStrict1(
    int j,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readUtf8LineStrict1,
        jni.JniCallType.objectType,
        [j]).object);
  }

  static final _id_readUtf8CodePoint = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUtf8CodePoint", r"()I");

  /// from: public int readUtf8CodePoint()
  int readUtf8CodePoint() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf8CodePoint, jni.JniCallType.intType, []).integer;
  }

  static final _id_readByteArray = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readByteArray", r"()[B");

  /// from: public byte[] readByteArray()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> readByteArray() {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readByteArray,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_readByteArray1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readByteArray", r"(J)[B");

  /// from: public byte[] readByteArray(long j)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> readByteArray1(
    int j,
  ) {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readByteArray1,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_read =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"read", r"([B)I");

  /// from: public int read(byte[] bs)
  int read(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_read, jni.JniCallType.intType, [bs.reference]).integer;
  }

  static final _id_readFully1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readFully", r"([B)V");

  /// from: public void readFully(byte[] bs)
  void readFully1(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_readFully1,
        jni.JniCallType.voidType, [bs.reference]).check();
  }

  static final _id_read1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"read", r"([BII)I");

  /// from: public int read(byte[] bs, int i, int i1)
  int read1(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_read1,
        jni.JniCallType.intType,
        [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).integer;
  }

  static final _id_read2 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"read", r"(Ljava/nio/ByteBuffer;)I");

  /// from: public int read(java.nio.ByteBuffer byteBuffer)
  int read2(
    jni.JByteBuffer byteBuffer,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_read2,
        jni.JniCallType.intType, [byteBuffer.reference]).integer;
  }

  static final _id_clear =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"clear", r"()V");

  /// from: public final void clear()
  void clear() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clear, jni.JniCallType.voidType, []).check();
  }

  static final _id_skip =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"skip", r"(J)V");

  /// from: public void skip(long j)
  void skip(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_skip, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_write = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"write", r"(Lokio/ByteString;)Lokio/Buffer;");

  /// from: public okio.Buffer write(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer write(
    ByteString byteString,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_write,
        jni.JniCallType.objectType,
        [byteString.reference]).object);
  }

  static final _id_write1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"write", r"(Lokio/ByteString;II)Lokio/Buffer;");

  /// from: public okio.Buffer write(okio.ByteString byteString, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer write1(
    ByteString byteString,
    int i,
    int i1,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_write1,
        jni.JniCallType.objectType,
        [byteString.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id_writeUtf8 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeUtf8", r"(Ljava/lang/String;)Lokio/Buffer;");

  /// from: public okio.Buffer writeUtf8(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeUtf8(
    jni.JString string,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_writeUtf8,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_writeUtf81 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeUtf8", r"(Ljava/lang/String;II)Lokio/Buffer;");

  /// from: public okio.Buffer writeUtf8(java.lang.String string, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeUtf81(
    jni.JString string,
    int i,
    int i1,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_writeUtf81,
        jni.JniCallType.objectType,
        [string.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id_writeUtf8CodePoint = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeUtf8CodePoint", r"(I)Lokio/Buffer;");

  /// from: public okio.Buffer writeUtf8CodePoint(int i)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeUtf8CodePoint(
    int i,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_writeUtf8CodePoint,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_writeString = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeString",
      r"(Ljava/lang/String;Ljava/nio/charset/Charset;)Lokio/Buffer;");

  /// from: public okio.Buffer writeString(java.lang.String string, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeString(
    jni.JString string,
    jni.JObject charset,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_writeString,
        jni.JniCallType.objectType,
        [string.reference, charset.reference]).object);
  }

  static final _id_writeString1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeString",
      r"(Ljava/lang/String;IILjava/nio/charset/Charset;)Lokio/Buffer;");

  /// from: public okio.Buffer writeString(java.lang.String string, int i, int i1, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeString1(
    jni.JString string,
    int i,
    int i1,
    jni.JObject charset,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_writeString1, jni.JniCallType.objectType, [
      string.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      charset.reference
    ]).object);
  }

  static final _id_write2 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"([B)Lokio/Buffer;");

  /// from: public okio.Buffer write(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer write2(
    jni.JArray<jni.jbyte> bs,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_write2,
        jni.JniCallType.objectType,
        [bs.reference]).object);
  }

  static final _id_write3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"([BII)Lokio/Buffer;");

  /// from: public okio.Buffer write(byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer write3(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_write3,
        jni.JniCallType.objectType,
        [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id_write4 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"(Ljava/nio/ByteBuffer;)I");

  /// from: public int write(java.nio.ByteBuffer byteBuffer)
  int write4(
    jni.JByteBuffer byteBuffer,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write4,
        jni.JniCallType.intType, [byteBuffer.reference]).integer;
  }

  static final _id_writeAll = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeAll", r"(Lokio/Source;)J");

  /// from: public long writeAll(okio.Source source)
  int writeAll(
    Source source,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeAll,
        jni.JniCallType.longType, [source.reference]).long;
  }

  static final _id_write5 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"write", r"(Lokio/Source;J)Lokio/Buffer;");

  /// from: public okio.Buffer write(okio.Source source, long j)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer write5(
    Source source,
    int j,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_write5,
        jni.JniCallType.objectType,
        [source.reference, j]).object);
  }

  static final _id_writeByte = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeByte", r"(I)Lokio/Buffer;");

  /// from: public okio.Buffer writeByte(int i)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeByte(
    int i,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_writeByte,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_writeShort = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeShort", r"(I)Lokio/Buffer;");

  /// from: public okio.Buffer writeShort(int i)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeShort(
    int i,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_writeShort,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_writeShortLe = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeShortLe", r"(I)Lokio/Buffer;");

  /// from: public okio.Buffer writeShortLe(int i)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeShortLe(
    int i,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_writeShortLe,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_writeInt = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeInt", r"(I)Lokio/Buffer;");

  /// from: public okio.Buffer writeInt(int i)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeInt(
    int i,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_writeInt,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_writeIntLe = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeIntLe", r"(I)Lokio/Buffer;");

  /// from: public okio.Buffer writeIntLe(int i)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeIntLe(
    int i,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_writeIntLe,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_writeLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeLong", r"(J)Lokio/Buffer;");

  /// from: public okio.Buffer writeLong(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeLong(
    int j,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_writeLong, jni.JniCallType.objectType, [j]).object);
  }

  static final _id_writeLongLe = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeLongLe", r"(J)Lokio/Buffer;");

  /// from: public okio.Buffer writeLongLe(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeLongLe(
    int j,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_writeLongLe, jni.JniCallType.objectType, [j]).object);
  }

  static final _id_writeDecimalLong = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeDecimalLong", r"(J)Lokio/Buffer;");

  /// from: public okio.Buffer writeDecimalLong(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeDecimalLong(
    int j,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_writeDecimalLong,
        jni.JniCallType.objectType,
        [j]).object);
  }

  static final _id_writeHexadecimalUnsignedLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeHexadecimalUnsignedLong",
          r"(J)Lokio/Buffer;");

  /// from: public okio.Buffer writeHexadecimalUnsignedLong(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeHexadecimalUnsignedLong(
    int j,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_writeHexadecimalUnsignedLong,
        jni.JniCallType.objectType,
        [j]).object);
  }

  static final _id_write6 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"(Lokio/Buffer;J)V");

  /// from: public void write(okio.Buffer buffer, long j)
  void write6(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write6,
        jni.JniCallType.voidType, [buffer.reference, j]).check();
  }

  static final _id_read3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"read", r"(Lokio/Buffer;J)J");

  /// from: public long read(okio.Buffer buffer, long j)
  int read3(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_read3,
        jni.JniCallType.longType, [buffer.reference, j]).long;
  }

  static final _id_indexOf =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"(B)J");

  /// from: public long indexOf(byte b)
  int indexOf(
    int b,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf,
        jni.JniCallType.longType, [jni.JValueByte(b)]).long;
  }

  static final _id_indexOf1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"(BJ)J");

  /// from: public long indexOf(byte b, long j)
  int indexOf1(
    int b,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf1,
        jni.JniCallType.longType, [jni.JValueByte(b), j]).long;
  }

  static final _id_indexOf2 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"(BJJ)J");

  /// from: public long indexOf(byte b, long j, long j1)
  int indexOf2(
    int b,
    int j,
    int j1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf2,
        jni.JniCallType.longType, [jni.JValueByte(b), j, j1]).long;
  }

  static final _id_indexOf3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"indexOf", r"(Lokio/ByteString;)J");

  /// from: public long indexOf(okio.ByteString byteString)
  int indexOf3(
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf3,
        jni.JniCallType.longType, [byteString.reference]).long;
  }

  static final _id_indexOf4 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"indexOf", r"(Lokio/ByteString;J)J");

  /// from: public long indexOf(okio.ByteString byteString, long j)
  int indexOf4(
    ByteString byteString,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf4,
        jni.JniCallType.longType, [byteString.reference, j]).long;
  }

  static final _id_indexOfElement = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"indexOfElement", r"(Lokio/ByteString;)J");

  /// from: public long indexOfElement(okio.ByteString byteString)
  int indexOfElement(
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOfElement,
        jni.JniCallType.longType, [byteString.reference]).long;
  }

  static final _id_indexOfElement1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"indexOfElement", r"(Lokio/ByteString;J)J");

  /// from: public long indexOfElement(okio.ByteString byteString, long j)
  int indexOfElement1(
    ByteString byteString,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOfElement1,
        jni.JniCallType.longType, [byteString.reference, j]).long;
  }

  static final _id_rangeEquals = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"rangeEquals", r"(JLokio/ByteString;)Z");

  /// from: public boolean rangeEquals(long j, okio.ByteString byteString)
  bool rangeEquals(
    int j,
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_rangeEquals,
        jni.JniCallType.booleanType, [j, byteString.reference]).boolean;
  }

  static final _id_rangeEquals1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"rangeEquals", r"(JLokio/ByteString;II)Z");

  /// from: public boolean rangeEquals(long j, okio.ByteString byteString, int i, int i1)
  bool rangeEquals1(
    int j,
    ByteString byteString,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_rangeEquals1,
        jni.JniCallType.booleanType,
        [j, byteString.reference, jni.JValueInt(i), jni.JValueInt(i1)]).boolean;
  }

  static final _id_flush =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"flush", r"()V");

  /// from: public void flush()
  void flush() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_flush, jni.JniCallType.voidType, []).check();
  }

  static final _id_isOpen =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isOpen", r"()Z");

  /// from: public boolean isOpen()
  bool isOpen() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isOpen, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_md5 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"md5", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString md5()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString md5() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_md5, jni.JniCallType.objectType, []).object);
  }

  static final _id_sha1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sha1", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString sha1()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString sha1() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_sha1, jni.JniCallType.objectType, []).object);
  }

  static final _id_sha256 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sha256", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString sha256()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString sha256() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_sha256, jni.JniCallType.objectType, []).object);
  }

  static final _id_sha512 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sha512", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString sha512()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString sha512() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_sha512, jni.JniCallType.objectType, []).object);
  }

  static final _id_hmacSha1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"hmacSha1", r"(Lokio/ByteString;)Lokio/ByteString;");

  /// from: public final okio.ByteString hmacSha1(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString hmacSha1(
    ByteString byteString,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_hmacSha1,
        jni.JniCallType.objectType,
        [byteString.reference]).object);
  }

  static final _id_hmacSha256 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"hmacSha256", r"(Lokio/ByteString;)Lokio/ByteString;");

  /// from: public final okio.ByteString hmacSha256(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString hmacSha256(
    ByteString byteString,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_hmacSha256,
        jni.JniCallType.objectType,
        [byteString.reference]).object);
  }

  static final _id_hmacSha512 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"hmacSha512", r"(Lokio/ByteString;)Lokio/ByteString;");

  /// from: public final okio.ByteString hmacSha512(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString hmacSha512(
    ByteString byteString,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_hmacSha512,
        jni.JniCallType.objectType,
        [byteString.reference]).object);
  }

  static final _id_equals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"equals", r"(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [object.reference]).boolean;
  }

  static final _id_hashCode1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"hashCode", r"()I");

  /// from: public int hashCode()
  int hashCode1() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hashCode1, jni.JniCallType.intType, []).integer;
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id_copy = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"copy", r"()Lokio/Buffer;");

  /// from: public final okio.Buffer copy()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer copy() {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_copy, jni.JniCallType.objectType, []).object);
  }

  static final _id_clone = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clone", r"()Lokio/Buffer;");

  /// from: public okio.Buffer clone()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer clone() {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clone, jni.JniCallType.objectType, []).object);
  }

  static final _id_snapshot = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"snapshot", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString snapshot()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString snapshot() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_snapshot, jni.JniCallType.objectType, []).object);
  }

  static final _id_snapshot1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"snapshot", r"(I)Lokio/ByteString;");

  /// from: public final okio.ByteString snapshot(int i)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString snapshot1(
    int i,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_snapshot1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_readUnsafe = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readUnsafe",
      r"(Lokio/Buffer$UnsafeCursor;)Lokio/Buffer$UnsafeCursor;");

  /// from: public final okio.Buffer$UnsafeCursor readUnsafe(okio.Buffer$UnsafeCursor unsafeCursor)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer_UnsafeCursor readUnsafe(
    Buffer_UnsafeCursor unsafeCursor,
  ) {
    return const $Buffer_UnsafeCursorType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readUnsafe,
            jni.JniCallType.objectType, [unsafeCursor.reference]).object);
  }

  static final _id_readAndWriteUnsafe = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readAndWriteUnsafe",
      r"(Lokio/Buffer$UnsafeCursor;)Lokio/Buffer$UnsafeCursor;");

  /// from: public final okio.Buffer$UnsafeCursor readAndWriteUnsafe(okio.Buffer$UnsafeCursor unsafeCursor)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer_UnsafeCursor readAndWriteUnsafe(
    Buffer_UnsafeCursor unsafeCursor,
  ) {
    return const $Buffer_UnsafeCursorType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readAndWriteUnsafe,
            jni.JniCallType.objectType, [unsafeCursor.reference]).object);
  }

  static final _id__deprecated_getByte = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_getByte", r"(J)B");

  /// from: public final byte -deprecated_getByte(long j)
  int _deprecated_getByte(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id__deprecated_getByte, jni.JniCallType.byteType, [j]).byte;
  }

  static final _id__deprecated_size = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_size", r"()J");

  /// from: public final long -deprecated_size()
  int _deprecated_size() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id__deprecated_size, jni.JniCallType.longType, []).long;
  }

  static final _id_copyTo3 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"copyTo", r"(Ljava/io/OutputStream;J)Lokio/Buffer;");

  /// from: public final okio.Buffer copyTo(java.io.OutputStream outputStream, long j)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer copyTo3(
    jni.JObject outputStream,
    int j,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_copyTo3,
        jni.JniCallType.objectType,
        [outputStream.reference, j]).object);
  }

  static final _id_copyTo4 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"copyTo", r"(Ljava/io/OutputStream;)Lokio/Buffer;");

  /// from: public final okio.Buffer copyTo(java.io.OutputStream outputStream)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer copyTo4(
    jni.JObject outputStream,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_copyTo4,
        jni.JniCallType.objectType,
        [outputStream.reference]).object);
  }

  static final _id_writeTo1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeTo", r"(Ljava/io/OutputStream;)Lokio/Buffer;");

  /// from: public final okio.Buffer writeTo(java.io.OutputStream outputStream)
  /// The returned object must be released after use, by calling the [release] method.
  Buffer writeTo1(
    jni.JObject outputStream,
  ) {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_writeTo1,
        jni.JniCallType.objectType,
        [outputStream.reference]).object);
  }

  static final _id_readUnsafe1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readUnsafe", r"()Lokio/Buffer$UnsafeCursor;");

  /// from: public final okio.Buffer$UnsafeCursor readUnsafe()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer_UnsafeCursor readUnsafe1() {
    return const $Buffer_UnsafeCursorType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_readUnsafe1, jni.JniCallType.objectType, []).object);
  }

  static final _id_readAndWriteUnsafe1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readAndWriteUnsafe", r"()Lokio/Buffer$UnsafeCursor;");

  /// from: public final okio.Buffer$UnsafeCursor readAndWriteUnsafe()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer_UnsafeCursor readAndWriteUnsafe1() {
    return const $Buffer_UnsafeCursorType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readAndWriteUnsafe1,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_emitCompleteSegments1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"emitCompleteSegments", r"()Lokio/BufferedSink;");

  /// from: public okio.BufferedSink emitCompleteSegments()
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink emitCompleteSegments1() {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_emitCompleteSegments1,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_emit1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"emit", r"()Lokio/BufferedSink;");

  /// from: public okio.BufferedSink emit()
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink emit1() {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_emit1, jni.JniCallType.objectType, []).object);
  }

  static final _id_write7 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"write", r"(Lokio/ByteString;)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink write(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write7(
    ByteString byteString,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write7, jni.JniCallType.objectType,
            [byteString.reference]).object);
  }

  static final _id_write8 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"write", r"(Lokio/ByteString;II)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink write(okio.ByteString byteString, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write8(
    ByteString byteString,
    int i,
    int i1,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write8, jni.JniCallType.objectType, [
      byteString.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1)
    ]).object);
  }

  static final _id_writeUtf82 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeUtf8",
      r"(Ljava/lang/String;)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeUtf8(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeUtf82(
    jni.JString string,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeUtf82,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_writeUtf83 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeUtf8",
      r"(Ljava/lang/String;II)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeUtf8(java.lang.String string, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeUtf83(
    jni.JString string,
    int i,
    int i1,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_writeUtf83,
            jni.JniCallType.objectType,
            [string.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id_writeUtf8CodePoint1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeUtf8CodePoint", r"(I)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeUtf8CodePoint(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeUtf8CodePoint1(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeUtf8CodePoint1,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeString2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeString",
      r"(Ljava/lang/String;Ljava/nio/charset/Charset;)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeString(java.lang.String string, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeString2(
    jni.JString string,
    jni.JObject charset,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_writeString2,
            jni.JniCallType.objectType,
            [string.reference, charset.reference]).object);
  }

  static final _id_writeString3 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeString",
      r"(Ljava/lang/String;IILjava/nio/charset/Charset;)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeString(java.lang.String string, int i, int i1, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeString3(
    jni.JString string,
    int i,
    int i1,
    jni.JObject charset,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_writeString3, jni.JniCallType.objectType, [
      string.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      charset.reference
    ]).object);
  }

  static final _id_write9 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"([B)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink write(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write9(
    jni.JArray<jni.jbyte> bs,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write9, jni.JniCallType.objectType,
            [bs.reference]).object);
  }

  static final _id_write10 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"([BII)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink write(byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write10(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write10, jni.JniCallType.objectType,
            [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id_write11 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"write", r"(Lokio/Source;J)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink write(okio.Source source, long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write11(
    Source source,
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write11, jni.JniCallType.objectType,
            [source.reference, j]).object);
  }

  static final _id_writeByte1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeByte", r"(I)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeByte(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeByte1(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeByte1,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeShort1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeShort", r"(I)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeShort(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeShort1(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeShort1,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeShortLe1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeShortLe", r"(I)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeShortLe(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeShortLe1(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeShortLe1,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeInt1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeInt", r"(I)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeInt(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeInt1(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeInt1,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeIntLe1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeIntLe", r"(I)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeIntLe(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeIntLe1(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeIntLe1,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeLong1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeLong", r"(J)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeLong(long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeLong1(
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_writeLong1, jni.JniCallType.objectType, [j]).object);
  }

  static final _id_writeLongLe1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeLongLe", r"(J)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeLongLe(long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeLongLe1(
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeLongLe1,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_writeDecimalLong1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeDecimalLong", r"(J)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeDecimalLong(long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeDecimalLong1(
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeDecimalLong1,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_writeHexadecimalUnsignedLong1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeHexadecimalUnsignedLong",
          r"(J)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeHexadecimalUnsignedLong(long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeHexadecimalUnsignedLong1(
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeHexadecimalUnsignedLong1,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_clone1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clone", r"()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject clone1() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clone1, jni.JniCallType.objectType, []).object);
  }
}

final class $BufferType extends jni.JObjType<Buffer> {
  const $BufferType();

  @override
  String get signature => r"Lokio/Buffer;";

  @override
  Buffer fromRef(jni.JObjectPtr ref) => Buffer.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BufferType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BufferType) && other is $BufferType;
  }
}

/// from: okio.BufferedSink
class BufferedSink extends jni.JObject {
  @override
  late final jni.JObjType<BufferedSink> $type = type;

  BufferedSink.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/BufferedSink");

  /// The type which includes information such as the signature of this class.
  static const type = $BufferedSinkType();
  static final _id_buffer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"buffer", r"()Lokio/Buffer;");

  /// from: public abstract okio.Buffer buffer()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer buffer() {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_buffer, jni.JniCallType.objectType, []).object);
  }

  static final _id_getBuffer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getBuffer", r"()Lokio/Buffer;");

  /// from: public abstract okio.Buffer getBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer getBuffer() {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getBuffer, jni.JniCallType.objectType, []).object);
  }

  static final _id_write = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"write", r"(Lokio/ByteString;)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink write(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write(
    ByteString byteString,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write, jni.JniCallType.objectType,
            [byteString.reference]).object);
  }

  static final _id_write1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"write", r"(Lokio/ByteString;II)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink write(okio.ByteString byteString, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write1(
    ByteString byteString,
    int i,
    int i1,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write1, jni.JniCallType.objectType, [
      byteString.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1)
    ]).object);
  }

  static final _id_write2 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"([B)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink write(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write2(
    jni.JArray<jni.jbyte> bs,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write2, jni.JniCallType.objectType,
            [bs.reference]).object);
  }

  static final _id_write3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"([BII)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink write(byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write3(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write3, jni.JniCallType.objectType,
            [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id_writeAll = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeAll", r"(Lokio/Source;)J");

  /// from: public abstract long writeAll(okio.Source source)
  int writeAll(
    Source source,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeAll,
        jni.JniCallType.longType, [source.reference]).long;
  }

  static final _id_write4 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"write", r"(Lokio/Source;J)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink write(okio.Source source, long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write4(
    Source source,
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write4, jni.JniCallType.objectType,
            [source.reference, j]).object);
  }

  static final _id_writeUtf8 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"writeUtf8", r"(Ljava/lang/String;)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink writeUtf8(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeUtf8(
    jni.JString string,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeUtf8,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_writeUtf81 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeUtf8",
      r"(Ljava/lang/String;II)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink writeUtf8(java.lang.String string, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeUtf81(
    jni.JString string,
    int i,
    int i1,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_writeUtf81,
            jni.JniCallType.objectType,
            [string.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id_writeUtf8CodePoint = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeUtf8CodePoint", r"(I)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink writeUtf8CodePoint(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeUtf8CodePoint(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeUtf8CodePoint,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeString = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeString",
      r"(Ljava/lang/String;Ljava/nio/charset/Charset;)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink writeString(java.lang.String string, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeString(
    jni.JString string,
    jni.JObject charset,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_writeString,
            jni.JniCallType.objectType,
            [string.reference, charset.reference]).object);
  }

  static final _id_writeString1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeString",
      r"(Ljava/lang/String;IILjava/nio/charset/Charset;)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink writeString(java.lang.String string, int i, int i1, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeString1(
    jni.JString string,
    int i,
    int i1,
    jni.JObject charset,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_writeString1, jni.JniCallType.objectType, [
      string.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      charset.reference
    ]).object);
  }

  static final _id_writeByte = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeByte", r"(I)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink writeByte(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeByte(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeByte,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeShort = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeShort", r"(I)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink writeShort(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeShort(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeShort,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeShortLe = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeShortLe", r"(I)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink writeShortLe(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeShortLe(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeShortLe,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeInt = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeInt", r"(I)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink writeInt(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeInt(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeInt, jni.JniCallType.objectType,
            [jni.JValueInt(i)]).object);
  }

  static final _id_writeIntLe = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeIntLe", r"(I)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink writeIntLe(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeIntLe(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeIntLe,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeLong", r"(J)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink writeLong(long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeLong(
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_writeLong, jni.JniCallType.objectType, [j]).object);
  }

  static final _id_writeLongLe = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeLongLe", r"(J)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink writeLongLe(long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeLongLe(
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeLongLe,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_writeDecimalLong = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeDecimalLong", r"(J)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink writeDecimalLong(long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeDecimalLong(
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeDecimalLong,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_writeHexadecimalUnsignedLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeHexadecimalUnsignedLong",
          r"(J)Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink writeHexadecimalUnsignedLong(long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeHexadecimalUnsignedLong(
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeHexadecimalUnsignedLong,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_flush =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"flush", r"()V");

  /// from: public abstract void flush()
  void flush() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_flush, jni.JniCallType.voidType, []).check();
  }

  static final _id_emit = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"emit", r"()Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink emit()
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink emit() {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_emit, jni.JniCallType.objectType, []).object);
  }

  static final _id_emitCompleteSegments = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"emitCompleteSegments", r"()Lokio/BufferedSink;");

  /// from: public abstract okio.BufferedSink emitCompleteSegments()
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink emitCompleteSegments() {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_emitCompleteSegments,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_outputStream = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"outputStream", r"()Ljava/io/OutputStream;");

  /// from: public abstract java.io.OutputStream outputStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject outputStream() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_outputStream, jni.JniCallType.objectType, []).object);
  }
}

final class $BufferedSinkType extends jni.JObjType<BufferedSink> {
  const $BufferedSinkType();

  @override
  String get signature => r"Lokio/BufferedSink;";

  @override
  BufferedSink fromRef(jni.JObjectPtr ref) => BufferedSink.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BufferedSinkType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BufferedSinkType) &&
        other is $BufferedSinkType;
  }
}

/// from: okio.BufferedSource
class BufferedSource extends jni.JObject {
  @override
  late final jni.JObjType<BufferedSource> $type = type;

  BufferedSource.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/BufferedSource");

  /// The type which includes information such as the signature of this class.
  static const type = $BufferedSourceType();
  static final _id_buffer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"buffer", r"()Lokio/Buffer;");

  /// from: public abstract okio.Buffer buffer()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer buffer() {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_buffer, jni.JniCallType.objectType, []).object);
  }

  static final _id_getBuffer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getBuffer", r"()Lokio/Buffer;");

  /// from: public abstract okio.Buffer getBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer getBuffer() {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getBuffer, jni.JniCallType.objectType, []).object);
  }

  static final _id_exhausted =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"exhausted", r"()Z");

  /// from: public abstract boolean exhausted()
  bool exhausted() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_exhausted, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_require =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"require", r"(J)V");

  /// from: public abstract void require(long j)
  void require(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_require, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_request =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"request", r"(J)Z");

  /// from: public abstract boolean request(long j)
  bool request(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_request, jni.JniCallType.booleanType, [j]).boolean;
  }

  static final _id_readByte =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readByte", r"()B");

  /// from: public abstract byte readByte()
  int readByte() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readByte, jni.JniCallType.byteType, []).byte;
  }

  static final _id_readShort =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readShort", r"()S");

  /// from: public abstract short readShort()
  int readShort() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readShort, jni.JniCallType.shortType, []).short;
  }

  static final _id_readShortLe =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readShortLe", r"()S");

  /// from: public abstract short readShortLe()
  int readShortLe() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readShortLe, jni.JniCallType.shortType, []).short;
  }

  static final _id_readInt =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readInt", r"()I");

  /// from: public abstract int readInt()
  int readInt() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readInt, jni.JniCallType.intType, []).integer;
  }

  static final _id_readIntLe =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readIntLe", r"()I");

  /// from: public abstract int readIntLe()
  int readIntLe() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readIntLe, jni.JniCallType.intType, []).integer;
  }

  static final _id_readLong =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readLong", r"()J");

  /// from: public abstract long readLong()
  int readLong() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readLong, jni.JniCallType.longType, []).long;
  }

  static final _id_readLongLe =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readLongLe", r"()J");

  /// from: public abstract long readLongLe()
  int readLongLe() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readLongLe, jni.JniCallType.longType, []).long;
  }

  static final _id_readDecimalLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readDecimalLong", r"()J");

  /// from: public abstract long readDecimalLong()
  int readDecimalLong() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readDecimalLong, jni.JniCallType.longType, []).long;
  }

  static final _id_readHexadecimalUnsignedLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readHexadecimalUnsignedLong", r"()J");

  /// from: public abstract long readHexadecimalUnsignedLong()
  int readHexadecimalUnsignedLong() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_readHexadecimalUnsignedLong, jni.JniCallType.longType, []).long;
  }

  static final _id_skip =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"skip", r"(J)V");

  /// from: public abstract void skip(long j)
  void skip(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_skip, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_readByteString = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readByteString", r"()Lokio/ByteString;");

  /// from: public abstract okio.ByteString readByteString()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString readByteString() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readByteString, jni.JniCallType.objectType, []).object);
  }

  static final _id_readByteString1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readByteString", r"(J)Lokio/ByteString;");

  /// from: public abstract okio.ByteString readByteString(long j)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString readByteString1(
    int j,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readByteString1,
        jni.JniCallType.objectType,
        [j]).object);
  }

  static final _id_select = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"select", r"(Lokio/Options;)I");

  /// from: public abstract int select(okio.Options options)
  int select(
    Options options,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_select,
        jni.JniCallType.intType, [options.reference]).integer;
  }

  static final _id_readByteArray = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readByteArray", r"()[B");

  /// from: public abstract byte[] readByteArray()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> readByteArray() {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readByteArray,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_readByteArray1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readByteArray", r"(J)[B");

  /// from: public abstract byte[] readByteArray(long j)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> readByteArray1(
    int j,
  ) {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readByteArray1,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_read =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"read", r"([B)I");

  /// from: public abstract int read(byte[] bs)
  int read(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_read, jni.JniCallType.intType, [bs.reference]).integer;
  }

  static final _id_readFully =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readFully", r"([B)V");

  /// from: public abstract void readFully(byte[] bs)
  void readFully(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_readFully,
        jni.JniCallType.voidType, [bs.reference]).check();
  }

  static final _id_read1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"read", r"([BII)I");

  /// from: public abstract int read(byte[] bs, int i, int i1)
  int read1(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_read1,
        jni.JniCallType.intType,
        [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).integer;
  }

  static final _id_readFully1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readFully", r"(Lokio/Buffer;J)V");

  /// from: public abstract void readFully(okio.Buffer buffer, long j)
  void readFully1(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_readFully1,
        jni.JniCallType.voidType, [buffer.reference, j]).check();
  }

  static final _id_readAll = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readAll", r"(Lokio/Sink;)J");

  /// from: public abstract long readAll(okio.Sink sink)
  int readAll(
    Sink sink,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_readAll,
        jni.JniCallType.longType, [sink.reference]).long;
  }

  static final _id_readUtf8 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUtf8", r"()Ljava/lang/String;");

  /// from: public abstract java.lang.String readUtf8()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf8, jni.JniCallType.objectType, []).object);
  }

  static final _id_readUtf81 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUtf8", r"(J)Ljava/lang/String;");

  /// from: public abstract java.lang.String readUtf8(long j)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf81(
    int j,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf81, jni.JniCallType.objectType, [j]).object);
  }

  static final _id_readUtf8Line = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readUtf8Line", r"()Ljava/lang/String;");

  /// from: public abstract java.lang.String readUtf8Line()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8Line() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf8Line, jni.JniCallType.objectType, []).object);
  }

  static final _id_readUtf8LineStrict = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readUtf8LineStrict", r"()Ljava/lang/String;");

  /// from: public abstract java.lang.String readUtf8LineStrict()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8LineStrict() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readUtf8LineStrict,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_readUtf8LineStrict1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readUtf8LineStrict", r"(J)Ljava/lang/String;");

  /// from: public abstract java.lang.String readUtf8LineStrict(long j)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8LineStrict1(
    int j,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readUtf8LineStrict1,
        jni.JniCallType.objectType,
        [j]).object);
  }

  static final _id_readUtf8CodePoint = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUtf8CodePoint", r"()I");

  /// from: public abstract int readUtf8CodePoint()
  int readUtf8CodePoint() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf8CodePoint, jni.JniCallType.intType, []).integer;
  }

  static final _id_readString = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readString",
      r"(Ljava/nio/charset/Charset;)Ljava/lang/String;");

  /// from: public abstract java.lang.String readString(java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readString(
    jni.JObject charset,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readString,
        jni.JniCallType.objectType,
        [charset.reference]).object);
  }

  static final _id_readString1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readString",
      r"(JLjava/nio/charset/Charset;)Ljava/lang/String;");

  /// from: public abstract java.lang.String readString(long j, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readString1(
    int j,
    jni.JObject charset,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readString1,
        jni.JniCallType.objectType,
        [j, charset.reference]).object);
  }

  static final _id_indexOf =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"(B)J");

  /// from: public abstract long indexOf(byte b)
  int indexOf(
    int b,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf,
        jni.JniCallType.longType, [jni.JValueByte(b)]).long;
  }

  static final _id_indexOf1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"(BJ)J");

  /// from: public abstract long indexOf(byte b, long j)
  int indexOf1(
    int b,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf1,
        jni.JniCallType.longType, [jni.JValueByte(b), j]).long;
  }

  static final _id_indexOf2 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"(BJJ)J");

  /// from: public abstract long indexOf(byte b, long j, long j1)
  int indexOf2(
    int b,
    int j,
    int j1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf2,
        jni.JniCallType.longType, [jni.JValueByte(b), j, j1]).long;
  }

  static final _id_indexOf3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"indexOf", r"(Lokio/ByteString;)J");

  /// from: public abstract long indexOf(okio.ByteString byteString)
  int indexOf3(
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf3,
        jni.JniCallType.longType, [byteString.reference]).long;
  }

  static final _id_indexOf4 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"indexOf", r"(Lokio/ByteString;J)J");

  /// from: public abstract long indexOf(okio.ByteString byteString, long j)
  int indexOf4(
    ByteString byteString,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf4,
        jni.JniCallType.longType, [byteString.reference, j]).long;
  }

  static final _id_indexOfElement = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"indexOfElement", r"(Lokio/ByteString;)J");

  /// from: public abstract long indexOfElement(okio.ByteString byteString)
  int indexOfElement(
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOfElement,
        jni.JniCallType.longType, [byteString.reference]).long;
  }

  static final _id_indexOfElement1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"indexOfElement", r"(Lokio/ByteString;J)J");

  /// from: public abstract long indexOfElement(okio.ByteString byteString, long j)
  int indexOfElement1(
    ByteString byteString,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOfElement1,
        jni.JniCallType.longType, [byteString.reference, j]).long;
  }

  static final _id_rangeEquals = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"rangeEquals", r"(JLokio/ByteString;)Z");

  /// from: public abstract boolean rangeEquals(long j, okio.ByteString byteString)
  bool rangeEquals(
    int j,
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_rangeEquals,
        jni.JniCallType.booleanType, [j, byteString.reference]).boolean;
  }

  static final _id_rangeEquals1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"rangeEquals", r"(JLokio/ByteString;II)Z");

  /// from: public abstract boolean rangeEquals(long j, okio.ByteString byteString, int i, int i1)
  bool rangeEquals1(
    int j,
    ByteString byteString,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_rangeEquals1,
        jni.JniCallType.booleanType,
        [j, byteString.reference, jni.JValueInt(i), jni.JValueInt(i1)]).boolean;
  }

  static final _id_peek = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"peek", r"()Lokio/BufferedSource;");

  /// from: public abstract okio.BufferedSource peek()
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSource peek() {
    return const $BufferedSourceType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_peek, jni.JniCallType.objectType, []).object);
  }

  static final _id_inputStream = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"inputStream", r"()Ljava/io/InputStream;");

  /// from: public abstract java.io.InputStream inputStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject inputStream() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_inputStream, jni.JniCallType.objectType, []).object);
  }
}

final class $BufferedSourceType extends jni.JObjType<BufferedSource> {
  const $BufferedSourceType();

  @override
  String get signature => r"Lokio/BufferedSource;";

  @override
  BufferedSource fromRef(jni.JObjectPtr ref) => BufferedSource.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BufferedSourceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BufferedSourceType) &&
        other is $BufferedSourceType;
  }
}

/// from: okio.ByteString$Companion
class ByteString_Companion extends jni.JObject {
  @override
  late final jni.JObjType<ByteString_Companion> $type = type;

  ByteString_Companion.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/ByteString$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $ByteString_CompanionType();
  static final _id_of = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"of", r"([B)Lokio/ByteString;");

  /// from: public final okio.ByteString of(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString of(
    jni.JArray<jni.jbyte> bs,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_of, jni.JniCallType.objectType, [bs.reference]).object);
  }

  static final _id_of1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"of", r"([BII)Lokio/ByteString;");

  /// from: public final okio.ByteString of(byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString of1(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_of1,
        jni.JniCallType.objectType,
        [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id_of2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"of", r"(Ljava/nio/ByteBuffer;)Lokio/ByteString;");

  /// from: public final okio.ByteString of(java.nio.ByteBuffer byteBuffer)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString of2(
    jni.JByteBuffer byteBuffer,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_of2,
        jni.JniCallType.objectType,
        [byteBuffer.reference]).object);
  }

  static final _id_encodeUtf8 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"encodeUtf8",
      r"(Ljava/lang/String;)Lokio/ByteString;");

  /// from: public final okio.ByteString encodeUtf8(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString encodeUtf8(
    jni.JString string,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_encodeUtf8,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_encodeString = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"encodeString",
      r"(Ljava/lang/String;Ljava/nio/charset/Charset;)Lokio/ByteString;");

  /// from: public final okio.ByteString encodeString(java.lang.String string, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString encodeString(
    jni.JString string,
    jni.JObject charset,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_encodeString,
        jni.JniCallType.objectType,
        [string.reference, charset.reference]).object);
  }

  static final _id_decodeBase64 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"decodeBase64",
      r"(Ljava/lang/String;)Lokio/ByteString;");

  /// from: public final okio.ByteString decodeBase64(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString decodeBase64(
    jni.JString string,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_decodeBase64,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_decodeHex = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"decodeHex", r"(Ljava/lang/String;)Lokio/ByteString;");

  /// from: public final okio.ByteString decodeHex(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString decodeHex(
    jni.JString string,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_decodeHex,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_read = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"read", r"(Ljava/io/InputStream;I)Lokio/ByteString;");

  /// from: public final okio.ByteString read(java.io.InputStream inputStream, int i)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString read(
    jni.JObject inputStream,
    int i,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_read,
        jni.JniCallType.objectType,
        [inputStream.reference, jni.JValueInt(i)]).object);
  }

  static final _id__deprecated_decodeBase64 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_decodeBase64",
      r"(Ljava/lang/String;)Lokio/ByteString;");

  /// from: public final okio.ByteString -deprecated_decodeBase64(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString _deprecated_decodeBase64(
    jni.JString string,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_decodeBase64,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id__deprecated_decodeHex = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_decodeHex",
      r"(Ljava/lang/String;)Lokio/ByteString;");

  /// from: public final okio.ByteString -deprecated_decodeHex(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString _deprecated_decodeHex(
    jni.JString string,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_decodeHex,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id__deprecated_encodeString = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_encodeString",
      r"(Ljava/lang/String;Ljava/nio/charset/Charset;)Lokio/ByteString;");

  /// from: public final okio.ByteString -deprecated_encodeString(java.lang.String string, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString _deprecated_encodeString(
    jni.JString string,
    jni.JObject charset,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_encodeString,
        jni.JniCallType.objectType,
        [string.reference, charset.reference]).object);
  }

  static final _id__deprecated_encodeUtf8 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_encodeUtf8",
      r"(Ljava/lang/String;)Lokio/ByteString;");

  /// from: public final okio.ByteString -deprecated_encodeUtf8(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString _deprecated_encodeUtf8(
    jni.JString string,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_encodeUtf8,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id__deprecated_of = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_of",
      r"(Ljava/nio/ByteBuffer;)Lokio/ByteString;");

  /// from: public final okio.ByteString -deprecated_of(java.nio.ByteBuffer byteBuffer)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString _deprecated_of(
    jni.JByteBuffer byteBuffer,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_of,
        jni.JniCallType.objectType,
        [byteBuffer.reference]).object);
  }

  static final _id__deprecated_of1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_of", r"([BII)Lokio/ByteString;");

  /// from: public final okio.ByteString -deprecated_of(byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString _deprecated_of1(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_of1,
        jni.JniCallType.objectType,
        [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id__deprecated_read = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_read",
      r"(Ljava/io/InputStream;I)Lokio/ByteString;");

  /// from: public final okio.ByteString -deprecated_read(java.io.InputStream inputStream, int i)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString _deprecated_read(
    jni.JObject inputStream,
    int i,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_read,
        jni.JniCallType.objectType,
        [inputStream.reference, jni.JValueInt(i)]).object);
  }

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory ByteString_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return ByteString_Companion.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [defaultConstructorMarker.reference]).object);
  }
}

final class $ByteString_CompanionType
    extends jni.JObjType<ByteString_Companion> {
  const $ByteString_CompanionType();

  @override
  String get signature => r"Lokio/ByteString$Companion;";

  @override
  ByteString_Companion fromRef(jni.JObjectPtr ref) =>
      ByteString_Companion.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ByteString_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ByteString_CompanionType) &&
        other is $ByteString_CompanionType;
  }
}

/// from: okio.ByteString
class ByteString extends jni.JObject {
  @override
  late final jni.JObjType<ByteString> $type = type;

  ByteString.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/ByteString");

  /// The type which includes information such as the signature of this class.
  static const type = $ByteStringType();
  static final _id_Companion = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Companion",
    r"Lokio/ByteString$Companion;",
  );

  /// from: static public final okio.ByteString$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString_Companion get Companion =>
      const $ByteString_CompanionType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_Companion, jni.JniCallType.objectType)
          .object);

  static final _id_EMPTY = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"EMPTY",
    r"Lokio/ByteString;",
  );

  /// from: static public final okio.ByteString EMPTY
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString get EMPTY => const $ByteStringType().fromRef(jni
      .Jni.accessors
      .getStaticField(_class.reference, _id_EMPTY, jni.JniCallType.objectType)
      .object);

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"([B)V");

  /// from: public void <init>(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  factory ByteString(
    jni.JArray<jni.jbyte> bs,
  ) {
    return ByteString.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, [bs.reference]).object);
  }

  static final _id_utf8 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"utf8", r"()Ljava/lang/String;");

  /// from: public java.lang.String utf8()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString utf8() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_utf8, jni.JniCallType.objectType, []).object);
  }

  static final _id_string = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"string", r"(Ljava/nio/charset/Charset;)Ljava/lang/String;");

  /// from: public java.lang.String string(java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString string(
    jni.JObject charset,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_string,
        jni.JniCallType.objectType,
        [charset.reference]).object);
  }

  static final _id_base64 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"base64", r"()Ljava/lang/String;");

  /// from: public java.lang.String base64()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString base64() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_base64, jni.JniCallType.objectType, []).object);
  }

  static final _id_md5 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"md5", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString md5()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString md5() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_md5, jni.JniCallType.objectType, []).object);
  }

  static final _id_sha1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sha1", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString sha1()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString sha1() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_sha1, jni.JniCallType.objectType, []).object);
  }

  static final _id_sha256 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sha256", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString sha256()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString sha256() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_sha256, jni.JniCallType.objectType, []).object);
  }

  static final _id_sha512 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sha512", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString sha512()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString sha512() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_sha512, jni.JniCallType.objectType, []).object);
  }

  static final _id_hmacSha1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"hmacSha1", r"(Lokio/ByteString;)Lokio/ByteString;");

  /// from: public okio.ByteString hmacSha1(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString hmacSha1(
    ByteString byteString,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_hmacSha1,
        jni.JniCallType.objectType,
        [byteString.reference]).object);
  }

  static final _id_hmacSha256 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"hmacSha256", r"(Lokio/ByteString;)Lokio/ByteString;");

  /// from: public okio.ByteString hmacSha256(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString hmacSha256(
    ByteString byteString,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_hmacSha256,
        jni.JniCallType.objectType,
        [byteString.reference]).object);
  }

  static final _id_hmacSha512 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"hmacSha512", r"(Lokio/ByteString;)Lokio/ByteString;");

  /// from: public okio.ByteString hmacSha512(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString hmacSha512(
    ByteString byteString,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_hmacSha512,
        jni.JniCallType.objectType,
        [byteString.reference]).object);
  }

  static final _id_base64Url = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"base64Url", r"()Ljava/lang/String;");

  /// from: public java.lang.String base64Url()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString base64Url() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_base64Url, jni.JniCallType.objectType, []).object);
  }

  static final _id_hex = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"hex", r"()Ljava/lang/String;");

  /// from: public java.lang.String hex()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString hex() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hex, jni.JniCallType.objectType, []).object);
  }

  static final _id_toAsciiLowercase = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"toAsciiLowercase", r"()Lokio/ByteString;");

  /// from: public okio.ByteString toAsciiLowercase()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString toAsciiLowercase() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_toAsciiLowercase,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_toAsciiUppercase = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"toAsciiUppercase", r"()Lokio/ByteString;");

  /// from: public okio.ByteString toAsciiUppercase()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString toAsciiUppercase() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_toAsciiUppercase,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_substring = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"substring", r"(II)Lokio/ByteString;");

  /// from: public okio.ByteString substring(int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString substring(
    int i,
    int i1,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_substring,
        jni.JniCallType.objectType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id_getByte =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getByte", r"(I)B");

  /// from: public final byte getByte(int i)
  int getByte(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_getByte,
        jni.JniCallType.byteType, [jni.JValueInt(i)]).byte;
  }

  static final _id_size =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"size", r"()I");

  /// from: public final int size()
  int size() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_size, jni.JniCallType.intType, []).integer;
  }

  static final _id_toByteArray = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toByteArray", r"()[B");

  /// from: public byte[] toByteArray()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> toByteArray() {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_toByteArray, jni.JniCallType.objectType, []).object);
  }

  static final _id_asByteBuffer = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"asByteBuffer", r"()Ljava/nio/ByteBuffer;");

  /// from: public java.nio.ByteBuffer asByteBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JByteBuffer asByteBuffer() {
    return const jni.JByteBufferType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_asByteBuffer,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_write = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"(Ljava/io/OutputStream;)V");

  /// from: public void write(java.io.OutputStream outputStream)
  void write(
    jni.JObject outputStream,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write,
        jni.JniCallType.voidType, [outputStream.reference]).check();
  }

  static final _id_rangeEquals = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"rangeEquals", r"(ILokio/ByteString;II)Z");

  /// from: public boolean rangeEquals(int i, okio.ByteString byteString, int i1, int i2)
  bool rangeEquals(
    int i,
    ByteString byteString,
    int i1,
    int i2,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_rangeEquals, jni.JniCallType.booleanType, [
      jni.JValueInt(i),
      byteString.reference,
      jni.JValueInt(i1),
      jni.JValueInt(i2)
    ]).boolean;
  }

  static final _id_rangeEquals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"rangeEquals", r"(I[BII)Z");

  /// from: public boolean rangeEquals(int i, byte[] bs, int i1, int i2)
  bool rangeEquals1(
    int i,
    jni.JArray<jni.jbyte> bs,
    int i1,
    int i2,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_rangeEquals1, jni.JniCallType.booleanType, [
      jni.JValueInt(i),
      bs.reference,
      jni.JValueInt(i1),
      jni.JValueInt(i2)
    ]).boolean;
  }

  static final _id_copyInto = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"copyInto", r"(I[BII)V");

  /// from: public void copyInto(int i, byte[] bs, int i1, int i2)
  void copyInto(
    int i,
    jni.JArray<jni.jbyte> bs,
    int i1,
    int i2,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_copyInto, jni.JniCallType.voidType, [
      jni.JValueInt(i),
      bs.reference,
      jni.JValueInt(i1),
      jni.JValueInt(i2)
    ]).check();
  }

  static final _id_startsWith = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"startsWith", r"(Lokio/ByteString;)Z");

  /// from: public final boolean startsWith(okio.ByteString byteString)
  bool startsWith(
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_startsWith,
        jni.JniCallType.booleanType, [byteString.reference]).boolean;
  }

  static final _id_startsWith1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"startsWith", r"([B)Z");

  /// from: public final boolean startsWith(byte[] bs)
  bool startsWith1(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_startsWith1,
        jni.JniCallType.booleanType, [bs.reference]).boolean;
  }

  static final _id_endsWith = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"endsWith", r"(Lokio/ByteString;)Z");

  /// from: public final boolean endsWith(okio.ByteString byteString)
  bool endsWith(
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_endsWith,
        jni.JniCallType.booleanType, [byteString.reference]).boolean;
  }

  static final _id_endsWith1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"endsWith", r"([B)Z");

  /// from: public final boolean endsWith(byte[] bs)
  bool endsWith1(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_endsWith1,
        jni.JniCallType.booleanType, [bs.reference]).boolean;
  }

  static final _id_indexOf = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"indexOf", r"(Lokio/ByteString;I)I");

  /// from: public final int indexOf(okio.ByteString byteString, int i)
  int indexOf(
    ByteString byteString,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_indexOf,
        jni.JniCallType.intType,
        [byteString.reference, jni.JValueInt(i)]).integer;
  }

  static final _id_indexOf1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"([BI)I");

  /// from: public int indexOf(byte[] bs, int i)
  int indexOf1(
    jni.JArray<jni.jbyte> bs,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf1,
        jni.JniCallType.intType, [bs.reference, jni.JValueInt(i)]).integer;
  }

  static final _id_lastIndexOf = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"lastIndexOf", r"(Lokio/ByteString;I)I");

  /// from: public final int lastIndexOf(okio.ByteString byteString, int i)
  int lastIndexOf(
    ByteString byteString,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_lastIndexOf,
        jni.JniCallType.intType,
        [byteString.reference, jni.JValueInt(i)]).integer;
  }

  static final _id_lastIndexOf1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"lastIndexOf", r"([BI)I");

  /// from: public int lastIndexOf(byte[] bs, int i)
  int lastIndexOf1(
    jni.JArray<jni.jbyte> bs,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_lastIndexOf1,
        jni.JniCallType.intType, [bs.reference, jni.JValueInt(i)]).integer;
  }

  static final _id_equals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"equals", r"(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [object.reference]).boolean;
  }

  static final _id_hashCode1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"hashCode", r"()I");

  /// from: public int hashCode()
  int hashCode1() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hashCode1, jni.JniCallType.intType, []).integer;
  }

  static final _id_compareTo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"compareTo", r"(Lokio/ByteString;)I");

  /// from: public int compareTo(okio.ByteString byteString)
  int compareTo(
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_compareTo,
        jni.JniCallType.intType, [byteString.reference]).integer;
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_getByte = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_getByte", r"(I)B");

  /// from: public final byte -deprecated_getByte(int i)
  int _deprecated_getByte(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_getByte,
        jni.JniCallType.byteType,
        [jni.JValueInt(i)]).byte;
  }

  static final _id__deprecated_size = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_size", r"()I");

  /// from: public final int -deprecated_size()
  int _deprecated_size() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id__deprecated_size, jni.JniCallType.intType, []).integer;
  }

  static final _id_substring1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"substring", r"(I)Lokio/ByteString;");

  /// from: public final okio.ByteString substring(int i)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString substring1(
    int i,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_substring1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_substring2 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"substring", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString substring()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString substring2() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_substring2, jni.JniCallType.objectType, []).object);
  }

  static final _id_indexOf2 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"indexOf", r"(Lokio/ByteString;)I");

  /// from: public final int indexOf(okio.ByteString byteString)
  int indexOf2(
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf2,
        jni.JniCallType.intType, [byteString.reference]).integer;
  }

  static final _id_indexOf3 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"([B)I");

  /// from: public final int indexOf(byte[] bs)
  int indexOf3(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf3,
        jni.JniCallType.intType, [bs.reference]).integer;
  }

  static final _id_lastIndexOf2 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"lastIndexOf", r"(Lokio/ByteString;)I");

  /// from: public final int lastIndexOf(okio.ByteString byteString)
  int lastIndexOf2(
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_lastIndexOf2,
        jni.JniCallType.intType, [byteString.reference]).integer;
  }

  static final _id_lastIndexOf3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"lastIndexOf", r"([B)I");

  /// from: public final int lastIndexOf(byte[] bs)
  int lastIndexOf3(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_lastIndexOf3,
        jni.JniCallType.intType, [bs.reference]).integer;
  }

  static final _id_of = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"of", r"([B)Lokio/ByteString;");

  /// from: static public final okio.ByteString of(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString of(
    jni.JArray<jni.jbyte> bs,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_of,
            jni.JniCallType.objectType, [bs.reference]).object);
  }

  static final _id_of1 = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"of", r"([BII)Lokio/ByteString;");

  /// from: static public final okio.ByteString of(byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString of1(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_of1,
            jni.JniCallType.objectType,
            [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id_of2 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"of", r"(Ljava/nio/ByteBuffer;)Lokio/ByteString;");

  /// from: static public final okio.ByteString of(java.nio.ByteBuffer byteBuffer)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString of2(
    jni.JByteBuffer byteBuffer,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_of2,
            jni.JniCallType.objectType, [byteBuffer.reference]).object);
  }

  static final _id_encodeUtf8 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"encodeUtf8",
      r"(Ljava/lang/String;)Lokio/ByteString;");

  /// from: static public final okio.ByteString encodeUtf8(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString encodeUtf8(
    jni.JString string,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_encodeUtf8,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_encodeString = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"encodeString",
      r"(Ljava/lang/String;Ljava/nio/charset/Charset;)Lokio/ByteString;");

  /// from: static public final okio.ByteString encodeString(java.lang.String string, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString encodeString(
    jni.JString string,
    jni.JObject charset,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_encodeString,
            jni.JniCallType.objectType,
            [string.reference, charset.reference]).object);
  }

  static final _id_decodeBase64 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"decodeBase64",
      r"(Ljava/lang/String;)Lokio/ByteString;");

  /// from: static public final okio.ByteString decodeBase64(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString decodeBase64(
    jni.JString string,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_decodeBase64,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_decodeHex = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"decodeHex", r"(Ljava/lang/String;)Lokio/ByteString;");

  /// from: static public final okio.ByteString decodeHex(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString decodeHex(
    jni.JString string,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_decodeHex,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_read = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"read", r"(Ljava/io/InputStream;I)Lokio/ByteString;");

  /// from: static public final okio.ByteString read(java.io.InputStream inputStream, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString read(
    jni.JObject inputStream,
    int i,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_read,
            jni.JniCallType.objectType,
            [inputStream.reference, jni.JValueInt(i)]).object);
  }

  static final _id_compareTo1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"compareTo", r"(Ljava/lang/Object;)I");

  /// from: public int compareTo(java.lang.Object object)
  int compareTo1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_compareTo1,
        jni.JniCallType.intType, [object.reference]).integer;
  }
}

final class $ByteStringType extends jni.JObjType<ByteString> {
  const $ByteStringType();

  @override
  String get signature => r"Lokio/ByteString;";

  @override
  ByteString fromRef(jni.JObjectPtr ref) => ByteString.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ByteStringType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ByteStringType) && other is $ByteStringType;
  }
}

/// from: okio.CipherSink
class CipherSink extends jni.JObject {
  @override
  late final jni.JObjType<CipherSink> $type = type;

  CipherSink.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/CipherSink");

  /// The type which includes information such as the signature of this class.
  static const type = $CipherSinkType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lokio/BufferedSink;Ljavax/crypto/Cipher;)V");

  /// from: public void <init>(okio.BufferedSink bufferedSink, javax.crypto.Cipher cipher)
  /// The returned object must be released after use, by calling the [release] method.
  factory CipherSink(
    BufferedSink bufferedSink,
    jni.JObject cipher,
  ) {
    return CipherSink.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [bufferedSink.reference, cipher.reference]).object);
  }

  static final _id_getCipher = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getCipher", r"()Ljavax/crypto/Cipher;");

  /// from: public final javax.crypto.Cipher getCipher()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCipher() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getCipher, jni.JniCallType.objectType, []).object);
  }

  static final _id_write = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"(Lokio/Buffer;J)V");

  /// from: public void write(okio.Buffer buffer, long j)
  void write(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write,
        jni.JniCallType.voidType, [buffer.reference, j]).check();
  }

  static final _id_flush =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"flush", r"()V");

  /// from: public void flush()
  void flush() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_flush, jni.JniCallType.voidType, []).check();
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }
}

final class $CipherSinkType extends jni.JObjType<CipherSink> {
  const $CipherSinkType();

  @override
  String get signature => r"Lokio/CipherSink;";

  @override
  CipherSink fromRef(jni.JObjectPtr ref) => CipherSink.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CipherSinkType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CipherSinkType) && other is $CipherSinkType;
  }
}

/// from: okio.CipherSource
class CipherSource extends jni.JObject {
  @override
  late final jni.JObjType<CipherSource> $type = type;

  CipherSource.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/CipherSource");

  /// The type which includes information such as the signature of this class.
  static const type = $CipherSourceType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lokio/BufferedSource;Ljavax/crypto/Cipher;)V");

  /// from: public void <init>(okio.BufferedSource bufferedSource, javax.crypto.Cipher cipher)
  /// The returned object must be released after use, by calling the [release] method.
  factory CipherSource(
    BufferedSource bufferedSource,
    jni.JObject cipher,
  ) {
    return CipherSource.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [bufferedSource.reference, cipher.reference]).object);
  }

  static final _id_getCipher = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getCipher", r"()Ljavax/crypto/Cipher;");

  /// from: public final javax.crypto.Cipher getCipher()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCipher() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getCipher, jni.JniCallType.objectType, []).object);
  }

  static final _id_read = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"read", r"(Lokio/Buffer;J)J");

  /// from: public long read(okio.Buffer buffer, long j)
  int read(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_read,
        jni.JniCallType.longType, [buffer.reference, j]).long;
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }
}

final class $CipherSourceType extends jni.JObjType<CipherSource> {
  const $CipherSourceType();

  @override
  String get signature => r"Lokio/CipherSource;";

  @override
  CipherSource fromRef(jni.JObjectPtr ref) => CipherSource.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CipherSourceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CipherSourceType) &&
        other is $CipherSourceType;
  }
}

/// from: okio.DeflaterSink
class DeflaterSink extends jni.JObject {
  @override
  late final jni.JObjType<DeflaterSink> $type = type;

  DeflaterSink.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/DeflaterSink");

  /// The type which includes information such as the signature of this class.
  static const type = $DeflaterSinkType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lokio/BufferedSink;Ljava/util/zip/Deflater;)V");

  /// from: public void <init>(okio.BufferedSink bufferedSink, java.util.zip.Deflater deflater)
  /// The returned object must be released after use, by calling the [release] method.
  factory DeflaterSink(
    BufferedSink bufferedSink,
    jni.JObject deflater,
  ) {
    return DeflaterSink.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [bufferedSink.reference, deflater.reference]).object);
  }

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Lokio/Sink;Ljava/util/zip/Deflater;)V");

  /// from: public void <init>(okio.Sink sink, java.util.zip.Deflater deflater)
  /// The returned object must be released after use, by calling the [release] method.
  factory DeflaterSink.new1(
    Sink sink,
    jni.JObject deflater,
  ) {
    return DeflaterSink.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new1,
        [sink.reference, deflater.reference]).object);
  }

  static final _id_write = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"(Lokio/Buffer;J)V");

  /// from: public void write(okio.Buffer buffer, long j)
  void write(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write,
        jni.JniCallType.voidType, [buffer.reference, j]).check();
  }

  static final _id_flush =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"flush", r"()V");

  /// from: public void flush()
  void flush() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_flush, jni.JniCallType.voidType, []).check();
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }
}

final class $DeflaterSinkType extends jni.JObjType<DeflaterSink> {
  const $DeflaterSinkType();

  @override
  String get signature => r"Lokio/DeflaterSink;";

  @override
  DeflaterSink fromRef(jni.JObjectPtr ref) => DeflaterSink.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($DeflaterSinkType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($DeflaterSinkType) &&
        other is $DeflaterSinkType;
  }
}

/// from: okio.ExperimentalFileSystem
class ExperimentalFileSystem extends jni.JObject {
  @override
  late final jni.JObjType<ExperimentalFileSystem> $type = type;

  ExperimentalFileSystem.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/ExperimentalFileSystem");

  /// The type which includes information such as the signature of this class.
  static const type = $ExperimentalFileSystemType();
}

final class $ExperimentalFileSystemType
    extends jni.JObjType<ExperimentalFileSystem> {
  const $ExperimentalFileSystemType();

  @override
  String get signature => r"Lokio/ExperimentalFileSystem;";

  @override
  ExperimentalFileSystem fromRef(jni.JObjectPtr ref) =>
      ExperimentalFileSystem.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExperimentalFileSystemType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ExperimentalFileSystemType) &&
        other is $ExperimentalFileSystemType;
  }
}

/// from: okio.FileHandle
class FileHandle extends jni.JObject {
  @override
  late final jni.JObjType<FileHandle> $type = type;

  FileHandle.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/FileHandle");

  /// The type which includes information such as the signature of this class.
  static const type = $FileHandleType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"(Z)V");

  /// from: public void <init>(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  factory FileHandle(
    bool z,
  ) {
    return FileHandle.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, [z ? 1 : 0]).object);
  }

  static final _id_getReadWrite = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getReadWrite", r"()Z");

  /// from: public final boolean getReadWrite()
  bool getReadWrite() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getReadWrite, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getLock = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"getLock", r"()Ljava/util/concurrent/locks/ReentrantLock;");

  /// from: public final java.util.concurrent.locks.ReentrantLock getLock()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getLock() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getLock, jni.JniCallType.objectType, []).object);
  }

  static final _id_read =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"read", r"(J[BII)I");

  /// from: public final int read(long j, byte[] bs, int i, int i1)
  int read(
    int j,
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_read,
        jni.JniCallType.intType,
        [j, bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).integer;
  }

  static final _id_read1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"read", r"(JLokio/Buffer;J)J");

  /// from: public final long read(long j, okio.Buffer buffer, long j1)
  int read1(
    int j,
    Buffer buffer,
    int j1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_read1,
        jni.JniCallType.longType, [j, buffer.reference, j1]).long;
  }

  static final _id_size =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"size", r"()J");

  /// from: public final long size()
  int size() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_size, jni.JniCallType.longType, []).long;
  }

  static final _id_resize =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"resize", r"(J)V");

  /// from: public final void resize(long j)
  void resize(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_resize, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_write =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"write", r"(J[BII)V");

  /// from: public final void write(long j, byte[] bs, int i, int i1)
  void write(
    int j,
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_write,
        jni.JniCallType.voidType,
        [j, bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_write1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"(JLokio/Buffer;J)V");

  /// from: public final void write(long j, okio.Buffer buffer, long j1)
  void write1(
    int j,
    Buffer buffer,
    int j1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write1,
        jni.JniCallType.voidType, [j, buffer.reference, j1]).check();
  }

  static final _id_flush =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"flush", r"()V");

  /// from: public final void flush()
  void flush() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_flush, jni.JniCallType.voidType, []).check();
  }

  static final _id_source = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"source", r"(J)Lokio/Source;");

  /// from: public final okio.Source source(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Source source(
    int j,
  ) {
    return const $SourceType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_source, jni.JniCallType.objectType, [j]).object);
  }

  static final _id_position = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"position", r"(Lokio/Source;)J");

  /// from: public final long position(okio.Source source)
  int position(
    Source source,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_position,
        jni.JniCallType.longType, [source.reference]).long;
  }

  static final _id_reposition = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"reposition", r"(Lokio/Source;J)V");

  /// from: public final void reposition(okio.Source source, long j)
  void reposition(
    Source source,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_reposition,
        jni.JniCallType.voidType, [source.reference, j]).check();
  }

  static final _id_sink = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sink", r"(J)Lokio/Sink;");

  /// from: public final okio.Sink sink(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Sink sink(
    int j,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_sink, jni.JniCallType.objectType, [j]).object);
  }

  static final _id_appendingSink = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"appendingSink", r"()Lokio/Sink;");

  /// from: public final okio.Sink appendingSink()
  /// The returned object must be released after use, by calling the [release] method.
  Sink appendingSink() {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_appendingSink, jni.JniCallType.objectType, []).object);
  }

  static final _id_position1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"position", r"(Lokio/Sink;)J");

  /// from: public final long position(okio.Sink sink)
  int position1(
    Sink sink,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_position1,
        jni.JniCallType.longType, [sink.reference]).long;
  }

  static final _id_reposition1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"reposition", r"(Lokio/Sink;J)V");

  /// from: public final void reposition(okio.Sink sink, long j)
  void reposition1(
    Sink sink,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_reposition1,
        jni.JniCallType.voidType, [sink.reference, j]).check();
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public final void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_protectedRead = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedRead", r"(J[BII)I");

  /// from: protected abstract int protectedRead(long j, byte[] bs, int i, int i1)
  int protectedRead(
    int j,
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_protectedRead,
        jni.JniCallType.intType,
        [j, bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).integer;
  }

  static final _id_protectedWrite = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedWrite", r"(J[BII)V");

  /// from: protected abstract void protectedWrite(long j, byte[] bs, int i, int i1)
  void protectedWrite(
    int j,
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_protectedWrite,
        jni.JniCallType.voidType,
        [j, bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_protectedFlush = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedFlush", r"()V");

  /// from: protected abstract void protectedFlush()
  void protectedFlush() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protectedFlush, jni.JniCallType.voidType, []).check();
  }

  static final _id_protectedResize = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedResize", r"(J)V");

  /// from: protected abstract void protectedResize(long j)
  void protectedResize(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protectedResize, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_protectedSize = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedSize", r"()J");

  /// from: protected abstract long protectedSize()
  int protectedSize() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protectedSize, jni.JniCallType.longType, []).long;
  }

  static final _id_protectedClose = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedClose", r"()V");

  /// from: protected abstract void protectedClose()
  void protectedClose() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protectedClose, jni.JniCallType.voidType, []).check();
  }
}

final class $FileHandleType extends jni.JObjType<FileHandle> {
  const $FileHandleType();

  @override
  String get signature => r"Lokio/FileHandle;";

  @override
  FileHandle fromRef(jni.JObjectPtr ref) => FileHandle.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FileHandleType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileHandleType) && other is $FileHandleType;
  }
}

/// from: okio.FileMetadata
class FileMetadata extends jni.JObject {
  @override
  late final jni.JObjType<FileMetadata> $type = type;

  FileMetadata.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/FileMetadata");

  /// The type which includes information such as the signature of this class.
  static const type = $FileMetadataType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(ZZLokio/Path;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Long;Ljava/util/Map;)V");

  /// from: public void <init>(boolean z, boolean z1, okio.Path path, java.lang.Long long, java.lang.Long long1, java.lang.Long long2, java.lang.Long long3, java.util.Map map)
  /// The returned object must be released after use, by calling the [release] method.
  factory FileMetadata(
    bool z,
    bool z1,
    Path path,
    jni.JLong long,
    jni.JLong long1,
    jni.JLong long2,
    jni.JLong long3,
    jni.JMap<jni.JObject, jni.JObject> map,
  ) {
    return FileMetadata.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new0, [
      z ? 1 : 0,
      z1 ? 1 : 0,
      path.reference,
      long.reference,
      long1.reference,
      long2.reference,
      long3.reference,
      map.reference
    ]).object);
  }

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(ZZLokio/Path;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Long;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(boolean z, boolean z1, okio.Path path, java.lang.Long long, java.lang.Long long1, java.lang.Long long2, java.lang.Long long3, java.util.Map map, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory FileMetadata.new1(
    bool z,
    bool z1,
    Path path,
    jni.JLong long,
    jni.JLong long1,
    jni.JLong long2,
    jni.JLong long3,
    jni.JMap<jni.JObject, jni.JObject> map,
    int i,
    jni.JObject defaultConstructorMarker,
  ) {
    return FileMetadata.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new1, [
      z ? 1 : 0,
      z1 ? 1 : 0,
      path.reference,
      long.reference,
      long1.reference,
      long2.reference,
      long3.reference,
      map.reference,
      jni.JValueInt(i),
      defaultConstructorMarker.reference
    ]).object);
  }

  static final _id_isRegularFile = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isRegularFile", r"()Z");

  /// from: public final boolean isRegularFile()
  bool isRegularFile() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isRegularFile, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isDirectory =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isDirectory", r"()Z");

  /// from: public final boolean isDirectory()
  bool isDirectory() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isDirectory, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getSymlinkTarget = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getSymlinkTarget", r"()Lokio/Path;");

  /// from: public final okio.Path getSymlinkTarget()
  /// The returned object must be released after use, by calling the [release] method.
  Path getSymlinkTarget() {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getSymlinkTarget,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getSize = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getSize", r"()Ljava/lang/Long;");

  /// from: public final java.lang.Long getSize()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JLong getSize() {
    return const jni.JLongType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getSize, jni.JniCallType.objectType, []).object);
  }

  static final _id_getCreatedAtMillis = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getCreatedAtMillis", r"()Ljava/lang/Long;");

  /// from: public final java.lang.Long getCreatedAtMillis()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JLong getCreatedAtMillis() {
    return const jni.JLongType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getCreatedAtMillis,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getLastModifiedAtMillis = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getLastModifiedAtMillis", r"()Ljava/lang/Long;");

  /// from: public final java.lang.Long getLastModifiedAtMillis()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JLong getLastModifiedAtMillis() {
    return const jni.JLongType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getLastModifiedAtMillis,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getLastAccessedAtMillis = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getLastAccessedAtMillis", r"()Ljava/lang/Long;");

  /// from: public final java.lang.Long getLastAccessedAtMillis()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JLong getLastAccessedAtMillis() {
    return const jni.JLongType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getLastAccessedAtMillis,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getExtras = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getExtras", r"()Ljava/util/Map;");

  /// from: public final java.util.Map getExtras()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JMap<jni.JObject, jni.JObject> getExtras() {
    return const jni.JMapType(jni.JObjectType(), jni.JObjectType()).fromRef(
        jni.Jni.accessors.callMethodWithArgs(
            reference, _id_getExtras, jni.JniCallType.objectType, []).object);
  }

  static final _id_extra = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"extra", r"(Lkotlin/reflect/KClass;)Ljava/lang/Object;");

  /// from: public final T extra(kotlin.reflect.KClass kClass)
  /// The returned object must be released after use, by calling the [release] method.
  $T extra<$T extends jni.JObject>(
    jni.JObject kClass, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jni.Jni.accessors.callMethodWithArgs(reference, _id_extra,
        jni.JniCallType.objectType, [kClass.reference]).object);
  }

  static final _id_copy = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"copy",
      r"(ZZLokio/Path;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Long;Ljava/lang/Long;Ljava/util/Map;)Lokio/FileMetadata;");

  /// from: public final okio.FileMetadata copy(boolean z, boolean z1, okio.Path path, java.lang.Long long, java.lang.Long long1, java.lang.Long long2, java.lang.Long long3, java.util.Map map)
  /// The returned object must be released after use, by calling the [release] method.
  FileMetadata copy(
    bool z,
    bool z1,
    Path path,
    jni.JLong long,
    jni.JLong long1,
    jni.JLong long2,
    jni.JLong long3,
    jni.JMap<jni.JObject, jni.JObject> map,
  ) {
    return const $FileMetadataType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_copy, jni.JniCallType.objectType, [
      z ? 1 : 0,
      z1 ? 1 : 0,
      path.reference,
      long.reference,
      long1.reference,
      long2.reference,
      long3.reference,
      map.reference
    ]).object);
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id_new2 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory FileMetadata.new2() {
    return FileMetadata.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new2, []).object);
  }
}

final class $FileMetadataType extends jni.JObjType<FileMetadata> {
  const $FileMetadataType();

  @override
  String get signature => r"Lokio/FileMetadata;";

  @override
  FileMetadata fromRef(jni.JObjectPtr ref) => FileMetadata.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FileMetadataType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileMetadataType) &&
        other is $FileMetadataType;
  }
}

/// from: okio.FileSystem$Companion
class FileSystem_Companion extends jni.JObject {
  @override
  late final jni.JObjType<FileSystem_Companion> $type = type;

  FileSystem_Companion.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/FileSystem$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $FileSystem_CompanionType();
  static final _id_get0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"get", r"(Ljava/nio/file/FileSystem;)Lokio/FileSystem;");

  /// from: public final okio.FileSystem get(java.nio.file.FileSystem fileSystem)
  /// The returned object must be released after use, by calling the [release] method.
  FileSystem get0(
    jni.JObject fileSystem,
  ) {
    return const $FileSystemType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get0,
        jni.JniCallType.objectType,
        [fileSystem.reference]).object);
  }

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory FileSystem_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return FileSystem_Companion.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [defaultConstructorMarker.reference]).object);
  }
}

final class $FileSystem_CompanionType
    extends jni.JObjType<FileSystem_Companion> {
  const $FileSystem_CompanionType();

  @override
  String get signature => r"Lokio/FileSystem$Companion;";

  @override
  FileSystem_Companion fromRef(jni.JObjectPtr ref) =>
      FileSystem_Companion.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FileSystem_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileSystem_CompanionType) &&
        other is $FileSystem_CompanionType;
  }
}

/// from: okio.FileSystem
class FileSystem extends jni.JObject {
  @override
  late final jni.JObjType<FileSystem> $type = type;

  FileSystem.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/FileSystem");

  /// The type which includes information such as the signature of this class.
  static const type = $FileSystemType();
  static final _id_Companion = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Companion",
    r"Lokio/FileSystem$Companion;",
  );

  /// from: static public final okio.FileSystem$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static FileSystem_Companion get Companion =>
      const $FileSystem_CompanionType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_Companion, jni.JniCallType.objectType)
          .object);

  static final _id_SYSTEM = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"SYSTEM",
    r"Lokio/FileSystem;",
  );

  /// from: static public final okio.FileSystem SYSTEM
  /// The returned object must be released after use, by calling the [release] method.
  static FileSystem get SYSTEM => const $FileSystemType().fromRef(jni
      .Jni.accessors
      .getStaticField(_class.reference, _id_SYSTEM, jni.JniCallType.objectType)
      .object);

  static final _id_SYSTEM_TEMPORARY_DIRECTORY =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"SYSTEM_TEMPORARY_DIRECTORY",
    r"Lokio/Path;",
  );

  /// from: static public final okio.Path SYSTEM_TEMPORARY_DIRECTORY
  /// The returned object must be released after use, by calling the [release] method.
  static Path get SYSTEM_TEMPORARY_DIRECTORY =>
      const $PathType().fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_SYSTEM_TEMPORARY_DIRECTORY,
              jni.JniCallType.objectType)
          .object);

  static final _id_RESOURCES = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"RESOURCES",
    r"Lokio/FileSystem;",
  );

  /// from: static public final okio.FileSystem RESOURCES
  /// The returned object must be released after use, by calling the [release] method.
  static FileSystem get RESOURCES =>
      const $FileSystemType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_RESOURCES, jni.JniCallType.objectType)
          .object);

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory FileSystem() {
    return FileSystem.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_canonicalize = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"canonicalize", r"(Lokio/Path;)Lokio/Path;");

  /// from: public abstract okio.Path canonicalize(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Path canonicalize(
    Path path,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_canonicalize,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_metadata = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"metadata", r"(Lokio/Path;)Lokio/FileMetadata;");

  /// from: public final okio.FileMetadata metadata(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileMetadata metadata(
    Path path,
  ) {
    return const $FileMetadataType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_metadata, jni.JniCallType.objectType,
            [path.reference]).object);
  }

  static final _id_metadataOrNull = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"metadataOrNull", r"(Lokio/Path;)Lokio/FileMetadata;");

  /// from: public abstract okio.FileMetadata metadataOrNull(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileMetadata metadataOrNull(
    Path path,
  ) {
    return const $FileMetadataType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_metadataOrNull,
            jni.JniCallType.objectType, [path.reference]).object);
  }

  static final _id_exists = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"exists", r"(Lokio/Path;)Z");

  /// from: public final boolean exists(okio.Path path)
  bool exists(
    Path path,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_exists,
        jni.JniCallType.booleanType, [path.reference]).boolean;
  }

  static final _id_list = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"list", r"(Lokio/Path;)Ljava/util/List;");

  /// from: public abstract java.util.List list(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Path> list(
    Path path,
  ) {
    return const jni.JListType($PathType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_list, jni.JniCallType.objectType,
            [path.reference]).object);
  }

  static final _id_listOrNull = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"listOrNull", r"(Lokio/Path;)Ljava/util/List;");

  /// from: public abstract java.util.List listOrNull(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Path> listOrNull(
    Path path,
  ) {
    return const jni.JListType($PathType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_listOrNull,
            jni.JniCallType.objectType, [path.reference]).object);
  }

  static final _id_listRecursively = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"listRecursively",
      r"(Lokio/Path;Z)Lkotlin/sequences/Sequence;");

  /// from: public kotlin.sequences.Sequence listRecursively(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject listRecursively(
    Path path,
    bool z,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_listRecursively,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_listRecursively1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"listRecursively",
      r"(Lokio/Path;)Lkotlin/sequences/Sequence;");

  /// from: public final kotlin.sequences.Sequence listRecursively(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject listRecursively1(
    Path path,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_listRecursively1,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_openReadOnly = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"openReadOnly", r"(Lokio/Path;)Lokio/FileHandle;");

  /// from: public abstract okio.FileHandle openReadOnly(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileHandle openReadOnly(
    Path path,
  ) {
    return const $FileHandleType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openReadOnly,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_openReadWrite = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"openReadWrite", r"(Lokio/Path;ZZ)Lokio/FileHandle;");

  /// from: public abstract okio.FileHandle openReadWrite(okio.Path path, boolean z, boolean z1)
  /// The returned object must be released after use, by calling the [release] method.
  FileHandle openReadWrite(
    Path path,
    bool z,
    bool z1,
  ) {
    return const $FileHandleType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openReadWrite,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0, z1 ? 1 : 0]).object);
  }

  static final _id_openReadWrite1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"openReadWrite", r"(Lokio/Path;)Lokio/FileHandle;");

  /// from: public final okio.FileHandle openReadWrite(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileHandle openReadWrite1(
    Path path,
  ) {
    return const $FileHandleType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openReadWrite1,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_source = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"source", r"(Lokio/Path;)Lokio/Source;");

  /// from: public abstract okio.Source source(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Source source(
    Path path,
  ) {
    return const $SourceType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_source,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id__read = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-read",
      r"(Lokio/Path;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;");

  /// from: public final T -read(okio.Path path, kotlin.jvm.functions.Function1 function1)
  /// The returned object must be released after use, by calling the [release] method.
  $T _read<$T extends jni.JObject>(
    Path path,
    jni.JObject function1, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__read,
        jni.JniCallType.objectType,
        [path.reference, function1.reference]).object);
  }

  static final _id_sink = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sink", r"(Lokio/Path;Z)Lokio/Sink;");

  /// from: public abstract okio.Sink sink(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Sink sink(
    Path path,
    bool z,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sink,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_sink1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sink", r"(Lokio/Path;)Lokio/Sink;");

  /// from: public final okio.Sink sink(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Sink sink1(
    Path path,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sink1,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id__write = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-write",
      r"(Lokio/Path;ZLkotlin/jvm/functions/Function1;)Ljava/lang/Object;");

  /// from: public final T -write(okio.Path path, boolean z, kotlin.jvm.functions.Function1 function1)
  /// The returned object must be released after use, by calling the [release] method.
  $T _write<$T extends jni.JObject>(
    Path path,
    bool z,
    jni.JObject function1, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__write,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0, function1.reference]).object);
  }

  static final _id_appendingSink = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"appendingSink", r"(Lokio/Path;Z)Lokio/Sink;");

  /// from: public abstract okio.Sink appendingSink(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Sink appendingSink(
    Path path,
    bool z,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_appendingSink,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_appendingSink1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"appendingSink", r"(Lokio/Path;)Lokio/Sink;");

  /// from: public final okio.Sink appendingSink(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Sink appendingSink1(
    Path path,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_appendingSink1,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_createDirectory = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"createDirectory", r"(Lokio/Path;Z)V");

  /// from: public abstract void createDirectory(okio.Path path, boolean z)
  void createDirectory(
    Path path,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_createDirectory,
        jni.JniCallType.voidType, [path.reference, z ? 1 : 0]).check();
  }

  static final _id_createDirectory1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"createDirectory", r"(Lokio/Path;)V");

  /// from: public final void createDirectory(okio.Path path)
  void createDirectory1(
    Path path,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_createDirectory1,
        jni.JniCallType.voidType, [path.reference]).check();
  }

  static final _id_createDirectories = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"createDirectories", r"(Lokio/Path;Z)V");

  /// from: public final void createDirectories(okio.Path path, boolean z)
  void createDirectories(
    Path path,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_createDirectories,
        jni.JniCallType.voidType,
        [path.reference, z ? 1 : 0]).check();
  }

  static final _id_createDirectories1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"createDirectories", r"(Lokio/Path;)V");

  /// from: public final void createDirectories(okio.Path path)
  void createDirectories1(
    Path path,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_createDirectories1,
        jni.JniCallType.voidType,
        [path.reference]).check();
  }

  static final _id_atomicMove = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"atomicMove", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public abstract void atomicMove(okio.Path path, okio.Path path1)
  void atomicMove(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_atomicMove,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }

  static final _id_copy = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"copy", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public void copy(okio.Path path, okio.Path path1)
  void copy(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_copy,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }

  static final _id_delete = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"delete", r"(Lokio/Path;Z)V");

  /// from: public abstract void delete(okio.Path path, boolean z)
  void delete(
    Path path,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_delete,
        jni.JniCallType.voidType, [path.reference, z ? 1 : 0]).check();
  }

  static final _id_delete1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"delete", r"(Lokio/Path;)V");

  /// from: public final void delete(okio.Path path)
  void delete1(
    Path path,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_delete1,
        jni.JniCallType.voidType, [path.reference]).check();
  }

  static final _id_deleteRecursively = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"deleteRecursively", r"(Lokio/Path;Z)V");

  /// from: public void deleteRecursively(okio.Path path, boolean z)
  void deleteRecursively(
    Path path,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_deleteRecursively,
        jni.JniCallType.voidType,
        [path.reference, z ? 1 : 0]).check();
  }

  static final _id_deleteRecursively1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"deleteRecursively", r"(Lokio/Path;)V");

  /// from: public final void deleteRecursively(okio.Path path)
  void deleteRecursively1(
    Path path,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_deleteRecursively1,
        jni.JniCallType.voidType,
        [path.reference]).check();
  }

  static final _id_createSymlink = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"createSymlink", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public abstract void createSymlink(okio.Path path, okio.Path path1)
  void createSymlink(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_createSymlink,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }

  static final _id_get0 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"get",
      r"(Ljava/nio/file/FileSystem;)Lokio/FileSystem;");

  /// from: static public final okio.FileSystem get(java.nio.file.FileSystem fileSystem)
  /// The returned object must be released after use, by calling the [release] method.
  static FileSystem get0(
    jni.JObject fileSystem,
  ) {
    return const $FileSystemType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_get0,
            jni.JniCallType.objectType, [fileSystem.reference]).object);
  }
}

final class $FileSystemType extends jni.JObjType<FileSystem> {
  const $FileSystemType();

  @override
  String get signature => r"Lokio/FileSystem;";

  @override
  FileSystem fromRef(jni.JObjectPtr ref) => FileSystem.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FileSystemType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileSystemType) && other is $FileSystemType;
  }
}

/// from: okio.ForwardingFileSystem
class ForwardingFileSystem extends FileSystem {
  @override
  late final jni.JObjType<ForwardingFileSystem> $type = type;

  ForwardingFileSystem.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/ForwardingFileSystem");

  /// The type which includes information such as the signature of this class.
  static const type = $ForwardingFileSystemType();
  static final _id_new1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Lokio/FileSystem;)V");

  /// from: public void <init>(okio.FileSystem fileSystem)
  /// The returned object must be released after use, by calling the [release] method.
  factory ForwardingFileSystem.new1(
    FileSystem fileSystem,
  ) {
    return ForwardingFileSystem.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new1, [fileSystem.reference]).object);
  }

  static final _id_delegate = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"delegate", r"()Lokio/FileSystem;");

  /// from: public final okio.FileSystem delegate()
  /// The returned object must be released after use, by calling the [release] method.
  FileSystem delegate() {
    return const $FileSystemType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_delegate, jni.JniCallType.objectType, []).object);
  }

  static final _id_onPathParameter = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onPathParameter",
      r"(Lokio/Path;Ljava/lang/String;Ljava/lang/String;)Lokio/Path;");

  /// from: public okio.Path onPathParameter(okio.Path path, java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Path onPathParameter(
    Path path,
    jni.JString string,
    jni.JString string1,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onPathParameter,
        jni.JniCallType.objectType,
        [path.reference, string.reference, string1.reference]).object);
  }

  static final _id_onPathResult = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"onPathResult",
      r"(Lokio/Path;Ljava/lang/String;)Lokio/Path;");

  /// from: public okio.Path onPathResult(okio.Path path, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Path onPathResult(
    Path path,
    jni.JString string,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onPathResult,
        jni.JniCallType.objectType,
        [path.reference, string.reference]).object);
  }

  static final _id_canonicalize = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"canonicalize", r"(Lokio/Path;)Lokio/Path;");

  /// from: public okio.Path canonicalize(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Path canonicalize(
    Path path,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_canonicalize,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_metadataOrNull = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"metadataOrNull", r"(Lokio/Path;)Lokio/FileMetadata;");

  /// from: public okio.FileMetadata metadataOrNull(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileMetadata metadataOrNull(
    Path path,
  ) {
    return const $FileMetadataType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_metadataOrNull,
            jni.JniCallType.objectType, [path.reference]).object);
  }

  static final _id_list = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"list", r"(Lokio/Path;)Ljava/util/List;");

  /// from: public java.util.List list(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Path> list(
    Path path,
  ) {
    return const jni.JListType($PathType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_list, jni.JniCallType.objectType,
            [path.reference]).object);
  }

  static final _id_listOrNull = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"listOrNull", r"(Lokio/Path;)Ljava/util/List;");

  /// from: public java.util.List listOrNull(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Path> listOrNull(
    Path path,
  ) {
    return const jni.JListType($PathType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_listOrNull,
            jni.JniCallType.objectType, [path.reference]).object);
  }

  static final _id_listRecursively = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"listRecursively",
      r"(Lokio/Path;Z)Lkotlin/sequences/Sequence;");

  /// from: public kotlin.sequences.Sequence listRecursively(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject listRecursively(
    Path path,
    bool z,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_listRecursively,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_openReadOnly = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"openReadOnly", r"(Lokio/Path;)Lokio/FileHandle;");

  /// from: public okio.FileHandle openReadOnly(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileHandle openReadOnly(
    Path path,
  ) {
    return const $FileHandleType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openReadOnly,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_openReadWrite = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"openReadWrite", r"(Lokio/Path;ZZ)Lokio/FileHandle;");

  /// from: public okio.FileHandle openReadWrite(okio.Path path, boolean z, boolean z1)
  /// The returned object must be released after use, by calling the [release] method.
  FileHandle openReadWrite(
    Path path,
    bool z,
    bool z1,
  ) {
    return const $FileHandleType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openReadWrite,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0, z1 ? 1 : 0]).object);
  }

  static final _id_source = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"source", r"(Lokio/Path;)Lokio/Source;");

  /// from: public okio.Source source(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Source source(
    Path path,
  ) {
    return const $SourceType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_source,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_sink = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sink", r"(Lokio/Path;Z)Lokio/Sink;");

  /// from: public okio.Sink sink(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Sink sink(
    Path path,
    bool z,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sink,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_appendingSink = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"appendingSink", r"(Lokio/Path;Z)Lokio/Sink;");

  /// from: public okio.Sink appendingSink(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Sink appendingSink(
    Path path,
    bool z,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_appendingSink,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_createDirectory = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"createDirectory", r"(Lokio/Path;Z)V");

  /// from: public void createDirectory(okio.Path path, boolean z)
  void createDirectory(
    Path path,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_createDirectory,
        jni.JniCallType.voidType, [path.reference, z ? 1 : 0]).check();
  }

  static final _id_atomicMove = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"atomicMove", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public void atomicMove(okio.Path path, okio.Path path1)
  void atomicMove(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_atomicMove,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }

  static final _id_delete = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"delete", r"(Lokio/Path;Z)V");

  /// from: public void delete(okio.Path path, boolean z)
  void delete(
    Path path,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_delete,
        jni.JniCallType.voidType, [path.reference, z ? 1 : 0]).check();
  }

  static final _id_createSymlink = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"createSymlink", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public void createSymlink(okio.Path path, okio.Path path1)
  void createSymlink(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_createSymlink,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }
}

final class $ForwardingFileSystemType
    extends jni.JObjType<ForwardingFileSystem> {
  const $ForwardingFileSystemType();

  @override
  String get signature => r"Lokio/ForwardingFileSystem;";

  @override
  ForwardingFileSystem fromRef(jni.JObjectPtr ref) =>
      ForwardingFileSystem.fromRef(ref);

  @override
  jni.JObjType get superType => const $FileSystemType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($ForwardingFileSystemType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ForwardingFileSystemType) &&
        other is $ForwardingFileSystemType;
  }
}

/// from: okio.ForwardingSink
class ForwardingSink extends jni.JObject {
  @override
  late final jni.JObjType<ForwardingSink> $type = type;

  ForwardingSink.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/ForwardingSink");

  /// The type which includes information such as the signature of this class.
  static const type = $ForwardingSinkType();
  static final _id_new0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Lokio/Sink;)V");

  /// from: public void <init>(okio.Sink sink)
  /// The returned object must be released after use, by calling the [release] method.
  factory ForwardingSink(
    Sink sink,
  ) {
    return ForwardingSink.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [sink.reference]).object);
  }

  static final _id_delegate = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"delegate", r"()Lokio/Sink;");

  /// from: public final okio.Sink delegate()
  /// The returned object must be released after use, by calling the [release] method.
  Sink delegate() {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_delegate, jni.JniCallType.objectType, []).object);
  }

  static final _id_write = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"(Lokio/Buffer;J)V");

  /// from: public void write(okio.Buffer buffer, long j)
  void write(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write,
        jni.JniCallType.voidType, [buffer.reference, j]).check();
  }

  static final _id_flush =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"flush", r"()V");

  /// from: public void flush()
  void flush() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_flush, jni.JniCallType.voidType, []).check();
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_delegate = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_delegate", r"()Lokio/Sink;");

  /// from: public final okio.Sink -deprecated_delegate()
  /// The returned object must be released after use, by calling the [release] method.
  Sink _deprecated_delegate() {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_delegate,
        jni.JniCallType.objectType, []).object);
  }
}

final class $ForwardingSinkType extends jni.JObjType<ForwardingSink> {
  const $ForwardingSinkType();

  @override
  String get signature => r"Lokio/ForwardingSink;";

  @override
  ForwardingSink fromRef(jni.JObjectPtr ref) => ForwardingSink.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ForwardingSinkType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ForwardingSinkType) &&
        other is $ForwardingSinkType;
  }
}

/// from: okio.ForwardingSource
class ForwardingSource extends jni.JObject {
  @override
  late final jni.JObjType<ForwardingSource> $type = type;

  ForwardingSource.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/ForwardingSource");

  /// The type which includes information such as the signature of this class.
  static const type = $ForwardingSourceType();
  static final _id_new0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Lokio/Source;)V");

  /// from: public void <init>(okio.Source source)
  /// The returned object must be released after use, by calling the [release] method.
  factory ForwardingSource(
    Source source,
  ) {
    return ForwardingSource.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [source.reference]).object);
  }

  static final _id_delegate = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"delegate", r"()Lokio/Source;");

  /// from: public final okio.Source delegate()
  /// The returned object must be released after use, by calling the [release] method.
  Source delegate() {
    return const $SourceType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_delegate, jni.JniCallType.objectType, []).object);
  }

  static final _id_read = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"read", r"(Lokio/Buffer;J)J");

  /// from: public long read(okio.Buffer buffer, long j)
  int read(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_read,
        jni.JniCallType.longType, [buffer.reference, j]).long;
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_delegate = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_delegate", r"()Lokio/Source;");

  /// from: public final okio.Source -deprecated_delegate()
  /// The returned object must be released after use, by calling the [release] method.
  Source _deprecated_delegate() {
    return const $SourceType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_delegate,
        jni.JniCallType.objectType, []).object);
  }
}

final class $ForwardingSourceType extends jni.JObjType<ForwardingSource> {
  const $ForwardingSourceType();

  @override
  String get signature => r"Lokio/ForwardingSource;";

  @override
  ForwardingSource fromRef(jni.JObjectPtr ref) => ForwardingSource.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ForwardingSourceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ForwardingSourceType) &&
        other is $ForwardingSourceType;
  }
}

/// from: okio.ForwardingTimeout
class ForwardingTimeout extends Timeout {
  @override
  late final jni.JObjType<ForwardingTimeout> $type = type;

  ForwardingTimeout.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/ForwardingTimeout");

  /// The type which includes information such as the signature of this class.
  static const type = $ForwardingTimeoutType();
  static final _id_new1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Lokio/Timeout;)V");

  /// from: public void <init>(okio.Timeout timeout)
  /// The returned object must be released after use, by calling the [release] method.
  factory ForwardingTimeout.new1(
    Timeout timeout,
  ) {
    return ForwardingTimeout.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new1, [timeout.reference]).object);
  }

  static final _id_delegate = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"delegate", r"()Lokio/Timeout;");

  /// from: public final okio.Timeout delegate()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout delegate() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_delegate, jni.JniCallType.objectType, []).object);
  }

  static final _id_setDelegate = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"setDelegate", r"(Lokio/Timeout;)V");

  /// from: public final void setDelegate(okio.Timeout timeout)
  void setDelegate(
    Timeout timeout,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_setDelegate,
        jni.JniCallType.voidType, [timeout.reference]).check();
  }

  static final _id_setDelegate1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setDelegate",
      r"(Lokio/Timeout;)Lokio/ForwardingTimeout;");

  /// from: public final okio.ForwardingTimeout setDelegate(okio.Timeout timeout)
  /// The returned object must be released after use, by calling the [release] method.
  ForwardingTimeout setDelegate1(
    Timeout timeout,
  ) {
    return const $ForwardingTimeoutType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setDelegate1,
            jni.JniCallType.objectType, [timeout.reference]).object);
  }

  static final _id_timeout = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"timeout", r"(JLjava/util/concurrent/TimeUnit;)Lokio/Timeout;");

  /// from: public okio.Timeout timeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_timeout,
        jni.JniCallType.objectType,
        [j, timeUnit.reference]).object);
  }

  static final _id_timeoutNanos = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeoutNanos", r"()J");

  /// from: public long timeoutNanos()
  int timeoutNanos() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeoutNanos, jni.JniCallType.longType, []).long;
  }

  static final _id_hasDeadline =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"hasDeadline", r"()Z");

  /// from: public boolean hasDeadline()
  bool hasDeadline() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hasDeadline, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_deadlineNanoTime = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"deadlineNanoTime", r"()J");

  /// from: public long deadlineNanoTime()
  int deadlineNanoTime() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_deadlineNanoTime, jni.JniCallType.longType, []).long;
  }

  static final _id_deadlineNanoTime1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"deadlineNanoTime", r"(J)Lokio/Timeout;");

  /// from: public okio.Timeout deadlineNanoTime(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Timeout deadlineNanoTime1(
    int j,
  ) {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_deadlineNanoTime1,
        jni.JniCallType.objectType,
        [j]).object);
  }

  static final _id_clearTimeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clearTimeout", r"()Lokio/Timeout;");

  /// from: public okio.Timeout clearTimeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout clearTimeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clearTimeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_clearDeadline = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clearDeadline", r"()Lokio/Timeout;");

  /// from: public okio.Timeout clearDeadline()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout clearDeadline() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clearDeadline, jni.JniCallType.objectType, []).object);
  }

  static final _id_throwIfReached = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"throwIfReached", r"()V");

  /// from: public void throwIfReached()
  void throwIfReached() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_throwIfReached, jni.JniCallType.voidType, []).check();
  }
}

final class $ForwardingTimeoutType extends jni.JObjType<ForwardingTimeout> {
  const $ForwardingTimeoutType();

  @override
  String get signature => r"Lokio/ForwardingTimeout;";

  @override
  ForwardingTimeout fromRef(jni.JObjectPtr ref) =>
      ForwardingTimeout.fromRef(ref);

  @override
  jni.JObjType get superType => const $TimeoutType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($ForwardingTimeoutType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ForwardingTimeoutType) &&
        other is $ForwardingTimeoutType;
  }
}

/// from: okio.GzipSink
class GzipSink extends jni.JObject {
  @override
  late final jni.JObjType<GzipSink> $type = type;

  GzipSink.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/GzipSink");

  /// The type which includes information such as the signature of this class.
  static const type = $GzipSinkType();
  static final _id_new0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Lokio/Sink;)V");

  /// from: public void <init>(okio.Sink sink)
  /// The returned object must be released after use, by calling the [release] method.
  factory GzipSink(
    Sink sink,
  ) {
    return GzipSink.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [sink.reference]).object);
  }

  static final _id_deflater = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"deflater", r"()Ljava/util/zip/Deflater;");

  /// from: public final java.util.zip.Deflater deflater()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject deflater() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_deflater, jni.JniCallType.objectType, []).object);
  }

  static final _id_write = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"(Lokio/Buffer;J)V");

  /// from: public void write(okio.Buffer buffer, long j)
  void write(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write,
        jni.JniCallType.voidType, [buffer.reference, j]).check();
  }

  static final _id_flush =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"flush", r"()V");

  /// from: public void flush()
  void flush() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_flush, jni.JniCallType.voidType, []).check();
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id__deprecated_deflater = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_deflater", r"()Ljava/util/zip/Deflater;");

  /// from: public final java.util.zip.Deflater -deprecated_deflater()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_deflater() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_deflater,
        jni.JniCallType.objectType, []).object);
  }
}

final class $GzipSinkType extends jni.JObjType<GzipSink> {
  const $GzipSinkType();

  @override
  String get signature => r"Lokio/GzipSink;";

  @override
  GzipSink fromRef(jni.JObjectPtr ref) => GzipSink.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($GzipSinkType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($GzipSinkType) && other is $GzipSinkType;
  }
}

/// from: okio.GzipSource
class GzipSource extends jni.JObject {
  @override
  late final jni.JObjType<GzipSource> $type = type;

  GzipSource.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/GzipSource");

  /// The type which includes information such as the signature of this class.
  static const type = $GzipSourceType();
  static final _id_new0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Lokio/Source;)V");

  /// from: public void <init>(okio.Source source)
  /// The returned object must be released after use, by calling the [release] method.
  factory GzipSource(
    Source source,
  ) {
    return GzipSource.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [source.reference]).object);
  }

  static final _id_read = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"read", r"(Lokio/Buffer;J)J");

  /// from: public long read(okio.Buffer buffer, long j)
  int read(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_read,
        jni.JniCallType.longType, [buffer.reference, j]).long;
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }
}

final class $GzipSourceType extends jni.JObjType<GzipSource> {
  const $GzipSourceType();

  @override
  String get signature => r"Lokio/GzipSource;";

  @override
  GzipSource fromRef(jni.JObjectPtr ref) => GzipSource.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($GzipSourceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($GzipSourceType) && other is $GzipSourceType;
  }
}

/// from: okio.HashingSink$Companion
class HashingSink_Companion extends jni.JObject {
  @override
  late final jni.JObjType<HashingSink_Companion> $type = type;

  HashingSink_Companion.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/HashingSink$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $HashingSink_CompanionType();
  static final _id_md5 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"md5", r"(Lokio/Sink;)Lokio/HashingSink;");

  /// from: public final okio.HashingSink md5(okio.Sink sink)
  /// The returned object must be released after use, by calling the [release] method.
  HashingSink md5(
    Sink sink,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_md5, jni.JniCallType.objectType,
            [sink.reference]).object);
  }

  static final _id_sha1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"sha1", r"(Lokio/Sink;)Lokio/HashingSink;");

  /// from: public final okio.HashingSink sha1(okio.Sink sink)
  /// The returned object must be released after use, by calling the [release] method.
  HashingSink sha1(
    Sink sink,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_sha1, jni.JniCallType.objectType,
            [sink.reference]).object);
  }

  static final _id_sha256 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"sha256", r"(Lokio/Sink;)Lokio/HashingSink;");

  /// from: public final okio.HashingSink sha256(okio.Sink sink)
  /// The returned object must be released after use, by calling the [release] method.
  HashingSink sha256(
    Sink sink,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_sha256, jni.JniCallType.objectType,
            [sink.reference]).object);
  }

  static final _id_sha512 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"sha512", r"(Lokio/Sink;)Lokio/HashingSink;");

  /// from: public final okio.HashingSink sha512(okio.Sink sink)
  /// The returned object must be released after use, by calling the [release] method.
  HashingSink sha512(
    Sink sink,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_sha512, jni.JniCallType.objectType,
            [sink.reference]).object);
  }

  static final _id_hmacSha1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"hmacSha1", r"(Lokio/Sink;Lokio/ByteString;)Lokio/HashingSink;");

  /// from: public final okio.HashingSink hmacSha1(okio.Sink sink, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  HashingSink hmacSha1(
    Sink sink,
    ByteString byteString,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_hmacSha1, jni.JniCallType.objectType,
            [sink.reference, byteString.reference]).object);
  }

  static final _id_hmacSha256 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"hmacSha256",
      r"(Lokio/Sink;Lokio/ByteString;)Lokio/HashingSink;");

  /// from: public final okio.HashingSink hmacSha256(okio.Sink sink, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  HashingSink hmacSha256(
    Sink sink,
    ByteString byteString,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_hmacSha256,
            jni.JniCallType.objectType,
            [sink.reference, byteString.reference]).object);
  }

  static final _id_hmacSha512 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"hmacSha512",
      r"(Lokio/Sink;Lokio/ByteString;)Lokio/HashingSink;");

  /// from: public final okio.HashingSink hmacSha512(okio.Sink sink, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  HashingSink hmacSha512(
    Sink sink,
    ByteString byteString,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_hmacSha512,
            jni.JniCallType.objectType,
            [sink.reference, byteString.reference]).object);
  }

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory HashingSink_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return HashingSink_Companion.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [defaultConstructorMarker.reference]).object);
  }
}

final class $HashingSink_CompanionType
    extends jni.JObjType<HashingSink_Companion> {
  const $HashingSink_CompanionType();

  @override
  String get signature => r"Lokio/HashingSink$Companion;";

  @override
  HashingSink_Companion fromRef(jni.JObjectPtr ref) =>
      HashingSink_Companion.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($HashingSink_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($HashingSink_CompanionType) &&
        other is $HashingSink_CompanionType;
  }
}

/// from: okio.HashingSink
class HashingSink extends ForwardingSink {
  @override
  late final jni.JObjType<HashingSink> $type = type;

  HashingSink.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/HashingSink");

  /// The type which includes information such as the signature of this class.
  static const type = $HashingSinkType();
  static final _id_Companion = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Companion",
    r"Lokio/HashingSink$Companion;",
  );

  /// from: static public final okio.HashingSink$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSink_Companion get Companion =>
      const $HashingSink_CompanionType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_Companion, jni.JniCallType.objectType)
          .object);

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lokio/Sink;Ljava/security/MessageDigest;)V");

  /// from: public void <init>(okio.Sink sink, java.security.MessageDigest messageDigest)
  /// The returned object must be released after use, by calling the [release] method.
  factory HashingSink.new1(
    Sink sink,
    jni.JObject messageDigest,
  ) {
    return HashingSink.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new1,
        [sink.reference, messageDigest.reference]).object);
  }

  static final _id_new2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Lokio/Sink;Ljava/lang/String;)V");

  /// from: public void <init>(okio.Sink sink, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  factory HashingSink.new2(
    Sink sink,
    jni.JString string,
  ) {
    return HashingSink.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new2, [sink.reference, string.reference]).object);
  }

  static final _id_new3 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Lokio/Sink;Ljavax/crypto/Mac;)V");

  /// from: public void <init>(okio.Sink sink, javax.crypto.Mac mac)
  /// The returned object must be released after use, by calling the [release] method.
  factory HashingSink.new3(
    Sink sink,
    jni.JObject mac,
  ) {
    return HashingSink.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new3, [sink.reference, mac.reference]).object);
  }

  static final _id_new4 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lokio/Sink;Lokio/ByteString;Ljava/lang/String;)V");

  /// from: public void <init>(okio.Sink sink, okio.ByteString byteString, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  factory HashingSink.new4(
    Sink sink,
    ByteString byteString,
    jni.JString string,
  ) {
    return HashingSink.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new4,
        [sink.reference, byteString.reference, string.reference]).object);
  }

  static final _id_write = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"(Lokio/Buffer;J)V");

  /// from: public void write(okio.Buffer buffer, long j)
  void write(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write,
        jni.JniCallType.voidType, [buffer.reference, j]).check();
  }

  static final _id_hash = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"hash", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString hash()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString hash() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hash, jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_hash = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_hash", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString -deprecated_hash()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString _deprecated_hash() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_hash,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_md5 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"md5", r"(Lokio/Sink;)Lokio/HashingSink;");

  /// from: static public final okio.HashingSink md5(okio.Sink sink)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSink md5(
    Sink sink,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_md5,
            jni.JniCallType.objectType, [sink.reference]).object);
  }

  static final _id_sha1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"sha1", r"(Lokio/Sink;)Lokio/HashingSink;");

  /// from: static public final okio.HashingSink sha1(okio.Sink sink)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSink sha1(
    Sink sink,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_sha1,
            jni.JniCallType.objectType, [sink.reference]).object);
  }

  static final _id_sha256 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"sha256", r"(Lokio/Sink;)Lokio/HashingSink;");

  /// from: static public final okio.HashingSink sha256(okio.Sink sink)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSink sha256(
    Sink sink,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_sha256,
            jni.JniCallType.objectType, [sink.reference]).object);
  }

  static final _id_sha512 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"sha512", r"(Lokio/Sink;)Lokio/HashingSink;");

  /// from: static public final okio.HashingSink sha512(okio.Sink sink)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSink sha512(
    Sink sink,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_sha512,
            jni.JniCallType.objectType, [sink.reference]).object);
  }

  static final _id_hmacSha1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"hmacSha1",
      r"(Lokio/Sink;Lokio/ByteString;)Lokio/HashingSink;");

  /// from: static public final okio.HashingSink hmacSha1(okio.Sink sink, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSink hmacSha1(
    Sink sink,
    ByteString byteString,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_hmacSha1,
            jni.JniCallType.objectType,
            [sink.reference, byteString.reference]).object);
  }

  static final _id_hmacSha256 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"hmacSha256",
      r"(Lokio/Sink;Lokio/ByteString;)Lokio/HashingSink;");

  /// from: static public final okio.HashingSink hmacSha256(okio.Sink sink, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSink hmacSha256(
    Sink sink,
    ByteString byteString,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_hmacSha256,
            jni.JniCallType.objectType,
            [sink.reference, byteString.reference]).object);
  }

  static final _id_hmacSha512 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"hmacSha512",
      r"(Lokio/Sink;Lokio/ByteString;)Lokio/HashingSink;");

  /// from: static public final okio.HashingSink hmacSha512(okio.Sink sink, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSink hmacSha512(
    Sink sink,
    ByteString byteString,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_hmacSha512,
            jni.JniCallType.objectType,
            [sink.reference, byteString.reference]).object);
  }
}

final class $HashingSinkType extends jni.JObjType<HashingSink> {
  const $HashingSinkType();

  @override
  String get signature => r"Lokio/HashingSink;";

  @override
  HashingSink fromRef(jni.JObjectPtr ref) => HashingSink.fromRef(ref);

  @override
  jni.JObjType get superType => const $ForwardingSinkType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($HashingSinkType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($HashingSinkType) && other is $HashingSinkType;
  }
}

/// from: okio.HashingSource$Companion
class HashingSource_Companion extends jni.JObject {
  @override
  late final jni.JObjType<HashingSource_Companion> $type = type;

  HashingSource_Companion.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/HashingSource$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $HashingSource_CompanionType();
  static final _id_md5 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"md5", r"(Lokio/Source;)Lokio/HashingSource;");

  /// from: public final okio.HashingSource md5(okio.Source source)
  /// The returned object must be released after use, by calling the [release] method.
  HashingSource md5(
    Source source,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_md5, jni.JniCallType.objectType,
            [source.reference]).object);
  }

  static final _id_sha1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"sha1", r"(Lokio/Source;)Lokio/HashingSource;");

  /// from: public final okio.HashingSource sha1(okio.Source source)
  /// The returned object must be released after use, by calling the [release] method.
  HashingSource sha1(
    Source source,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_sha1, jni.JniCallType.objectType,
            [source.reference]).object);
  }

  static final _id_sha256 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"sha256", r"(Lokio/Source;)Lokio/HashingSource;");

  /// from: public final okio.HashingSource sha256(okio.Source source)
  /// The returned object must be released after use, by calling the [release] method.
  HashingSource sha256(
    Source source,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_sha256, jni.JniCallType.objectType,
            [source.reference]).object);
  }

  static final _id_sha512 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"sha512", r"(Lokio/Source;)Lokio/HashingSource;");

  /// from: public final okio.HashingSource sha512(okio.Source source)
  /// The returned object must be released after use, by calling the [release] method.
  HashingSource sha512(
    Source source,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_sha512, jni.JniCallType.objectType,
            [source.reference]).object);
  }

  static final _id_hmacSha1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"hmacSha1", r"(Lokio/Source;Lokio/ByteString;)Lokio/HashingSource;");

  /// from: public final okio.HashingSource hmacSha1(okio.Source source, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  HashingSource hmacSha1(
    Source source,
    ByteString byteString,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_hmacSha1, jni.JniCallType.objectType,
            [source.reference, byteString.reference]).object);
  }

  static final _id_hmacSha256 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"hmacSha256",
      r"(Lokio/Source;Lokio/ByteString;)Lokio/HashingSource;");

  /// from: public final okio.HashingSource hmacSha256(okio.Source source, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  HashingSource hmacSha256(
    Source source,
    ByteString byteString,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_hmacSha256,
            jni.JniCallType.objectType,
            [source.reference, byteString.reference]).object);
  }

  static final _id_hmacSha512 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"hmacSha512",
      r"(Lokio/Source;Lokio/ByteString;)Lokio/HashingSource;");

  /// from: public final okio.HashingSource hmacSha512(okio.Source source, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  HashingSource hmacSha512(
    Source source,
    ByteString byteString,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_hmacSha512,
            jni.JniCallType.objectType,
            [source.reference, byteString.reference]).object);
  }

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory HashingSource_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return HashingSource_Companion.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [defaultConstructorMarker.reference]).object);
  }
}

final class $HashingSource_CompanionType
    extends jni.JObjType<HashingSource_Companion> {
  const $HashingSource_CompanionType();

  @override
  String get signature => r"Lokio/HashingSource$Companion;";

  @override
  HashingSource_Companion fromRef(jni.JObjectPtr ref) =>
      HashingSource_Companion.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($HashingSource_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($HashingSource_CompanionType) &&
        other is $HashingSource_CompanionType;
  }
}

/// from: okio.HashingSource
class HashingSource extends ForwardingSource {
  @override
  late final jni.JObjType<HashingSource> $type = type;

  HashingSource.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/HashingSource");

  /// The type which includes information such as the signature of this class.
  static const type = $HashingSourceType();
  static final _id_Companion = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Companion",
    r"Lokio/HashingSource$Companion;",
  );

  /// from: static public final okio.HashingSource$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSource_Companion get Companion =>
      const $HashingSource_CompanionType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_Companion, jni.JniCallType.objectType)
          .object);

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lokio/Source;Ljava/security/MessageDigest;)V");

  /// from: public void <init>(okio.Source source, java.security.MessageDigest messageDigest)
  /// The returned object must be released after use, by calling the [release] method.
  factory HashingSource.new1(
    Source source,
    jni.JObject messageDigest,
  ) {
    return HashingSource.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new1,
        [source.reference, messageDigest.reference]).object);
  }

  static final _id_new2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Lokio/Source;Ljava/lang/String;)V");

  /// from: public void <init>(okio.Source source, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  factory HashingSource.new2(
    Source source,
    jni.JString string,
  ) {
    return HashingSource.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new2,
        [source.reference, string.reference]).object);
  }

  static final _id_new3 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Lokio/Source;Ljavax/crypto/Mac;)V");

  /// from: public void <init>(okio.Source source, javax.crypto.Mac mac)
  /// The returned object must be released after use, by calling the [release] method.
  factory HashingSource.new3(
    Source source,
    jni.JObject mac,
  ) {
    return HashingSource.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new3, [source.reference, mac.reference]).object);
  }

  static final _id_new4 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lokio/Source;Lokio/ByteString;Ljava/lang/String;)V");

  /// from: public void <init>(okio.Source source, okio.ByteString byteString, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  factory HashingSource.new4(
    Source source,
    ByteString byteString,
    jni.JString string,
  ) {
    return HashingSource.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new4,
        [source.reference, byteString.reference, string.reference]).object);
  }

  static final _id_read = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"read", r"(Lokio/Buffer;J)J");

  /// from: public long read(okio.Buffer buffer, long j)
  int read(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_read,
        jni.JniCallType.longType, [buffer.reference, j]).long;
  }

  static final _id_hash = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"hash", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString hash()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString hash() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hash, jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_hash = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_hash", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString -deprecated_hash()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString _deprecated_hash() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_hash,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_md5 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"md5", r"(Lokio/Source;)Lokio/HashingSource;");

  /// from: static public final okio.HashingSource md5(okio.Source source)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSource md5(
    Source source,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_md5,
            jni.JniCallType.objectType, [source.reference]).object);
  }

  static final _id_sha1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"sha1", r"(Lokio/Source;)Lokio/HashingSource;");

  /// from: static public final okio.HashingSource sha1(okio.Source source)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSource sha1(
    Source source,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_sha1,
            jni.JniCallType.objectType, [source.reference]).object);
  }

  static final _id_sha256 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"sha256", r"(Lokio/Source;)Lokio/HashingSource;");

  /// from: static public final okio.HashingSource sha256(okio.Source source)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSource sha256(
    Source source,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_sha256,
            jni.JniCallType.objectType, [source.reference]).object);
  }

  static final _id_sha512 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"sha512", r"(Lokio/Source;)Lokio/HashingSource;");

  /// from: static public final okio.HashingSource sha512(okio.Source source)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSource sha512(
    Source source,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_sha512,
            jni.JniCallType.objectType, [source.reference]).object);
  }

  static final _id_hmacSha1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"hmacSha1",
      r"(Lokio/Source;Lokio/ByteString;)Lokio/HashingSource;");

  /// from: static public final okio.HashingSource hmacSha1(okio.Source source, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSource hmacSha1(
    Source source,
    ByteString byteString,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_hmacSha1,
            jni.JniCallType.objectType,
            [source.reference, byteString.reference]).object);
  }

  static final _id_hmacSha256 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"hmacSha256",
      r"(Lokio/Source;Lokio/ByteString;)Lokio/HashingSource;");

  /// from: static public final okio.HashingSource hmacSha256(okio.Source source, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSource hmacSha256(
    Source source,
    ByteString byteString,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_hmacSha256,
            jni.JniCallType.objectType,
            [source.reference, byteString.reference]).object);
  }

  static final _id_hmacSha512 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"hmacSha512",
      r"(Lokio/Source;Lokio/ByteString;)Lokio/HashingSource;");

  /// from: static public final okio.HashingSource hmacSha512(okio.Source source, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSource hmacSha512(
    Source source,
    ByteString byteString,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_hmacSha512,
            jni.JniCallType.objectType,
            [source.reference, byteString.reference]).object);
  }
}

final class $HashingSourceType extends jni.JObjType<HashingSource> {
  const $HashingSourceType();

  @override
  String get signature => r"Lokio/HashingSource;";

  @override
  HashingSource fromRef(jni.JObjectPtr ref) => HashingSource.fromRef(ref);

  @override
  jni.JObjType get superType => const $ForwardingSourceType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($HashingSourceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($HashingSourceType) &&
        other is $HashingSourceType;
  }
}

/// from: okio.InflaterSource
class InflaterSource extends jni.JObject {
  @override
  late final jni.JObjType<InflaterSource> $type = type;

  InflaterSource.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/InflaterSource");

  /// The type which includes information such as the signature of this class.
  static const type = $InflaterSourceType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lokio/BufferedSource;Ljava/util/zip/Inflater;)V");

  /// from: public void <init>(okio.BufferedSource bufferedSource, java.util.zip.Inflater inflater)
  /// The returned object must be released after use, by calling the [release] method.
  factory InflaterSource(
    BufferedSource bufferedSource,
    jni.JObject inflater,
  ) {
    return InflaterSource.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [bufferedSource.reference, inflater.reference]).object);
  }

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Lokio/Source;Ljava/util/zip/Inflater;)V");

  /// from: public void <init>(okio.Source source, java.util.zip.Inflater inflater)
  /// The returned object must be released after use, by calling the [release] method.
  factory InflaterSource.new1(
    Source source,
    jni.JObject inflater,
  ) {
    return InflaterSource.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new1,
        [source.reference, inflater.reference]).object);
  }

  static final _id_read = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"read", r"(Lokio/Buffer;J)J");

  /// from: public long read(okio.Buffer buffer, long j)
  int read(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_read,
        jni.JniCallType.longType, [buffer.reference, j]).long;
  }

  static final _id_readOrInflate = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readOrInflate", r"(Lokio/Buffer;J)J");

  /// from: public final long readOrInflate(okio.Buffer buffer, long j)
  int readOrInflate(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_readOrInflate,
        jni.JniCallType.longType, [buffer.reference, j]).long;
  }

  static final _id_refill =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"refill", r"()Z");

  /// from: public final boolean refill()
  bool refill() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_refill, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }
}

final class $InflaterSourceType extends jni.JObjType<InflaterSource> {
  const $InflaterSourceType();

  @override
  String get signature => r"Lokio/InflaterSource;";

  @override
  InflaterSource fromRef(jni.JObjectPtr ref) => InflaterSource.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($InflaterSourceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($InflaterSourceType) &&
        other is $InflaterSourceType;
  }
}

/// from: okio.JvmFileHandle
class JvmFileHandle extends FileHandle {
  @override
  late final jni.JObjType<JvmFileHandle> $type = type;

  JvmFileHandle.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/JvmFileHandle");

  /// The type which includes information such as the signature of this class.
  static const type = $JvmFileHandleType();
  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(ZLjava/io/RandomAccessFile;)V");

  /// from: public void <init>(boolean z, java.io.RandomAccessFile randomAccessFile)
  /// The returned object must be released after use, by calling the [release] method.
  factory JvmFileHandle.new1(
    bool z,
    jni.JObject randomAccessFile,
  ) {
    return JvmFileHandle.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new1,
        [z ? 1 : 0, randomAccessFile.reference]).object);
  }

  static final _id_protectedResize = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedResize", r"(J)V");

  /// from: protected void protectedResize(long j)
  void protectedResize(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protectedResize, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_protectedSize = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedSize", r"()J");

  /// from: protected long protectedSize()
  int protectedSize() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protectedSize, jni.JniCallType.longType, []).long;
  }

  static final _id_protectedRead = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedRead", r"(J[BII)I");

  /// from: protected int protectedRead(long j, byte[] bs, int i, int i1)
  int protectedRead(
    int j,
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_protectedRead,
        jni.JniCallType.intType,
        [j, bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).integer;
  }

  static final _id_protectedWrite = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedWrite", r"(J[BII)V");

  /// from: protected void protectedWrite(long j, byte[] bs, int i, int i1)
  void protectedWrite(
    int j,
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_protectedWrite,
        jni.JniCallType.voidType,
        [j, bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_protectedFlush = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedFlush", r"()V");

  /// from: protected void protectedFlush()
  void protectedFlush() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protectedFlush, jni.JniCallType.voidType, []).check();
  }

  static final _id_protectedClose = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedClose", r"()V");

  /// from: protected void protectedClose()
  void protectedClose() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protectedClose, jni.JniCallType.voidType, []).check();
  }
}

final class $JvmFileHandleType extends jni.JObjType<JvmFileHandle> {
  const $JvmFileHandleType();

  @override
  String get signature => r"Lokio/JvmFileHandle;";

  @override
  JvmFileHandle fromRef(jni.JObjectPtr ref) => JvmFileHandle.fromRef(ref);

  @override
  jni.JObjType get superType => const $FileHandleType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($JvmFileHandleType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($JvmFileHandleType) &&
        other is $JvmFileHandleType;
  }
}

/// from: okio.JvmSystemFileSystem
class JvmSystemFileSystem extends FileSystem {
  @override
  late final jni.JObjType<JvmSystemFileSystem> $type = type;

  JvmSystemFileSystem.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/JvmSystemFileSystem");

  /// The type which includes information such as the signature of this class.
  static const type = $JvmSystemFileSystemType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory JvmSystemFileSystem() {
    return JvmSystemFileSystem.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_canonicalize = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"canonicalize", r"(Lokio/Path;)Lokio/Path;");

  /// from: public okio.Path canonicalize(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Path canonicalize(
    Path path,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_canonicalize,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_metadataOrNull = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"metadataOrNull", r"(Lokio/Path;)Lokio/FileMetadata;");

  /// from: public okio.FileMetadata metadataOrNull(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileMetadata metadataOrNull(
    Path path,
  ) {
    return const $FileMetadataType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_metadataOrNull,
            jni.JniCallType.objectType, [path.reference]).object);
  }

  static final _id_list = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"list", r"(Lokio/Path;)Ljava/util/List;");

  /// from: public java.util.List list(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Path> list(
    Path path,
  ) {
    return const jni.JListType($PathType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_list, jni.JniCallType.objectType,
            [path.reference]).object);
  }

  static final _id_listOrNull = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"listOrNull", r"(Lokio/Path;)Ljava/util/List;");

  /// from: public java.util.List listOrNull(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Path> listOrNull(
    Path path,
  ) {
    return const jni.JListType($PathType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_listOrNull,
            jni.JniCallType.objectType, [path.reference]).object);
  }

  static final _id_openReadOnly = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"openReadOnly", r"(Lokio/Path;)Lokio/FileHandle;");

  /// from: public okio.FileHandle openReadOnly(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileHandle openReadOnly(
    Path path,
  ) {
    return const $FileHandleType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openReadOnly,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_openReadWrite = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"openReadWrite", r"(Lokio/Path;ZZ)Lokio/FileHandle;");

  /// from: public okio.FileHandle openReadWrite(okio.Path path, boolean z, boolean z1)
  /// The returned object must be released after use, by calling the [release] method.
  FileHandle openReadWrite(
    Path path,
    bool z,
    bool z1,
  ) {
    return const $FileHandleType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openReadWrite,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0, z1 ? 1 : 0]).object);
  }

  static final _id_source = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"source", r"(Lokio/Path;)Lokio/Source;");

  /// from: public okio.Source source(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Source source(
    Path path,
  ) {
    return const $SourceType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_source,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_sink = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sink", r"(Lokio/Path;Z)Lokio/Sink;");

  /// from: public okio.Sink sink(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Sink sink(
    Path path,
    bool z,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sink,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_appendingSink = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"appendingSink", r"(Lokio/Path;Z)Lokio/Sink;");

  /// from: public okio.Sink appendingSink(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Sink appendingSink(
    Path path,
    bool z,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_appendingSink,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_createDirectory = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"createDirectory", r"(Lokio/Path;Z)V");

  /// from: public void createDirectory(okio.Path path, boolean z)
  void createDirectory(
    Path path,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_createDirectory,
        jni.JniCallType.voidType, [path.reference, z ? 1 : 0]).check();
  }

  static final _id_atomicMove = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"atomicMove", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public void atomicMove(okio.Path path, okio.Path path1)
  void atomicMove(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_atomicMove,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }

  static final _id_delete = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"delete", r"(Lokio/Path;Z)V");

  /// from: public void delete(okio.Path path, boolean z)
  void delete(
    Path path,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_delete,
        jni.JniCallType.voidType, [path.reference, z ? 1 : 0]).check();
  }

  static final _id_createSymlink = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"createSymlink", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public void createSymlink(okio.Path path, okio.Path path1)
  void createSymlink(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_createSymlink,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }
}

final class $JvmSystemFileSystemType extends jni.JObjType<JvmSystemFileSystem> {
  const $JvmSystemFileSystemType();

  @override
  String get signature => r"Lokio/JvmSystemFileSystem;";

  @override
  JvmSystemFileSystem fromRef(jni.JObjectPtr ref) =>
      JvmSystemFileSystem.fromRef(ref);

  @override
  jni.JObjType get superType => const $FileSystemType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($JvmSystemFileSystemType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($JvmSystemFileSystemType) &&
        other is $JvmSystemFileSystemType;
  }
}

/// from: okio.NioFileSystemFileHandle
class NioFileSystemFileHandle extends FileHandle {
  @override
  late final jni.JObjType<NioFileSystemFileHandle> $type = type;

  NioFileSystemFileHandle.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/NioFileSystemFileHandle");

  /// The type which includes information such as the signature of this class.
  static const type = $NioFileSystemFileHandleType();
  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(ZLjava/nio/channels/FileChannel;)V");

  /// from: public void <init>(boolean z, java.nio.channels.FileChannel fileChannel)
  /// The returned object must be released after use, by calling the [release] method.
  factory NioFileSystemFileHandle.new1(
    bool z,
    jni.JObject fileChannel,
  ) {
    return NioFileSystemFileHandle.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new1, [z ? 1 : 0, fileChannel.reference]).object);
  }

  static final _id_protectedResize = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedResize", r"(J)V");

  /// from: protected void protectedResize(long j)
  void protectedResize(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protectedResize, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_protectedSize = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedSize", r"()J");

  /// from: protected long protectedSize()
  int protectedSize() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protectedSize, jni.JniCallType.longType, []).long;
  }

  static final _id_protectedRead = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedRead", r"(J[BII)I");

  /// from: protected int protectedRead(long j, byte[] bs, int i, int i1)
  int protectedRead(
    int j,
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_protectedRead,
        jni.JniCallType.intType,
        [j, bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).integer;
  }

  static final _id_protectedWrite = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedWrite", r"(J[BII)V");

  /// from: protected void protectedWrite(long j, byte[] bs, int i, int i1)
  void protectedWrite(
    int j,
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_protectedWrite,
        jni.JniCallType.voidType,
        [j, bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_protectedFlush = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedFlush", r"()V");

  /// from: protected void protectedFlush()
  void protectedFlush() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protectedFlush, jni.JniCallType.voidType, []).check();
  }

  static final _id_protectedClose = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protectedClose", r"()V");

  /// from: protected void protectedClose()
  void protectedClose() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protectedClose, jni.JniCallType.voidType, []).check();
  }
}

final class $NioFileSystemFileHandleType
    extends jni.JObjType<NioFileSystemFileHandle> {
  const $NioFileSystemFileHandleType();

  @override
  String get signature => r"Lokio/NioFileSystemFileHandle;";

  @override
  NioFileSystemFileHandle fromRef(jni.JObjectPtr ref) =>
      NioFileSystemFileHandle.fromRef(ref);

  @override
  jni.JObjType get superType => const $FileHandleType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($NioFileSystemFileHandleType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($NioFileSystemFileHandleType) &&
        other is $NioFileSystemFileHandleType;
  }
}

/// from: okio.NioFileSystemWrappingFileSystem
class NioFileSystemWrappingFileSystem extends NioSystemFileSystem {
  @override
  late final jni.JObjType<NioFileSystemWrappingFileSystem> $type = type;

  NioFileSystemWrappingFileSystem.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"okio/NioFileSystemWrappingFileSystem");

  /// The type which includes information such as the signature of this class.
  static const type = $NioFileSystemWrappingFileSystemType();
  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Ljava/nio/file/FileSystem;)V");

  /// from: public void <init>(java.nio.file.FileSystem fileSystem)
  /// The returned object must be released after use, by calling the [release] method.
  factory NioFileSystemWrappingFileSystem.new1(
    jni.JObject fileSystem,
  ) {
    return NioFileSystemWrappingFileSystem.fromRef(jni.Jni.accessors
        .newObjectWithArgs(
            _class.reference, _id_new1, [fileSystem.reference]).object);
  }

  static final _id_canonicalize1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"canonicalize", r"(Lokio/Path;)Lokio/Path;");

  /// from: public okio.Path canonicalize(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Path canonicalize1(
    Path path,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_canonicalize1,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_metadataOrNull = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"metadataOrNull", r"(Lokio/Path;)Lokio/FileMetadata;");

  /// from: public okio.FileMetadata metadataOrNull(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileMetadata metadataOrNull(
    Path path,
  ) {
    return const $FileMetadataType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_metadataOrNull,
            jni.JniCallType.objectType, [path.reference]).object);
  }

  static final _id_list1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"list", r"(Lokio/Path;)Ljava/util/List;");

  /// from: public java.util.List list(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Path> list1(
    Path path,
  ) {
    return const jni.JListType($PathType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_list1, jni.JniCallType.objectType,
            [path.reference]).object);
  }

  static final _id_listOrNull1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"listOrNull", r"(Lokio/Path;)Ljava/util/List;");

  /// from: public java.util.List listOrNull(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Path> listOrNull1(
    Path path,
  ) {
    return const jni.JListType($PathType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_listOrNull1,
            jni.JniCallType.objectType, [path.reference]).object);
  }

  static final _id_openReadOnly1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"openReadOnly", r"(Lokio/Path;)Lokio/FileHandle;");

  /// from: public okio.FileHandle openReadOnly(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileHandle openReadOnly1(
    Path path,
  ) {
    return const $FileHandleType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openReadOnly1,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_openReadWrite2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"openReadWrite", r"(Lokio/Path;ZZ)Lokio/FileHandle;");

  /// from: public okio.FileHandle openReadWrite(okio.Path path, boolean z, boolean z1)
  /// The returned object must be released after use, by calling the [release] method.
  FileHandle openReadWrite2(
    Path path,
    bool z,
    bool z1,
  ) {
    return const $FileHandleType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openReadWrite2,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0, z1 ? 1 : 0]).object);
  }

  static final _id_source1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"source", r"(Lokio/Path;)Lokio/Source;");

  /// from: public okio.Source source(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Source source1(
    Path path,
  ) {
    return const $SourceType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_source1,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_sink2 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sink", r"(Lokio/Path;Z)Lokio/Sink;");

  /// from: public okio.Sink sink(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Sink sink2(
    Path path,
    bool z,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sink2,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_appendingSink2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"appendingSink", r"(Lokio/Path;Z)Lokio/Sink;");

  /// from: public okio.Sink appendingSink(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Sink appendingSink2(
    Path path,
    bool z,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_appendingSink2,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_createDirectory2 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"createDirectory", r"(Lokio/Path;Z)V");

  /// from: public void createDirectory(okio.Path path, boolean z)
  void createDirectory2(
    Path path,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_createDirectory2,
        jni.JniCallType.voidType, [path.reference, z ? 1 : 0]).check();
  }

  static final _id_atomicMove = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"atomicMove", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public void atomicMove(okio.Path path, okio.Path path1)
  void atomicMove(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_atomicMove,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }

  static final _id_delete2 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"delete", r"(Lokio/Path;Z)V");

  /// from: public void delete(okio.Path path, boolean z)
  void delete2(
    Path path,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_delete2,
        jni.JniCallType.voidType, [path.reference, z ? 1 : 0]).check();
  }

  static final _id_createSymlink = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"createSymlink", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public void createSymlink(okio.Path path, okio.Path path1)
  void createSymlink(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_createSymlink,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }
}

final class $NioFileSystemWrappingFileSystemType
    extends jni.JObjType<NioFileSystemWrappingFileSystem> {
  const $NioFileSystemWrappingFileSystemType();

  @override
  String get signature => r"Lokio/NioFileSystemWrappingFileSystem;";

  @override
  NioFileSystemWrappingFileSystem fromRef(jni.JObjectPtr ref) =>
      NioFileSystemWrappingFileSystem.fromRef(ref);

  @override
  jni.JObjType get superType => const $NioSystemFileSystemType();

  @override
  final superCount = 4;

  @override
  int get hashCode => ($NioFileSystemWrappingFileSystemType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($NioFileSystemWrappingFileSystemType) &&
        other is $NioFileSystemWrappingFileSystemType;
  }
}

/// from: okio.NioSystemFileSystem
class NioSystemFileSystem extends JvmSystemFileSystem {
  @override
  late final jni.JObjType<NioSystemFileSystem> $type = type;

  NioSystemFileSystem.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/NioSystemFileSystem");

  /// The type which includes information such as the signature of this class.
  static const type = $NioSystemFileSystemType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory NioSystemFileSystem() {
    return NioSystemFileSystem.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_metadataOrNull = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"metadataOrNull", r"(Lokio/Path;)Lokio/FileMetadata;");

  /// from: public okio.FileMetadata metadataOrNull(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileMetadata metadataOrNull(
    Path path,
  ) {
    return const $FileMetadataType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_metadataOrNull,
            jni.JniCallType.objectType, [path.reference]).object);
  }

  static final _id_metadataOrNull1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"metadataOrNull",
      r"(Ljava/nio/file/Path;)Lokio/FileMetadata;");

  /// from: protected final okio.FileMetadata metadataOrNull(java.nio.file.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileMetadata metadataOrNull1(
    jni.JObject path,
  ) {
    return const $FileMetadataType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_metadataOrNull1,
            jni.JniCallType.objectType, [path.reference]).object);
  }

  static final _id_atomicMove = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"atomicMove", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public void atomicMove(okio.Path path, okio.Path path1)
  void atomicMove(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_atomicMove,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }

  static final _id_createSymlink = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"createSymlink", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public void createSymlink(okio.Path path, okio.Path path1)
  void createSymlink(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_createSymlink,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }
}

final class $NioSystemFileSystemType extends jni.JObjType<NioSystemFileSystem> {
  const $NioSystemFileSystemType();

  @override
  String get signature => r"Lokio/NioSystemFileSystem;";

  @override
  NioSystemFileSystem fromRef(jni.JObjectPtr ref) =>
      NioSystemFileSystem.fromRef(ref);

  @override
  jni.JObjType get superType => const $JvmSystemFileSystemType();

  @override
  final superCount = 3;

  @override
  int get hashCode => ($NioSystemFileSystemType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($NioSystemFileSystemType) &&
        other is $NioSystemFileSystemType;
  }
}

/// from: okio.Okio
class Okio extends jni.JObject {
  @override
  late final jni.JObjType<Okio> $type = type;

  Okio.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Okio");

  /// The type which includes information such as the signature of this class.
  static const type = $OkioType();
  static final _id_sink = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"sink", r"(Ljava/io/OutputStream;)Lokio/Sink;");

  /// from: static public final okio.Sink sink(java.io.OutputStream outputStream)
  /// The returned object must be released after use, by calling the [release] method.
  static Sink sink(
    jni.JObject outputStream,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_sink,
        jni.JniCallType.objectType,
        [outputStream.reference]).object);
  }

  static final _id_source = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"source", r"(Ljava/io/InputStream;)Lokio/Source;");

  /// from: static public final okio.Source source(java.io.InputStream inputStream)
  /// The returned object must be released after use, by calling the [release] method.
  static Source source(
    jni.JObject inputStream,
  ) {
    return const $SourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_source,
            jni.JniCallType.objectType, [inputStream.reference]).object);
  }

  static final _id_sink1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"sink", r"(Ljava/net/Socket;)Lokio/Sink;");

  /// from: static public final okio.Sink sink(java.net.Socket socket)
  /// The returned object must be released after use, by calling the [release] method.
  static Sink sink1(
    jni.JObject socket,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_sink1,
        jni.JniCallType.objectType,
        [socket.reference]).object);
  }

  static final _id_source1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"source", r"(Ljava/net/Socket;)Lokio/Source;");

  /// from: static public final okio.Source source(java.net.Socket socket)
  /// The returned object must be released after use, by calling the [release] method.
  static Source source1(
    jni.JObject socket,
  ) {
    return const $SourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_source1,
            jni.JniCallType.objectType, [socket.reference]).object);
  }

  static final _id_sink2 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"sink", r"(Ljava/io/File;Z)Lokio/Sink;");

  /// from: static public final okio.Sink sink(java.io.File file, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static Sink sink2(
    jni.JObject file,
    bool z,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_sink2,
        jni.JniCallType.objectType,
        [file.reference, z ? 1 : 0]).object);
  }

  static final _id_appendingSink = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"appendingSink", r"(Ljava/io/File;)Lokio/Sink;");

  /// from: static public final okio.Sink appendingSink(java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static Sink appendingSink(
    jni.JObject file,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_appendingSink,
        jni.JniCallType.objectType,
        [file.reference]).object);
  }

  static final _id_source2 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"source", r"(Ljava/io/File;)Lokio/Source;");

  /// from: static public final okio.Source source(java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static Source source2(
    jni.JObject file,
  ) {
    return const $SourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_source2,
            jni.JniCallType.objectType, [file.reference]).object);
  }

  static final _id_sink3 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"sink",
      r"(Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Lokio/Sink;");

  /// from: static public final okio.Sink sink(java.nio.file.Path path, java.nio.file.OpenOption[] openOptions)
  /// The returned object must be released after use, by calling the [release] method.
  static Sink sink3(
    jni.JObject path,
    jni.JArray<jni.JObject> openOptions,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_sink3,
        jni.JniCallType.objectType,
        [path.reference, openOptions.reference]).object);
  }

  static final _id_source3 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"source",
      r"(Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Lokio/Source;");

  /// from: static public final okio.Source source(java.nio.file.Path path, java.nio.file.OpenOption[] openOptions)
  /// The returned object must be released after use, by calling the [release] method.
  static Source source3(
    jni.JObject path,
    jni.JArray<jni.JObject> openOptions,
  ) {
    return const $SourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_source3,
            jni.JniCallType.objectType,
            [path.reference, openOptions.reference]).object);
  }

  static final _id_cipherSink = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"cipherSink",
      r"(Lokio/Sink;Ljavax/crypto/Cipher;)Lokio/CipherSink;");

  /// from: static public final okio.CipherSink cipherSink(okio.Sink sink, javax.crypto.Cipher cipher)
  /// The returned object must be released after use, by calling the [release] method.
  static CipherSink cipherSink(
    Sink sink,
    jni.JObject cipher,
  ) {
    return const $CipherSinkType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_cipherSink,
            jni.JniCallType.objectType,
            [sink.reference, cipher.reference]).object);
  }

  static final _id_cipherSource = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"cipherSource",
      r"(Lokio/Source;Ljavax/crypto/Cipher;)Lokio/CipherSource;");

  /// from: static public final okio.CipherSource cipherSource(okio.Source source, javax.crypto.Cipher cipher)
  /// The returned object must be released after use, by calling the [release] method.
  static CipherSource cipherSource(
    Source source,
    jni.JObject cipher,
  ) {
    return const $CipherSourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_cipherSource,
            jni.JniCallType.objectType,
            [source.reference, cipher.reference]).object);
  }

  static final _id_hashingSink = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"hashingSink",
      r"(Lokio/Sink;Ljavax/crypto/Mac;)Lokio/HashingSink;");

  /// from: static public final okio.HashingSink hashingSink(okio.Sink sink, javax.crypto.Mac mac)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSink hashingSink(
    Sink sink,
    jni.JObject mac,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_hashingSink,
            jni.JniCallType.objectType,
            [sink.reference, mac.reference]).object);
  }

  static final _id_hashingSource = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"hashingSource",
      r"(Lokio/Source;Ljavax/crypto/Mac;)Lokio/HashingSource;");

  /// from: static public final okio.HashingSource hashingSource(okio.Source source, javax.crypto.Mac mac)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSource hashingSource(
    Source source,
    jni.JObject mac,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_hashingSource,
            jni.JniCallType.objectType,
            [source.reference, mac.reference]).object);
  }

  static final _id_hashingSink1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"hashingSink",
      r"(Lokio/Sink;Ljava/security/MessageDigest;)Lokio/HashingSink;");

  /// from: static public final okio.HashingSink hashingSink(okio.Sink sink, java.security.MessageDigest messageDigest)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSink hashingSink1(
    Sink sink,
    jni.JObject messageDigest,
  ) {
    return const $HashingSinkType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_hashingSink1,
            jni.JniCallType.objectType,
            [sink.reference, messageDigest.reference]).object);
  }

  static final _id_hashingSource1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"hashingSource",
      r"(Lokio/Source;Ljava/security/MessageDigest;)Lokio/HashingSource;");

  /// from: static public final okio.HashingSource hashingSource(okio.Source source, java.security.MessageDigest messageDigest)
  /// The returned object must be released after use, by calling the [release] method.
  static HashingSource hashingSource1(
    Source source,
    jni.JObject messageDigest,
  ) {
    return const $HashingSourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_hashingSource1,
            jni.JniCallType.objectType,
            [source.reference, messageDigest.reference]).object);
  }

  static final _id_openZip = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"openZip",
      r"(Lokio/FileSystem;Lokio/Path;)Lokio/FileSystem;");

  /// from: static public final okio.FileSystem openZip(okio.FileSystem fileSystem, okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  static FileSystem openZip(
    FileSystem fileSystem,
    Path path,
  ) {
    return const $FileSystemType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_openZip,
            jni.JniCallType.objectType,
            [fileSystem.reference, path.reference]).object);
  }

  static final _id_asResourceFileSystem = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"asResourceFileSystem",
      r"(Ljava/lang/ClassLoader;)Lokio/FileSystem;");

  /// from: static public final okio.FileSystem asResourceFileSystem(java.lang.ClassLoader classLoader)
  /// The returned object must be released after use, by calling the [release] method.
  static FileSystem asResourceFileSystem(
    jni.JObject classLoader,
  ) {
    return const $FileSystemType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_asResourceFileSystem,
            jni.JniCallType.objectType, [classLoader.reference]).object);
  }

  static final _id_isAndroidGetsocknameError = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"isAndroidGetsocknameError",
          r"(Ljava/lang/AssertionError;)Z");

  /// from: static public final boolean isAndroidGetsocknameError(java.lang.AssertionError assertionError)
  static bool isAndroidGetsocknameError(
    jni.JObject assertionError,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_isAndroidGetsocknameError,
        jni.JniCallType.booleanType,
        [assertionError.reference]).boolean;
  }

  static final _id_sink4 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"sink", r"(Ljava/io/File;)Lokio/Sink;");

  /// from: static public final okio.Sink sink(java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static Sink sink4(
    jni.JObject file,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_sink4,
        jni.JniCallType.objectType,
        [file.reference]).object);
  }

  static final _id_buffer = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"buffer", r"(Lokio/Source;)Lokio/BufferedSource;");

  /// from: static public final okio.BufferedSource buffer(okio.Source source)
  /// The returned object must be released after use, by calling the [release] method.
  static BufferedSource buffer(
    Source source,
  ) {
    return const $BufferedSourceType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_buffer,
            jni.JniCallType.objectType, [source.reference]).object);
  }

  static final _id_buffer1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"buffer", r"(Lokio/Sink;)Lokio/BufferedSink;");

  /// from: static public final okio.BufferedSink buffer(okio.Sink sink)
  /// The returned object must be released after use, by calling the [release] method.
  static BufferedSink buffer1(
    Sink sink,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_buffer1,
            jni.JniCallType.objectType, [sink.reference]).object);
  }

  static final _id_blackhole = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"blackhole", r"()Lokio/Sink;");

  /// from: static public final okio.Sink blackhole()
  /// The returned object must be released after use, by calling the [release] method.
  static Sink blackhole() {
    return const $SinkType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_blackhole,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_use1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"use",
      r"(Ljava/io/Closeable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;");

  /// from: static public final R use(T closeable, kotlin.jvm.functions.Function1 function1)
  /// The returned object must be released after use, by calling the [release] method.
  static $R use1<$T extends jni.JObject, $R extends jni.JObject>(
    $T closeable,
    jni.JObject function1, {
    jni.JObjType<$T>? T,
    required jni.JObjType<$R> R,
  }) {
    T ??= jni.lowestCommonSuperType([
      closeable.$type,
    ]) as jni.JObjType<$T>;
    return R.fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_use1,
        jni.JniCallType.objectType,
        [closeable.reference, function1.reference]).object);
  }
}

final class $OkioType extends jni.JObjType<Okio> {
  const $OkioType();

  @override
  String get signature => r"Lokio/Okio;";

  @override
  Okio fromRef(jni.JObjectPtr ref) => Okio.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkioType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkioType) && other is $OkioType;
  }
}

/// from: okio.Options$Companion
class Options_Companion extends jni.JObject {
  @override
  late final jni.JObjType<Options_Companion> $type = type;

  Options_Companion.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Options$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $Options_CompanionType();
  static final _id_of = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"of", r"([Lokio/ByteString;)Lokio/Options;");

  /// from: public final okio.Options of(okio.ByteString[] byteStrings)
  /// The returned object must be released after use, by calling the [release] method.
  Options of(
    jni.JArray<ByteString> byteStrings,
  ) {
    return const $OptionsType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_of,
        jni.JniCallType.objectType,
        [byteStrings.reference]).object);
  }

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory Options_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return Options_Companion.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [defaultConstructorMarker.reference]).object);
  }
}

final class $Options_CompanionType extends jni.JObjType<Options_Companion> {
  const $Options_CompanionType();

  @override
  String get signature => r"Lokio/Options$Companion;";

  @override
  Options_Companion fromRef(jni.JObjectPtr ref) =>
      Options_Companion.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Options_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Options_CompanionType) &&
        other is $Options_CompanionType;
  }
}

/// from: okio.Options
class Options extends jni.JObject {
  @override
  late final jni.JObjType<Options> $type = type;

  Options.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Options");

  /// The type which includes information such as the signature of this class.
  static const type = $OptionsType();
  static final _id_Companion = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Companion",
    r"Lokio/Options$Companion;",
  );

  /// from: static public final okio.Options$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static Options_Companion get Companion =>
      const $Options_CompanionType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_Companion, jni.JniCallType.objectType)
          .object);

  static final _id_getSize =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getSize", r"()I");

  /// from: public int getSize()
  int getSize() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getSize, jni.JniCallType.intType, []).integer;
  }

  static final _id_get0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"get", r"(I)Lokio/ByteString;");

  /// from: public okio.ByteString get(int i)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString get0(
    int i,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get0,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_of = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"of", r"([Lokio/ByteString;)Lokio/Options;");

  /// from: static public final okio.Options of(okio.ByteString[] byteStrings)
  /// The returned object must be released after use, by calling the [release] method.
  static Options of(
    jni.JArray<ByteString> byteStrings,
  ) {
    return const $OptionsType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_of,
            jni.JniCallType.objectType, [byteStrings.reference]).object);
  }

  static final _id_get1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"get", r"(I)Ljava/lang/Object;");

  /// from: public java.lang.Object get(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject get1(
    int i,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_contains = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"contains", r"(Lokio/ByteString;)Z");

  /// from: public boolean contains(okio.ByteString byteString)
  bool contains(
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_contains,
        jni.JniCallType.booleanType, [byteString.reference]).boolean;
  }

  static final _id_contains1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"contains", r"(Ljava/lang/Object;)Z");

  /// from: public final boolean contains(java.lang.Object object)
  bool contains1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_contains1,
        jni.JniCallType.booleanType, [object.reference]).boolean;
  }

  static final _id_indexOf = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"indexOf", r"(Lokio/ByteString;)I");

  /// from: public int indexOf(okio.ByteString byteString)
  int indexOf(
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf,
        jni.JniCallType.intType, [byteString.reference]).integer;
  }

  static final _id_indexOf1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"indexOf", r"(Ljava/lang/Object;)I");

  /// from: public final int indexOf(java.lang.Object object)
  int indexOf1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf1,
        jni.JniCallType.intType, [object.reference]).integer;
  }

  static final _id_lastIndexOf = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"lastIndexOf", r"(Lokio/ByteString;)I");

  /// from: public int lastIndexOf(okio.ByteString byteString)
  int lastIndexOf(
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_lastIndexOf,
        jni.JniCallType.intType, [byteString.reference]).integer;
  }

  static final _id_lastIndexOf1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"lastIndexOf", r"(Ljava/lang/Object;)I");

  /// from: public final int lastIndexOf(java.lang.Object object)
  int lastIndexOf1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_lastIndexOf1,
        jni.JniCallType.intType, [object.reference]).integer;
  }

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"([Lokio/ByteString;[ILkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(okio.ByteString[] byteStrings, int[] is, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory Options(
    jni.JArray<ByteString> byteStrings,
    jni.JArray<jni.jint> is0,
    jni.JObject defaultConstructorMarker,
  ) {
    return Options.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [
      byteStrings.reference,
      is0.reference,
      defaultConstructorMarker.reference
    ]).object);
  }
}

final class $OptionsType extends jni.JObjType<Options> {
  const $OptionsType();

  @override
  String get signature => r"Lokio/Options;";

  @override
  Options fromRef(jni.JObjectPtr ref) => Options.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OptionsType) && other is $OptionsType;
  }
}

/// from: okio.Path$Companion
class Path_Companion extends jni.JObject {
  @override
  late final jni.JObjType<Path_Companion> $type = type;

  Path_Companion.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Path$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $Path_CompanionType();
  static final _id_get0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"get", r"(Ljava/lang/String;Z)Lokio/Path;");

  /// from: public final okio.Path get(java.lang.String string, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Path get0(
    jni.JString string,
    bool z,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get0,
        jni.JniCallType.objectType,
        [string.reference, z ? 1 : 0]).object);
  }

  static final _id_get1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"get", r"(Ljava/io/File;Z)Lokio/Path;");

  /// from: public final okio.Path get(java.io.File file, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Path get1(
    jni.JObject file,
    bool z,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get1,
        jni.JniCallType.objectType,
        [file.reference, z ? 1 : 0]).object);
  }

  static final _id_get2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"get", r"(Ljava/nio/file/Path;Z)Lokio/Path;");

  /// from: public final okio.Path get(java.nio.file.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Path get2(
    jni.JObject path,
    bool z,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get2,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_get3 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"get", r"(Ljava/lang/String;)Lokio/Path;");

  /// from: public final okio.Path get(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Path get3(
    jni.JString string,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get3,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_get4 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"get", r"(Ljava/io/File;)Lokio/Path;");

  /// from: public final okio.Path get(java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  Path get4(
    jni.JObject file,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get4,
        jni.JniCallType.objectType,
        [file.reference]).object);
  }

  static final _id_get5 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"get", r"(Ljava/nio/file/Path;)Lokio/Path;");

  /// from: public final okio.Path get(java.nio.file.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Path get5(
    jni.JObject path,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get5,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory Path_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return Path_Companion.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [defaultConstructorMarker.reference]).object);
  }
}

final class $Path_CompanionType extends jni.JObjType<Path_Companion> {
  const $Path_CompanionType();

  @override
  String get signature => r"Lokio/Path$Companion;";

  @override
  Path_Companion fromRef(jni.JObjectPtr ref) => Path_Companion.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Path_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Path_CompanionType) &&
        other is $Path_CompanionType;
  }
}

/// from: okio.Path
class Path extends jni.JObject {
  @override
  late final jni.JObjType<Path> $type = type;

  Path.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Path");

  /// The type which includes information such as the signature of this class.
  static const type = $PathType();
  static final _id_Companion = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Companion",
    r"Lokio/Path$Companion;",
  );

  /// from: static public final okio.Path$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static Path_Companion get Companion =>
      const $Path_CompanionType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_Companion, jni.JniCallType.objectType)
          .object);

  static final _id_DIRECTORY_SEPARATOR = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"DIRECTORY_SEPARATOR",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String DIRECTORY_SEPARATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DIRECTORY_SEPARATOR =>
      const jni.JStringType().fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_DIRECTORY_SEPARATOR,
              jni.JniCallType.objectType)
          .object);

  static final _id_new0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Lokio/ByteString;)V");

  /// from: public void <init>(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  factory Path(
    ByteString byteString,
  ) {
    return Path.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [byteString.reference]).object);
  }

  static final _id_getRoot = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getRoot", r"()Lokio/Path;");

  /// from: public final okio.Path getRoot()
  /// The returned object must be released after use, by calling the [release] method.
  Path getRoot() {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getRoot, jni.JniCallType.objectType, []).object);
  }

  static final _id_getSegments = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getSegments", r"()Ljava/util/List;");

  /// from: public final java.util.List getSegments()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> getSegments() {
    return const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_getSegments, jni.JniCallType.objectType, []).object);
  }

  static final _id_getSegmentsBytes = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getSegmentsBytes", r"()Ljava/util/List;");

  /// from: public final java.util.List getSegmentsBytes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<ByteString> getSegmentsBytes() {
    return const jni.JListType($ByteStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getSegmentsBytes,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_isAbsolute =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isAbsolute", r"()Z");

  /// from: public final boolean isAbsolute()
  bool isAbsolute() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isAbsolute, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isRelative =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isRelative", r"()Z");

  /// from: public final boolean isRelative()
  bool isRelative() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isRelative, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_volumeLetter = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"volumeLetter", r"()Ljava/lang/Character;");

  /// from: public final java.lang.Character volumeLetter()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JCharacter volumeLetter() {
    return const jni.JCharacterType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_volumeLetter,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_nameBytes = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"nameBytes", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString nameBytes()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString nameBytes() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_nameBytes, jni.JniCallType.objectType, []).object);
  }

  static final _id_name = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"name", r"()Ljava/lang/String;");

  /// from: public final java.lang.String name()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString name() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_name, jni.JniCallType.objectType, []).object);
  }

  static final _id_parent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"parent", r"()Lokio/Path;");

  /// from: public final okio.Path parent()
  /// The returned object must be released after use, by calling the [release] method.
  Path parent() {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_parent, jni.JniCallType.objectType, []).object);
  }

  static final _id_isRoot =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isRoot", r"()Z");

  /// from: public final boolean isRoot()
  bool isRoot() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isRoot, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_resolve = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"resolve", r"(Ljava/lang/String;)Lokio/Path;");

  /// from: public final okio.Path resolve(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Path resolve(
    jni.JString string,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_resolve,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_resolve1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"resolve", r"(Lokio/ByteString;)Lokio/Path;");

  /// from: public final okio.Path resolve(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  Path resolve1(
    ByteString byteString,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_resolve1,
        jni.JniCallType.objectType,
        [byteString.reference]).object);
  }

  static final _id_resolve2 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"resolve", r"(Lokio/Path;)Lokio/Path;");

  /// from: public final okio.Path resolve(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Path resolve2(
    Path path,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_resolve2,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_resolve3 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"resolve", r"(Ljava/lang/String;Z)Lokio/Path;");

  /// from: public final okio.Path resolve(java.lang.String string, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Path resolve3(
    jni.JString string,
    bool z,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_resolve3,
        jni.JniCallType.objectType,
        [string.reference, z ? 1 : 0]).object);
  }

  static final _id_resolve4 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"resolve", r"(Lokio/ByteString;Z)Lokio/Path;");

  /// from: public final okio.Path resolve(okio.ByteString byteString, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Path resolve4(
    ByteString byteString,
    bool z,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_resolve4,
        jni.JniCallType.objectType,
        [byteString.reference, z ? 1 : 0]).object);
  }

  static final _id_resolve5 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"resolve", r"(Lokio/Path;Z)Lokio/Path;");

  /// from: public final okio.Path resolve(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Path resolve5(
    Path path,
    bool z,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_resolve5,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_relativeTo = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"relativeTo", r"(Lokio/Path;)Lokio/Path;");

  /// from: public final okio.Path relativeTo(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Path relativeTo(
    Path path,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_relativeTo,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_normalized = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"normalized", r"()Lokio/Path;");

  /// from: public final okio.Path normalized()
  /// The returned object must be released after use, by calling the [release] method.
  Path normalized() {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_normalized, jni.JniCallType.objectType, []).object);
  }

  static final _id_toFile = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toFile", r"()Ljava/io/File;");

  /// from: public final java.io.File toFile()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject toFile() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toFile, jni.JniCallType.objectType, []).object);
  }

  static final _id_toNioPath = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toNioPath", r"()Ljava/nio/file/Path;");

  /// from: public final java.nio.file.Path toNioPath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject toNioPath() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toNioPath, jni.JniCallType.objectType, []).object);
  }

  static final _id_compareTo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"compareTo", r"(Lokio/Path;)I");

  /// from: public int compareTo(okio.Path path)
  int compareTo(
    Path path,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_compareTo,
        jni.JniCallType.intType, [path.reference]).integer;
  }

  static final _id_equals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"equals", r"(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [object.reference]).boolean;
  }

  static final _id_hashCode1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"hashCode", r"()I");

  /// from: public int hashCode()
  int hashCode1() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hashCode1, jni.JniCallType.intType, []).integer;
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id_get0 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"get", r"(Ljava/lang/String;Z)Lokio/Path;");

  /// from: static public final okio.Path get(java.lang.String string, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static Path get0(
    jni.JString string,
    bool z,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_get0,
        jni.JniCallType.objectType,
        [string.reference, z ? 1 : 0]).object);
  }

  static final _id_get1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"get", r"(Ljava/io/File;Z)Lokio/Path;");

  /// from: static public final okio.Path get(java.io.File file, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static Path get1(
    jni.JObject file,
    bool z,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_get1,
        jni.JniCallType.objectType,
        [file.reference, z ? 1 : 0]).object);
  }

  static final _id_get2 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"get", r"(Ljava/nio/file/Path;Z)Lokio/Path;");

  /// from: static public final okio.Path get(java.nio.file.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static Path get2(
    jni.JObject path,
    bool z,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_get2,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_get3 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"get", r"(Ljava/lang/String;)Lokio/Path;");

  /// from: static public final okio.Path get(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Path get3(
    jni.JString string,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_get3,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_get4 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"get", r"(Ljava/io/File;)Lokio/Path;");

  /// from: static public final okio.Path get(java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static Path get4(
    jni.JObject file,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_get4,
        jni.JniCallType.objectType,
        [file.reference]).object);
  }

  static final _id_get5 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"get", r"(Ljava/nio/file/Path;)Lokio/Path;");

  /// from: static public final okio.Path get(java.nio.file.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  static Path get5(
    jni.JObject path,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_get5,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_compareTo1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"compareTo", r"(Ljava/lang/Object;)I");

  /// from: public int compareTo(java.lang.Object object)
  int compareTo1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_compareTo1,
        jni.JniCallType.intType, [object.reference]).integer;
  }
}

final class $PathType extends jni.JObjType<Path> {
  const $PathType();

  @override
  String get signature => r"Lokio/Path;";

  @override
  Path fromRef(jni.JObjectPtr ref) => Path.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PathType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PathType) && other is $PathType;
  }
}

/// from: okio.PeekSource
class PeekSource extends jni.JObject {
  @override
  late final jni.JObjType<PeekSource> $type = type;

  PeekSource.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/PeekSource");

  /// The type which includes information such as the signature of this class.
  static const type = $PeekSourceType();
  static final _id_new0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Lokio/BufferedSource;)V");

  /// from: public void <init>(okio.BufferedSource bufferedSource)
  /// The returned object must be released after use, by calling the [release] method.
  factory PeekSource(
    BufferedSource bufferedSource,
  ) {
    return PeekSource.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [bufferedSource.reference]).object);
  }

  static final _id_read = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"read", r"(Lokio/Buffer;J)J");

  /// from: public long read(okio.Buffer buffer, long j)
  int read(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_read,
        jni.JniCallType.longType, [buffer.reference, j]).long;
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }
}

final class $PeekSourceType extends jni.JObjType<PeekSource> {
  const $PeekSourceType();

  @override
  String get signature => r"Lokio/PeekSource;";

  @override
  PeekSource fromRef(jni.JObjectPtr ref) => PeekSource.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PeekSourceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PeekSourceType) && other is $PeekSourceType;
  }
}

/// from: okio.Pipe
class Pipe extends jni.JObject {
  @override
  late final jni.JObjType<Pipe> $type = type;

  Pipe.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Pipe");

  /// The type which includes information such as the signature of this class.
  static const type = $PipeType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"(J)V");

  /// from: public void <init>(long j)
  /// The returned object must be released after use, by calling the [release] method.
  factory Pipe(
    int j,
  ) {
    return Pipe.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, [j]).object);
  }

  static final _id_getLock = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"getLock", r"()Ljava/util/concurrent/locks/ReentrantLock;");

  /// from: public final java.util.concurrent.locks.ReentrantLock getLock()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getLock() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getLock, jni.JniCallType.objectType, []).object);
  }

  static final _id_getCondition = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getCondition",
      r"()Ljava/util/concurrent/locks/Condition;");

  /// from: public final java.util.concurrent.locks.Condition getCondition()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCondition() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getCondition, jni.JniCallType.objectType, []).object);
  }

  static final _id_sink = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sink", r"()Lokio/Sink;");

  /// from: public final okio.Sink sink()
  /// The returned object must be released after use, by calling the [release] method.
  Sink sink() {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_sink, jni.JniCallType.objectType, []).object);
  }

  static final _id_source = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"source", r"()Lokio/Source;");

  /// from: public final okio.Source source()
  /// The returned object must be released after use, by calling the [release] method.
  Source source() {
    return const $SourceType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_source, jni.JniCallType.objectType, []).object);
  }

  static final _id_fold = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"fold", r"(Lokio/Sink;)V");

  /// from: public final void fold(okio.Sink sink)
  void fold(
    Sink sink,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_fold,
        jni.JniCallType.voidType, [sink.reference]).check();
  }

  static final _id__deprecated_sink = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_sink", r"()Lokio/Sink;");

  /// from: public final okio.Sink -deprecated_sink()
  /// The returned object must be released after use, by calling the [release] method.
  Sink _deprecated_sink() {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_sink,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_source = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_source", r"()Lokio/Source;");

  /// from: public final okio.Source -deprecated_source()
  /// The returned object must be released after use, by calling the [release] method.
  Source _deprecated_source() {
    return const $SourceType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_source,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_cancel =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"cancel", r"()V");

  /// from: public final void cancel()
  void cancel() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cancel, jni.JniCallType.voidType, []).check();
  }
}

final class $PipeType extends jni.JObjType<Pipe> {
  const $PipeType();

  @override
  String get signature => r"Lokio/Pipe;";

  @override
  Pipe fromRef(jni.JObjectPtr ref) => Pipe.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PipeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PipeType) && other is $PipeType;
  }
}

/// from: okio.RealBufferedSink
class RealBufferedSink extends jni.JObject {
  @override
  late final jni.JObjType<RealBufferedSink> $type = type;

  RealBufferedSink.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/RealBufferedSink");

  /// The type which includes information such as the signature of this class.
  static const type = $RealBufferedSinkType();
  static final _id_sink = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"sink",
    r"Lokio/Sink;",
  );

  /// from: public final okio.Sink sink
  /// The returned object must be released after use, by calling the [release] method.
  Sink get sink => const $SinkType().fromRef(jni.Jni.accessors
      .getField(reference, _id_sink, jni.JniCallType.objectType)
      .object);

  static final _id_bufferField = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"bufferField",
    r"Lokio/Buffer;",
  );

  /// from: public final okio.Buffer bufferField
  /// The returned object must be released after use, by calling the [release] method.
  Buffer get bufferField => const $BufferType().fromRef(jni.Jni.accessors
      .getField(reference, _id_bufferField, jni.JniCallType.objectType)
      .object);

  static final _id_closed = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"closed",
    r"Z",
  );

  /// from: public boolean closed
  bool get closed => jni.Jni.accessors
      .getField(reference, _id_closed, jni.JniCallType.booleanType)
      .boolean;

  /// from: public boolean closed
  set closed(bool value) =>
      jni.Jni.env.SetBooleanField(reference, _id_closed, value ? 1 : 0);

  static final _id_new0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Lokio/Sink;)V");

  /// from: public void <init>(okio.Sink sink)
  /// The returned object must be released after use, by calling the [release] method.
  factory RealBufferedSink(
    Sink sink,
  ) {
    return RealBufferedSink.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [sink.reference]).object);
  }

  static final _id_getBuffer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getBuffer", r"()Lokio/Buffer;");

  /// from: public okio.Buffer getBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer getBuffer() {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getBuffer, jni.JniCallType.objectType, []).object);
  }

  static final _id_buffer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"buffer", r"()Lokio/Buffer;");

  /// from: public okio.Buffer buffer()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer buffer() {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_buffer, jni.JniCallType.objectType, []).object);
  }

  static final _id_write = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"(Lokio/Buffer;J)V");

  /// from: public void write(okio.Buffer buffer, long j)
  void write(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write,
        jni.JniCallType.voidType, [buffer.reference, j]).check();
  }

  static final _id_write1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"write", r"(Lokio/ByteString;)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink write(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write1(
    ByteString byteString,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write1, jni.JniCallType.objectType,
            [byteString.reference]).object);
  }

  static final _id_write2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"write", r"(Lokio/ByteString;II)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink write(okio.ByteString byteString, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write2(
    ByteString byteString,
    int i,
    int i1,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write2, jni.JniCallType.objectType, [
      byteString.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1)
    ]).object);
  }

  static final _id_writeUtf8 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"writeUtf8", r"(Ljava/lang/String;)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeUtf8(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeUtf8(
    jni.JString string,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeUtf8,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_writeUtf81 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeUtf8",
      r"(Ljava/lang/String;II)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeUtf8(java.lang.String string, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeUtf81(
    jni.JString string,
    int i,
    int i1,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_writeUtf81,
            jni.JniCallType.objectType,
            [string.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id_writeUtf8CodePoint = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeUtf8CodePoint", r"(I)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeUtf8CodePoint(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeUtf8CodePoint(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeUtf8CodePoint,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeString = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeString",
      r"(Ljava/lang/String;Ljava/nio/charset/Charset;)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeString(java.lang.String string, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeString(
    jni.JString string,
    jni.JObject charset,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_writeString,
            jni.JniCallType.objectType,
            [string.reference, charset.reference]).object);
  }

  static final _id_writeString1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeString",
      r"(Ljava/lang/String;IILjava/nio/charset/Charset;)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeString(java.lang.String string, int i, int i1, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeString1(
    jni.JString string,
    int i,
    int i1,
    jni.JObject charset,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_writeString1, jni.JniCallType.objectType, [
      string.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      charset.reference
    ]).object);
  }

  static final _id_write3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"([B)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink write(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write3(
    jni.JArray<jni.jbyte> bs,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write3, jni.JniCallType.objectType,
            [bs.reference]).object);
  }

  static final _id_write4 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"([BII)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink write(byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write4(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write4, jni.JniCallType.objectType,
            [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id_write5 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"(Ljava/nio/ByteBuffer;)I");

  /// from: public int write(java.nio.ByteBuffer byteBuffer)
  int write5(
    jni.JByteBuffer byteBuffer,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write5,
        jni.JniCallType.intType, [byteBuffer.reference]).integer;
  }

  static final _id_writeAll = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeAll", r"(Lokio/Source;)J");

  /// from: public long writeAll(okio.Source source)
  int writeAll(
    Source source,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeAll,
        jni.JniCallType.longType, [source.reference]).long;
  }

  static final _id_write6 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"write", r"(Lokio/Source;J)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink write(okio.Source source, long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink write6(
    Source source,
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_write6, jni.JniCallType.objectType,
            [source.reference, j]).object);
  }

  static final _id_writeByte = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeByte", r"(I)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeByte(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeByte(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeByte,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeShort = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeShort", r"(I)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeShort(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeShort(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeShort,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeShortLe = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeShortLe", r"(I)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeShortLe(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeShortLe(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeShortLe,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeInt = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeInt", r"(I)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeInt(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeInt(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeInt, jni.JniCallType.objectType,
            [jni.JValueInt(i)]).object);
  }

  static final _id_writeIntLe = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeIntLe", r"(I)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeIntLe(int i)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeIntLe(
    int i,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeIntLe,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_writeLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeLong", r"(J)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeLong(long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeLong(
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_writeLong, jni.JniCallType.objectType, [j]).object);
  }

  static final _id_writeLongLe = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeLongLe", r"(J)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeLongLe(long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeLongLe(
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeLongLe,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_writeDecimalLong = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"writeDecimalLong", r"(J)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeDecimalLong(long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeDecimalLong(
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeDecimalLong,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_writeHexadecimalUnsignedLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeHexadecimalUnsignedLong",
          r"(J)Lokio/BufferedSink;");

  /// from: public okio.BufferedSink writeHexadecimalUnsignedLong(long j)
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink writeHexadecimalUnsignedLong(
    int j,
  ) {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeHexadecimalUnsignedLong,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_emitCompleteSegments = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"emitCompleteSegments", r"()Lokio/BufferedSink;");

  /// from: public okio.BufferedSink emitCompleteSegments()
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink emitCompleteSegments() {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_emitCompleteSegments,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_emit = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"emit", r"()Lokio/BufferedSink;");

  /// from: public okio.BufferedSink emit()
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSink emit() {
    return const $BufferedSinkType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_emit, jni.JniCallType.objectType, []).object);
  }

  static final _id_outputStream = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"outputStream", r"()Ljava/io/OutputStream;");

  /// from: public java.io.OutputStream outputStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject outputStream() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_outputStream, jni.JniCallType.objectType, []).object);
  }

  static final _id_flush =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"flush", r"()V");

  /// from: public void flush()
  void flush() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_flush, jni.JniCallType.voidType, []).check();
  }

  static final _id_isOpen =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isOpen", r"()Z");

  /// from: public boolean isOpen()
  bool isOpen() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isOpen, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }
}

final class $RealBufferedSinkType extends jni.JObjType<RealBufferedSink> {
  const $RealBufferedSinkType();

  @override
  String get signature => r"Lokio/RealBufferedSink;";

  @override
  RealBufferedSink fromRef(jni.JObjectPtr ref) => RealBufferedSink.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RealBufferedSinkType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RealBufferedSinkType) &&
        other is $RealBufferedSinkType;
  }
}

/// from: okio.RealBufferedSource
class RealBufferedSource extends jni.JObject {
  @override
  late final jni.JObjType<RealBufferedSource> $type = type;

  RealBufferedSource.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/RealBufferedSource");

  /// The type which includes information such as the signature of this class.
  static const type = $RealBufferedSourceType();
  static final _id_source = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"source",
    r"Lokio/Source;",
  );

  /// from: public final okio.Source source
  /// The returned object must be released after use, by calling the [release] method.
  Source get source => const $SourceType().fromRef(jni.Jni.accessors
      .getField(reference, _id_source, jni.JniCallType.objectType)
      .object);

  static final _id_bufferField = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"bufferField",
    r"Lokio/Buffer;",
  );

  /// from: public final okio.Buffer bufferField
  /// The returned object must be released after use, by calling the [release] method.
  Buffer get bufferField => const $BufferType().fromRef(jni.Jni.accessors
      .getField(reference, _id_bufferField, jni.JniCallType.objectType)
      .object);

  static final _id_closed = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"closed",
    r"Z",
  );

  /// from: public boolean closed
  bool get closed => jni.Jni.accessors
      .getField(reference, _id_closed, jni.JniCallType.booleanType)
      .boolean;

  /// from: public boolean closed
  set closed(bool value) =>
      jni.Jni.env.SetBooleanField(reference, _id_closed, value ? 1 : 0);

  static final _id_new0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Lokio/Source;)V");

  /// from: public void <init>(okio.Source source)
  /// The returned object must be released after use, by calling the [release] method.
  factory RealBufferedSource(
    Source source,
  ) {
    return RealBufferedSource.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [source.reference]).object);
  }

  static final _id_getBuffer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getBuffer", r"()Lokio/Buffer;");

  /// from: public okio.Buffer getBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer getBuffer() {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getBuffer, jni.JniCallType.objectType, []).object);
  }

  static final _id_buffer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"buffer", r"()Lokio/Buffer;");

  /// from: public okio.Buffer buffer()
  /// The returned object must be released after use, by calling the [release] method.
  Buffer buffer() {
    return const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_buffer, jni.JniCallType.objectType, []).object);
  }

  static final _id_read = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"read", r"(Lokio/Buffer;J)J");

  /// from: public long read(okio.Buffer buffer, long j)
  int read(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_read,
        jni.JniCallType.longType, [buffer.reference, j]).long;
  }

  static final _id_exhausted =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"exhausted", r"()Z");

  /// from: public boolean exhausted()
  bool exhausted() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_exhausted, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_require =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"require", r"(J)V");

  /// from: public void require(long j)
  void require(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_require, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_request =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"request", r"(J)Z");

  /// from: public boolean request(long j)
  bool request(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_request, jni.JniCallType.booleanType, [j]).boolean;
  }

  static final _id_readByte =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readByte", r"()B");

  /// from: public byte readByte()
  int readByte() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readByte, jni.JniCallType.byteType, []).byte;
  }

  static final _id_readByteString = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readByteString", r"()Lokio/ByteString;");

  /// from: public okio.ByteString readByteString()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString readByteString() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readByteString, jni.JniCallType.objectType, []).object);
  }

  static final _id_readByteString1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readByteString", r"(J)Lokio/ByteString;");

  /// from: public okio.ByteString readByteString(long j)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString readByteString1(
    int j,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readByteString1,
        jni.JniCallType.objectType,
        [j]).object);
  }

  static final _id_select = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"select", r"(Lokio/Options;)I");

  /// from: public int select(okio.Options options)
  int select(
    Options options,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_select,
        jni.JniCallType.intType, [options.reference]).integer;
  }

  static final _id_readByteArray = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readByteArray", r"()[B");

  /// from: public byte[] readByteArray()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> readByteArray() {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readByteArray,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_readByteArray1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readByteArray", r"(J)[B");

  /// from: public byte[] readByteArray(long j)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> readByteArray1(
    int j,
  ) {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readByteArray1,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_read1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"read", r"([B)I");

  /// from: public int read(byte[] bs)
  int read1(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_read1, jni.JniCallType.intType, [bs.reference]).integer;
  }

  static final _id_readFully =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readFully", r"([B)V");

  /// from: public void readFully(byte[] bs)
  void readFully(
    jni.JArray<jni.jbyte> bs,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_readFully,
        jni.JniCallType.voidType, [bs.reference]).check();
  }

  static final _id_read2 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"read", r"([BII)I");

  /// from: public int read(byte[] bs, int i, int i1)
  int read2(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_read2,
        jni.JniCallType.intType,
        [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).integer;
  }

  static final _id_read3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"read", r"(Ljava/nio/ByteBuffer;)I");

  /// from: public int read(java.nio.ByteBuffer byteBuffer)
  int read3(
    jni.JByteBuffer byteBuffer,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_read3,
        jni.JniCallType.intType, [byteBuffer.reference]).integer;
  }

  static final _id_readFully1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readFully", r"(Lokio/Buffer;J)V");

  /// from: public void readFully(okio.Buffer buffer, long j)
  void readFully1(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_readFully1,
        jni.JniCallType.voidType, [buffer.reference, j]).check();
  }

  static final _id_readAll = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readAll", r"(Lokio/Sink;)J");

  /// from: public long readAll(okio.Sink sink)
  int readAll(
    Sink sink,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_readAll,
        jni.JniCallType.longType, [sink.reference]).long;
  }

  static final _id_readUtf8 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUtf8", r"()Ljava/lang/String;");

  /// from: public java.lang.String readUtf8()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf8, jni.JniCallType.objectType, []).object);
  }

  static final _id_readUtf81 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUtf8", r"(J)Ljava/lang/String;");

  /// from: public java.lang.String readUtf8(long j)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf81(
    int j,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf81, jni.JniCallType.objectType, [j]).object);
  }

  static final _id_readString = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readString",
      r"(Ljava/nio/charset/Charset;)Ljava/lang/String;");

  /// from: public java.lang.String readString(java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readString(
    jni.JObject charset,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readString,
        jni.JniCallType.objectType,
        [charset.reference]).object);
  }

  static final _id_readString1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readString",
      r"(JLjava/nio/charset/Charset;)Ljava/lang/String;");

  /// from: public java.lang.String readString(long j, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readString1(
    int j,
    jni.JObject charset,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readString1,
        jni.JniCallType.objectType,
        [j, charset.reference]).object);
  }

  static final _id_readUtf8Line = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readUtf8Line", r"()Ljava/lang/String;");

  /// from: public java.lang.String readUtf8Line()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8Line() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf8Line, jni.JniCallType.objectType, []).object);
  }

  static final _id_readUtf8LineStrict = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readUtf8LineStrict", r"()Ljava/lang/String;");

  /// from: public java.lang.String readUtf8LineStrict()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8LineStrict() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readUtf8LineStrict,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_readUtf8LineStrict1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"readUtf8LineStrict", r"(J)Ljava/lang/String;");

  /// from: public java.lang.String readUtf8LineStrict(long j)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString readUtf8LineStrict1(
    int j,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_readUtf8LineStrict1,
        jni.JniCallType.objectType,
        [j]).object);
  }

  static final _id_readUtf8CodePoint = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readUtf8CodePoint", r"()I");

  /// from: public int readUtf8CodePoint()
  int readUtf8CodePoint() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readUtf8CodePoint, jni.JniCallType.intType, []).integer;
  }

  static final _id_readShort =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readShort", r"()S");

  /// from: public short readShort()
  int readShort() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readShort, jni.JniCallType.shortType, []).short;
  }

  static final _id_readShortLe =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readShortLe", r"()S");

  /// from: public short readShortLe()
  int readShortLe() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readShortLe, jni.JniCallType.shortType, []).short;
  }

  static final _id_readInt =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readInt", r"()I");

  /// from: public int readInt()
  int readInt() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readInt, jni.JniCallType.intType, []).integer;
  }

  static final _id_readIntLe =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readIntLe", r"()I");

  /// from: public int readIntLe()
  int readIntLe() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readIntLe, jni.JniCallType.intType, []).integer;
  }

  static final _id_readLong =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readLong", r"()J");

  /// from: public long readLong()
  int readLong() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readLong, jni.JniCallType.longType, []).long;
  }

  static final _id_readLongLe =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"readLongLe", r"()J");

  /// from: public long readLongLe()
  int readLongLe() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readLongLe, jni.JniCallType.longType, []).long;
  }

  static final _id_readDecimalLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readDecimalLong", r"()J");

  /// from: public long readDecimalLong()
  int readDecimalLong() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readDecimalLong, jni.JniCallType.longType, []).long;
  }

  static final _id_readHexadecimalUnsignedLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readHexadecimalUnsignedLong", r"()J");

  /// from: public long readHexadecimalUnsignedLong()
  int readHexadecimalUnsignedLong() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_readHexadecimalUnsignedLong, jni.JniCallType.longType, []).long;
  }

  static final _id_skip =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"skip", r"(J)V");

  /// from: public void skip(long j)
  void skip(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_skip, jni.JniCallType.voidType, [j]).check();
  }

  static final _id_indexOf =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"(B)J");

  /// from: public long indexOf(byte b)
  int indexOf(
    int b,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf,
        jni.JniCallType.longType, [jni.JValueByte(b)]).long;
  }

  static final _id_indexOf1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"(BJ)J");

  /// from: public long indexOf(byte b, long j)
  int indexOf1(
    int b,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf1,
        jni.JniCallType.longType, [jni.JValueByte(b), j]).long;
  }

  static final _id_indexOf2 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"(BJJ)J");

  /// from: public long indexOf(byte b, long j, long j1)
  int indexOf2(
    int b,
    int j,
    int j1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf2,
        jni.JniCallType.longType, [jni.JValueByte(b), j, j1]).long;
  }

  static final _id_indexOf3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"indexOf", r"(Lokio/ByteString;)J");

  /// from: public long indexOf(okio.ByteString byteString)
  int indexOf3(
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf3,
        jni.JniCallType.longType, [byteString.reference]).long;
  }

  static final _id_indexOf4 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"indexOf", r"(Lokio/ByteString;J)J");

  /// from: public long indexOf(okio.ByteString byteString, long j)
  int indexOf4(
    ByteString byteString,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf4,
        jni.JniCallType.longType, [byteString.reference, j]).long;
  }

  static final _id_indexOfElement = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"indexOfElement", r"(Lokio/ByteString;)J");

  /// from: public long indexOfElement(okio.ByteString byteString)
  int indexOfElement(
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOfElement,
        jni.JniCallType.longType, [byteString.reference]).long;
  }

  static final _id_indexOfElement1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"indexOfElement", r"(Lokio/ByteString;J)J");

  /// from: public long indexOfElement(okio.ByteString byteString, long j)
  int indexOfElement1(
    ByteString byteString,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOfElement1,
        jni.JniCallType.longType, [byteString.reference, j]).long;
  }

  static final _id_rangeEquals = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"rangeEquals", r"(JLokio/ByteString;)Z");

  /// from: public boolean rangeEquals(long j, okio.ByteString byteString)
  bool rangeEquals(
    int j,
    ByteString byteString,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_rangeEquals,
        jni.JniCallType.booleanType, [j, byteString.reference]).boolean;
  }

  static final _id_rangeEquals1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"rangeEquals", r"(JLokio/ByteString;II)Z");

  /// from: public boolean rangeEquals(long j, okio.ByteString byteString, int i, int i1)
  bool rangeEquals1(
    int j,
    ByteString byteString,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_rangeEquals1,
        jni.JniCallType.booleanType,
        [j, byteString.reference, jni.JValueInt(i), jni.JValueInt(i1)]).boolean;
  }

  static final _id_peek = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"peek", r"()Lokio/BufferedSource;");

  /// from: public okio.BufferedSource peek()
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSource peek() {
    return const $BufferedSourceType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_peek, jni.JniCallType.objectType, []).object);
  }

  static final _id_inputStream = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"inputStream", r"()Ljava/io/InputStream;");

  /// from: public java.io.InputStream inputStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject inputStream() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_inputStream, jni.JniCallType.objectType, []).object);
  }

  static final _id_isOpen =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isOpen", r"()Z");

  /// from: public boolean isOpen()
  bool isOpen() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isOpen, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }
}

final class $RealBufferedSourceType extends jni.JObjType<RealBufferedSource> {
  const $RealBufferedSourceType();

  @override
  String get signature => r"Lokio/RealBufferedSource;";

  @override
  RealBufferedSource fromRef(jni.JObjectPtr ref) =>
      RealBufferedSource.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RealBufferedSourceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RealBufferedSourceType) &&
        other is $RealBufferedSourceType;
  }
}

/// from: okio.Segment$Companion
class Segment_Companion extends jni.JObject {
  @override
  late final jni.JObjType<Segment_Companion> $type = type;

  Segment_Companion.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Segment$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $Segment_CompanionType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory Segment_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return Segment_Companion.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [defaultConstructorMarker.reference]).object);
  }
}

final class $Segment_CompanionType extends jni.JObjType<Segment_Companion> {
  const $Segment_CompanionType();

  @override
  String get signature => r"Lokio/Segment$Companion;";

  @override
  Segment_Companion fromRef(jni.JObjectPtr ref) =>
      Segment_Companion.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Segment_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Segment_CompanionType) &&
        other is $Segment_CompanionType;
  }
}

/// from: okio.Segment
class Segment extends jni.JObject {
  @override
  late final jni.JObjType<Segment> $type = type;

  Segment.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Segment");

  /// The type which includes information such as the signature of this class.
  static const type = $SegmentType();
  static final _id_Companion = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Companion",
    r"Lokio/Segment$Companion;",
  );

  /// from: static public final okio.Segment$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static Segment_Companion get Companion =>
      const $Segment_CompanionType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_Companion, jni.JniCallType.objectType)
          .object);

  static final _id_data = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"data",
    r"[B",
  );

  /// from: public final byte[] data
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> get data =>
      const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
          .getField(reference, _id_data, jni.JniCallType.objectType)
          .object);

  static final _id_pos = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"pos",
    r"I",
  );

  /// from: public int pos
  int get pos => jni.Jni.accessors
      .getField(reference, _id_pos, jni.JniCallType.intType)
      .integer;

  /// from: public int pos
  set pos(int value) => jni.Jni.env.SetIntField(reference, _id_pos, value);

  static final _id_limit = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"limit",
    r"I",
  );

  /// from: public int limit
  int get limit => jni.Jni.accessors
      .getField(reference, _id_limit, jni.JniCallType.intType)
      .integer;

  /// from: public int limit
  set limit(int value) => jni.Jni.env.SetIntField(reference, _id_limit, value);

  static final _id_shared = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"shared",
    r"Z",
  );

  /// from: public boolean shared
  bool get shared => jni.Jni.accessors
      .getField(reference, _id_shared, jni.JniCallType.booleanType)
      .boolean;

  /// from: public boolean shared
  set shared(bool value) =>
      jni.Jni.env.SetBooleanField(reference, _id_shared, value ? 1 : 0);

  static final _id_owner = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"owner",
    r"Z",
  );

  /// from: public boolean owner
  bool get owner => jni.Jni.accessors
      .getField(reference, _id_owner, jni.JniCallType.booleanType)
      .boolean;

  /// from: public boolean owner
  set owner(bool value) =>
      jni.Jni.env.SetBooleanField(reference, _id_owner, value ? 1 : 0);

  static final _id_next = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"next",
    r"Lokio/Segment;",
  );

  /// from: public okio.Segment next
  /// The returned object must be released after use, by calling the [release] method.
  Segment get next => const $SegmentType().fromRef(jni.Jni.accessors
      .getField(reference, _id_next, jni.JniCallType.objectType)
      .object);

  /// from: public okio.Segment next
  /// The returned object must be released after use, by calling the [release] method.
  set next(Segment value) =>
      jni.Jni.env.SetObjectField(reference, _id_next, value.reference);

  static final _id_prev = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"prev",
    r"Lokio/Segment;",
  );

  /// from: public okio.Segment prev
  /// The returned object must be released after use, by calling the [release] method.
  Segment get prev => const $SegmentType().fromRef(jni.Jni.accessors
      .getField(reference, _id_prev, jni.JniCallType.objectType)
      .object);

  /// from: public okio.Segment prev
  /// The returned object must be released after use, by calling the [release] method.
  set prev(Segment value) =>
      jni.Jni.env.SetObjectField(reference, _id_prev, value.reference);

  /// from: static public final int SIZE
  static const SIZE = 8192;

  /// from: static public final int SHARE_MINIMUM
  static const SHARE_MINIMUM = 1024;
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Segment() {
    return Segment.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_new1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"([BIIZZ)V");

  /// from: public void <init>(byte[] bs, int i, int i1, boolean z, boolean z1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Segment.new1(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
    bool z,
    bool z1,
  ) {
    return Segment.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new1, [
      bs.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      z ? 1 : 0,
      z1 ? 1 : 0
    ]).object);
  }

  static final _id_sharedCopy = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sharedCopy", r"()Lokio/Segment;");

  /// from: public final okio.Segment sharedCopy()
  /// The returned object must be released after use, by calling the [release] method.
  Segment sharedCopy() {
    return const $SegmentType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_sharedCopy, jni.JniCallType.objectType, []).object);
  }

  static final _id_unsharedCopy = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"unsharedCopy", r"()Lokio/Segment;");

  /// from: public final okio.Segment unsharedCopy()
  /// The returned object must be released after use, by calling the [release] method.
  Segment unsharedCopy() {
    return const $SegmentType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_unsharedCopy, jni.JniCallType.objectType, []).object);
  }

  static final _id_pop = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"pop", r"()Lokio/Segment;");

  /// from: public final okio.Segment pop()
  /// The returned object must be released after use, by calling the [release] method.
  Segment pop() {
    return const $SegmentType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_pop, jni.JniCallType.objectType, []).object);
  }

  static final _id_push = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"push", r"(Lokio/Segment;)Lokio/Segment;");

  /// from: public final okio.Segment push(okio.Segment segment)
  /// The returned object must be released after use, by calling the [release] method.
  Segment push(
    Segment segment,
  ) {
    return const $SegmentType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_push,
        jni.JniCallType.objectType,
        [segment.reference]).object);
  }

  static final _id_split = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"split", r"(I)Lokio/Segment;");

  /// from: public final okio.Segment split(int i)
  /// The returned object must be released after use, by calling the [release] method.
  Segment split(
    int i,
  ) {
    return const $SegmentType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_split,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_compact =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"compact", r"()V");

  /// from: public final void compact()
  void compact() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_compact, jni.JniCallType.voidType, []).check();
  }

  static final _id_writeTo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeTo", r"(Lokio/Segment;I)V");

  /// from: public final void writeTo(okio.Segment segment, int i)
  void writeTo(
    Segment segment,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_writeTo,
        jni.JniCallType.voidType,
        [segment.reference, jni.JValueInt(i)]).check();
  }
}

final class $SegmentType extends jni.JObjType<Segment> {
  const $SegmentType();

  @override
  String get signature => r"Lokio/Segment;";

  @override
  Segment fromRef(jni.JObjectPtr ref) => Segment.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($SegmentType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($SegmentType) && other is $SegmentType;
  }
}

/// from: okio.SegmentPool
class SegmentPool extends jni.JObject {
  @override
  late final jni.JObjType<SegmentPool> $type = type;

  SegmentPool.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/SegmentPool");

  /// The type which includes information such as the signature of this class.
  static const type = $SegmentPoolType();
  static final _id_INSTANCE = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"INSTANCE",
    r"Lokio/SegmentPool;",
  );

  /// from: static public final okio.SegmentPool INSTANCE
  /// The returned object must be released after use, by calling the [release] method.
  static SegmentPool get INSTANCE =>
      const $SegmentPoolType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_INSTANCE, jni.JniCallType.objectType)
          .object);

  static final _id_getMAX_SIZE =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getMAX_SIZE", r"()I");

  /// from: public final int getMAX_SIZE()
  int getMAX_SIZE() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getMAX_SIZE, jni.JniCallType.intType, []).integer;
  }

  static final _id_getByteCount = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getByteCount", r"()I");

  /// from: public final int getByteCount()
  int getByteCount() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getByteCount, jni.JniCallType.intType, []).integer;
  }

  static final _id_take = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"take", r"()Lokio/Segment;");

  /// from: static public final okio.Segment take()
  /// The returned object must be released after use, by calling the [release] method.
  static Segment take() {
    return const $SegmentType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference, _id_take, jni.JniCallType.objectType, []).object);
  }

  static final _id_recycle = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"recycle", r"(Lokio/Segment;)V");

  /// from: static public final void recycle(okio.Segment segment)
  static void recycle(
    Segment segment,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_recycle, jni.JniCallType.voidType, [segment.reference]).check();
  }
}

final class $SegmentPoolType extends jni.JObjType<SegmentPool> {
  const $SegmentPoolType();

  @override
  String get signature => r"Lokio/SegmentPool;";

  @override
  SegmentPool fromRef(jni.JObjectPtr ref) => SegmentPool.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($SegmentPoolType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($SegmentPoolType) && other is $SegmentPoolType;
  }
}

/// from: okio.SegmentedByteString
class SegmentedByteString extends ByteString {
  @override
  late final jni.JObjType<SegmentedByteString> $type = type;

  SegmentedByteString.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/SegmentedByteString");

  /// The type which includes information such as the signature of this class.
  static const type = $SegmentedByteStringType();
  static final _id_new1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"([[B[I)V");

  /// from: public void <init>(byte[][] bs, int[] is)
  /// The returned object must be released after use, by calling the [release] method.
  factory SegmentedByteString.new1(
    jni.JArray<jni.jbyte> bs,
    jni.JArray<jni.jint> is0,
  ) {
    return SegmentedByteString.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new1, [bs.reference, is0.reference]).object);
  }

  static final _id_string = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"string", r"(Ljava/nio/charset/Charset;)Ljava/lang/String;");

  /// from: public java.lang.String string(java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString string(
    jni.JObject charset,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_string,
        jni.JniCallType.objectType,
        [charset.reference]).object);
  }

  static final _id_base64 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"base64", r"()Ljava/lang/String;");

  /// from: public java.lang.String base64()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString base64() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_base64, jni.JniCallType.objectType, []).object);
  }

  static final _id_hex = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"hex", r"()Ljava/lang/String;");

  /// from: public java.lang.String hex()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString hex() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hex, jni.JniCallType.objectType, []).object);
  }

  static final _id_toAsciiLowercase = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"toAsciiLowercase", r"()Lokio/ByteString;");

  /// from: public okio.ByteString toAsciiLowercase()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString toAsciiLowercase() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_toAsciiLowercase,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_toAsciiUppercase = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"toAsciiUppercase", r"()Lokio/ByteString;");

  /// from: public okio.ByteString toAsciiUppercase()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString toAsciiUppercase() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_toAsciiUppercase,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_base64Url = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"base64Url", r"()Ljava/lang/String;");

  /// from: public java.lang.String base64Url()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString base64Url() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_base64Url, jni.JniCallType.objectType, []).object);
  }

  static final _id_substring = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"substring", r"(II)Lokio/ByteString;");

  /// from: public okio.ByteString substring(int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString substring(
    int i,
    int i1,
  ) {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_substring,
        jni.JniCallType.objectType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id_toByteArray = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toByteArray", r"()[B");

  /// from: public byte[] toByteArray()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> toByteArray() {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_toByteArray, jni.JniCallType.objectType, []).object);
  }

  static final _id_asByteBuffer = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"asByteBuffer", r"()Ljava/nio/ByteBuffer;");

  /// from: public java.nio.ByteBuffer asByteBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JByteBuffer asByteBuffer() {
    return const jni.JByteBufferType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_asByteBuffer,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_write = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"(Ljava/io/OutputStream;)V");

  /// from: public void write(java.io.OutputStream outputStream)
  void write(
    jni.JObject outputStream,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write,
        jni.JniCallType.voidType, [outputStream.reference]).check();
  }

  static final _id_rangeEquals = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"rangeEquals", r"(ILokio/ByteString;II)Z");

  /// from: public boolean rangeEquals(int i, okio.ByteString byteString, int i1, int i2)
  bool rangeEquals(
    int i,
    ByteString byteString,
    int i1,
    int i2,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_rangeEquals, jni.JniCallType.booleanType, [
      jni.JValueInt(i),
      byteString.reference,
      jni.JValueInt(i1),
      jni.JValueInt(i2)
    ]).boolean;
  }

  static final _id_rangeEquals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"rangeEquals", r"(I[BII)Z");

  /// from: public boolean rangeEquals(int i, byte[] bs, int i1, int i2)
  bool rangeEquals1(
    int i,
    jni.JArray<jni.jbyte> bs,
    int i1,
    int i2,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_rangeEquals1, jni.JniCallType.booleanType, [
      jni.JValueInt(i),
      bs.reference,
      jni.JValueInt(i1),
      jni.JValueInt(i2)
    ]).boolean;
  }

  static final _id_copyInto = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"copyInto", r"(I[BII)V");

  /// from: public void copyInto(int i, byte[] bs, int i1, int i2)
  void copyInto(
    int i,
    jni.JArray<jni.jbyte> bs,
    int i1,
    int i2,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_copyInto, jni.JniCallType.voidType, [
      jni.JValueInt(i),
      bs.reference,
      jni.JValueInt(i1),
      jni.JValueInt(i2)
    ]).check();
  }

  static final _id_indexOf1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"indexOf", r"([BI)I");

  /// from: public int indexOf(byte[] bs, int i)
  int indexOf1(
    jni.JArray<jni.jbyte> bs,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_indexOf1,
        jni.JniCallType.intType, [bs.reference, jni.JValueInt(i)]).integer;
  }

  static final _id_lastIndexOf1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"lastIndexOf", r"([BI)I");

  /// from: public int lastIndexOf(byte[] bs, int i)
  int lastIndexOf1(
    jni.JArray<jni.jbyte> bs,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_lastIndexOf1,
        jni.JniCallType.intType, [bs.reference, jni.JValueInt(i)]).integer;
  }

  static final _id_equals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"equals", r"(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [object.reference]).boolean;
  }

  static final _id_hashCode1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"hashCode", r"()I");

  /// from: public int hashCode()
  int hashCode1() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hashCode1, jni.JniCallType.intType, []).integer;
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }
}

final class $SegmentedByteStringType extends jni.JObjType<SegmentedByteString> {
  const $SegmentedByteStringType();

  @override
  String get signature => r"Lokio/SegmentedByteString;";

  @override
  SegmentedByteString fromRef(jni.JObjectPtr ref) =>
      SegmentedByteString.fromRef(ref);

  @override
  jni.JObjType get superType => const $ByteStringType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($SegmentedByteStringType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($SegmentedByteStringType) &&
        other is $SegmentedByteStringType;
  }
}

/// from: okio.Sink
class Sink extends jni.JObject {
  @override
  late final jni.JObjType<Sink> $type = type;

  Sink.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Sink");

  /// The type which includes information such as the signature of this class.
  static const type = $SinkType();
  static final _id_write = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"write", r"(Lokio/Buffer;J)V");

  /// from: public abstract void write(okio.Buffer buffer, long j)
  void write(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_write,
        jni.JniCallType.voidType, [buffer.reference, j]).check();
  }

  static final _id_flush =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"flush", r"()V");

  /// from: public abstract void flush()
  void flush() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_flush, jni.JniCallType.voidType, []).check();
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public abstract okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public abstract void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }
}

final class $SinkType extends jni.JObjType<Sink> {
  const $SinkType();

  @override
  String get signature => r"Lokio/Sink;";

  @override
  Sink fromRef(jni.JObjectPtr ref) => Sink.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($SinkType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($SinkType) && other is $SinkType;
  }
}

/// from: okio.Source
class Source extends jni.JObject {
  @override
  late final jni.JObjType<Source> $type = type;

  Source.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Source");

  /// The type which includes information such as the signature of this class.
  static const type = $SourceType();
  static final _id_read = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"read", r"(Lokio/Buffer;J)J");

  /// from: public abstract long read(okio.Buffer buffer, long j)
  int read(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_read,
        jni.JniCallType.longType, [buffer.reference, j]).long;
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public abstract okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public abstract void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }
}

final class $SourceType extends jni.JObjType<Source> {
  const $SourceType();

  @override
  String get signature => r"Lokio/Source;";

  @override
  Source fromRef(jni.JObjectPtr ref) => Source.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($SourceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($SourceType) && other is $SourceType;
  }
}

/// from: okio.Throttler
class Throttler extends jni.JObject {
  @override
  late final jni.JObjType<Throttler> $type = type;

  Throttler.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Throttler");

  /// The type which includes information such as the signature of this class.
  static const type = $ThrottlerType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"(J)V");

  /// from: public void <init>(long j)
  /// The returned object must be released after use, by calling the [release] method.
  factory Throttler(
    int j,
  ) {
    return Throttler.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, [j]).object);
  }

  static final _id_getLock = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"getLock", r"()Ljava/util/concurrent/locks/ReentrantLock;");

  /// from: public final java.util.concurrent.locks.ReentrantLock getLock()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getLock() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getLock, jni.JniCallType.objectType, []).object);
  }

  static final _id_getCondition = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getCondition",
      r"()Ljava/util/concurrent/locks/Condition;");

  /// from: public final java.util.concurrent.locks.Condition getCondition()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCondition() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getCondition, jni.JniCallType.objectType, []).object);
  }

  static final _id_new1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Throttler.new1() {
    return Throttler.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new1, []).object);
  }

  static final _id_bytesPerSecond = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"bytesPerSecond", r"(JJJ)V");

  /// from: public final void bytesPerSecond(long j, long j1, long j2)
  void bytesPerSecond(
    int j,
    int j1,
    int j2,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_bytesPerSecond,
        jni.JniCallType.voidType, [j, j1, j2]).check();
  }

  static final _id_source = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"source", r"(Lokio/Source;)Lokio/Source;");

  /// from: public final okio.Source source(okio.Source source)
  /// The returned object must be released after use, by calling the [release] method.
  Source source(
    Source source,
  ) {
    return const $SourceType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_source,
        jni.JniCallType.objectType,
        [source.reference]).object);
  }

  static final _id_sink = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sink", r"(Lokio/Sink;)Lokio/Sink;");

  /// from: public final okio.Sink sink(okio.Sink sink)
  /// The returned object must be released after use, by calling the [release] method.
  Sink sink(
    Sink sink,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sink,
        jni.JniCallType.objectType,
        [sink.reference]).object);
  }

  static final _id_bytesPerSecond1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"bytesPerSecond", r"(JJ)V");

  /// from: public final void bytesPerSecond(long j, long j1)
  void bytesPerSecond1(
    int j,
    int j1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_bytesPerSecond1,
        jni.JniCallType.voidType, [j, j1]).check();
  }

  static final _id_bytesPerSecond2 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"bytesPerSecond", r"(J)V");

  /// from: public final void bytesPerSecond(long j)
  void bytesPerSecond2(
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_bytesPerSecond2, jni.JniCallType.voidType, [j]).check();
  }
}

final class $ThrottlerType extends jni.JObjType<Throttler> {
  const $ThrottlerType();

  @override
  String get signature => r"Lokio/Throttler;";

  @override
  Throttler fromRef(jni.JObjectPtr ref) => Throttler.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ThrottlerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ThrottlerType) && other is $ThrottlerType;
  }
}

/// from: okio.Timeout$Companion
class Timeout_Companion extends jni.JObject {
  @override
  late final jni.JObjType<Timeout_Companion> $type = type;

  Timeout_Companion.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Timeout$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $Timeout_CompanionType();
  static final _id_minTimeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"minTimeout", r"(JJ)J");

  /// from: public final long minTimeout(long j, long j1)
  int minTimeout(
    int j,
    int j1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_minTimeout, jni.JniCallType.longType, [j, j1]).long;
  }

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory Timeout_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return Timeout_Companion.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [defaultConstructorMarker.reference]).object);
  }
}

final class $Timeout_CompanionType extends jni.JObjType<Timeout_Companion> {
  const $Timeout_CompanionType();

  @override
  String get signature => r"Lokio/Timeout$Companion;";

  @override
  Timeout_Companion fromRef(jni.JObjectPtr ref) =>
      Timeout_Companion.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Timeout_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Timeout_CompanionType) &&
        other is $Timeout_CompanionType;
  }
}

/// from: okio.Timeout
class Timeout extends jni.JObject {
  @override
  late final jni.JObjType<Timeout> $type = type;

  Timeout.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Timeout");

  /// The type which includes information such as the signature of this class.
  static const type = $TimeoutType();
  static final _id_Companion = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Companion",
    r"Lokio/Timeout$Companion;",
  );

  /// from: static public final okio.Timeout$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static Timeout_Companion get Companion =>
      const $Timeout_CompanionType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_Companion, jni.JniCallType.objectType)
          .object);

  static final _id_NONE = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"NONE",
    r"Lokio/Timeout;",
  );

  /// from: static public final okio.Timeout NONE
  /// The returned object must be released after use, by calling the [release] method.
  static Timeout get NONE => const $TimeoutType().fromRef(jni.Jni.accessors
      .getStaticField(_class.reference, _id_NONE, jni.JniCallType.objectType)
      .object);

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Timeout() {
    return Timeout.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_timeout = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"timeout", r"(JLjava/util/concurrent/TimeUnit;)Lokio/Timeout;");

  /// from: public okio.Timeout timeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_timeout,
        jni.JniCallType.objectType,
        [j, timeUnit.reference]).object);
  }

  static final _id_timeoutNanos = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeoutNanos", r"()J");

  /// from: public long timeoutNanos()
  int timeoutNanos() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeoutNanos, jni.JniCallType.longType, []).long;
  }

  static final _id_hasDeadline =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"hasDeadline", r"()Z");

  /// from: public boolean hasDeadline()
  bool hasDeadline() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hasDeadline, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_deadlineNanoTime = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"deadlineNanoTime", r"()J");

  /// from: public long deadlineNanoTime()
  int deadlineNanoTime() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_deadlineNanoTime, jni.JniCallType.longType, []).long;
  }

  static final _id_deadlineNanoTime1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"deadlineNanoTime", r"(J)Lokio/Timeout;");

  /// from: public okio.Timeout deadlineNanoTime(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Timeout deadlineNanoTime1(
    int j,
  ) {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_deadlineNanoTime1,
        jni.JniCallType.objectType,
        [j]).object);
  }

  static final _id_deadline = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"deadline", r"(JLjava/util/concurrent/TimeUnit;)Lokio/Timeout;");

  /// from: public final okio.Timeout deadline(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  Timeout deadline(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_deadline,
        jni.JniCallType.objectType,
        [j, timeUnit.reference]).object);
  }

  static final _id_clearTimeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clearTimeout", r"()Lokio/Timeout;");

  /// from: public okio.Timeout clearTimeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout clearTimeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clearTimeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_clearDeadline = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clearDeadline", r"()Lokio/Timeout;");

  /// from: public okio.Timeout clearDeadline()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout clearDeadline() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clearDeadline, jni.JniCallType.objectType, []).object);
  }

  static final _id_throwIfReached = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"throwIfReached", r"()V");

  /// from: public void throwIfReached()
  void throwIfReached() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_throwIfReached, jni.JniCallType.voidType, []).check();
  }

  static final _id_awaitSignal = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"awaitSignal",
      r"(Ljava/util/concurrent/locks/Condition;)V");

  /// from: public final void awaitSignal(java.util.concurrent.locks.Condition condition)
  void awaitSignal(
    jni.JObject condition,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_awaitSignal,
        jni.JniCallType.voidType, [condition.reference]).check();
  }

  static final _id_waitUntilNotified = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"waitUntilNotified", r"(Ljava/lang/Object;)V");

  /// from: public final void waitUntilNotified(java.lang.Object object)
  void waitUntilNotified(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_waitUntilNotified,
        jni.JniCallType.voidType,
        [object.reference]).check();
  }

  static final _id_intersectWith = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"intersectWith",
      r"(Lokio/Timeout;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;");

  /// from: public final T intersectWith(okio.Timeout timeout, kotlin.jvm.functions.Function0 function0)
  /// The returned object must be released after use, by calling the [release] method.
  $T intersectWith<$T extends jni.JObject>(
    Timeout timeout,
    jni.JObject function0, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_intersectWith,
        jni.JniCallType.objectType,
        [timeout.reference, function0.reference]).object);
  }
}

final class $TimeoutType extends jni.JObjType<Timeout> {
  const $TimeoutType();

  @override
  String get signature => r"Lokio/Timeout;";

  @override
  Timeout fromRef(jni.JObjectPtr ref) => Timeout.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($TimeoutType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($TimeoutType) && other is $TimeoutType;
  }
}

/// from: okio.Utf8
class Utf8 extends jni.JObject {
  @override
  late final jni.JObjType<Utf8> $type = type;

  Utf8.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/Utf8");

  /// The type which includes information such as the signature of this class.
  static const type = $Utf8Type();

  /// from: static public final byte REPLACEMENT_BYTE
  static const REPLACEMENT_BYTE = 63;

  /// from: static public final char REPLACEMENT_CHARACTER
  static const REPLACEMENT_CHARACTER = 65533;

  /// from: static public final int REPLACEMENT_CODE_POINT
  static const REPLACEMENT_CODE_POINT = 65533;

  /// from: static public final int HIGH_SURROGATE_HEADER
  static const HIGH_SURROGATE_HEADER = 55232;

  /// from: static public final int LOG_SURROGATE_HEADER
  static const LOG_SURROGATE_HEADER = 56320;

  /// from: static public final int MASK_2BYTES
  static const MASK_2BYTES = 3968;

  /// from: static public final int MASK_3BYTES
  static const MASK_3BYTES = -123008;

  /// from: static public final int MASK_4BYTES
  static const MASK_4BYTES = 3678080;
  static final _id_size = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"size", r"(Ljava/lang/String;II)J");

  /// from: static public final long size(java.lang.String string, int i, int i1)
  static int size(
    jni.JString string,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_size,
        jni.JniCallType.longType,
        [string.reference, jni.JValueInt(i), jni.JValueInt(i1)]).long;
  }

  static final _id_isIsoControl = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"isIsoControl", r"(I)Z");

  /// from: static public final boolean isIsoControl(int i)
  static bool isIsoControl(
    int i,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_isIsoControl,
        jni.JniCallType.booleanType,
        [jni.JValueInt(i)]).boolean;
  }

  static final _id_isUtf8Continuation = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"isUtf8Continuation", r"(B)Z");

  /// from: static public final boolean isUtf8Continuation(byte b)
  static bool isUtf8Continuation(
    int b,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_isUtf8Continuation,
        jni.JniCallType.booleanType,
        [jni.JValueByte(b)]).boolean;
  }

  static final _id_processUtf8Bytes = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"processUtf8Bytes",
      r"(Ljava/lang/String;IILkotlin/jvm/functions/Function1;)V");

  /// from: static public final void processUtf8Bytes(java.lang.String string, int i, int i1, kotlin.jvm.functions.Function1 function1)
  static void processUtf8Bytes(
    jni.JString string,
    int i,
    int i1,
    jni.JObject function1,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference, _id_processUtf8Bytes, jni.JniCallType.voidType, [
      string.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      function1.reference
    ]).check();
  }

  static final _id_processUtf8CodePoints = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"processUtf8CodePoints",
          r"([BIILkotlin/jvm/functions/Function1;)V");

  /// from: static public final void processUtf8CodePoints(java.lang.Object[] bs, int i, int i1, kotlin.jvm.functions.Function1 function1)
  static void processUtf8CodePoints(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
    jni.JObject function1,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference, _id_processUtf8CodePoints, jni.JniCallType.voidType, [
      bs.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      function1.reference
    ]).check();
  }

  static final _id_processUtf16Chars = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"processUtf16Chars",
      r"([BIILkotlin/jvm/functions/Function1;)V");

  /// from: static public final void processUtf16Chars(java.lang.Object[] bs, int i, int i1, kotlin.jvm.functions.Function1 function1)
  static void processUtf16Chars(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
    jni.JObject function1,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference, _id_processUtf16Chars, jni.JniCallType.voidType, [
      bs.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      function1.reference
    ]).check();
  }

  static final _id_process2Utf8Bytes = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"process2Utf8Bytes",
      r"([BIILkotlin/jvm/functions/Function1;)I");

  /// from: static public final int process2Utf8Bytes(java.lang.Object[] bs, int i, int i1, kotlin.jvm.functions.Function1 function1)
  static int process2Utf8Bytes(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
    jni.JObject function1,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference, _id_process2Utf8Bytes, jni.JniCallType.intType, [
      bs.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      function1.reference
    ]).integer;
  }

  static final _id_process3Utf8Bytes = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"process3Utf8Bytes",
      r"([BIILkotlin/jvm/functions/Function1;)I");

  /// from: static public final int process3Utf8Bytes(java.lang.Object[] bs, int i, int i1, kotlin.jvm.functions.Function1 function1)
  static int process3Utf8Bytes(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
    jni.JObject function1,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference, _id_process3Utf8Bytes, jni.JniCallType.intType, [
      bs.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      function1.reference
    ]).integer;
  }

  static final _id_process4Utf8Bytes = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"process4Utf8Bytes",
      r"([BIILkotlin/jvm/functions/Function1;)I");

  /// from: static public final int process4Utf8Bytes(java.lang.Object[] bs, int i, int i1, kotlin.jvm.functions.Function1 function1)
  static int process4Utf8Bytes(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
    jni.JObject function1,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference, _id_process4Utf8Bytes, jni.JniCallType.intType, [
      bs.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1),
      function1.reference
    ]).integer;
  }

  static final _id_size1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"size", r"(Ljava/lang/String;I)J");

  /// from: static public final long size(java.lang.String string, int i)
  static int size1(
    jni.JString string,
    int i,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_size1,
        jni.JniCallType.longType,
        [string.reference, jni.JValueInt(i)]).long;
  }

  static final _id_size2 = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"size", r"(Ljava/lang/String;)J");

  /// from: static public final long size(java.lang.String string)
  static int size2(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_size2, jni.JniCallType.longType, [string.reference]).long;
  }
}

final class $Utf8Type extends jni.JObjType<Utf8> {
  const $Utf8Type();

  @override
  String get signature => r"Lokio/Utf8;";

  @override
  Utf8 fromRef(jni.JObjectPtr ref) => Utf8.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Utf8Type).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Utf8Type) && other is $Utf8Type;
  }
}

/// from: okio.ZipFileSystem
class ZipFileSystem extends FileSystem {
  @override
  late final jni.JObjType<ZipFileSystem> $type = type;

  ZipFileSystem.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/ZipFileSystem");

  /// The type which includes information such as the signature of this class.
  static const type = $ZipFileSystemType();
  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(Lokio/Path;Lokio/FileSystem;Ljava/util/Map;Ljava/lang/String;)V");

  /// from: public void <init>(okio.Path path, okio.FileSystem fileSystem, java.util.Map map, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  factory ZipFileSystem.new1(
    Path path,
    FileSystem fileSystem,
    jni.JMap<Path, ZipEntry> map,
    jni.JString string,
  ) {
    return ZipFileSystem.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new1, [
      path.reference,
      fileSystem.reference,
      map.reference,
      string.reference
    ]).object);
  }

  static final _id_canonicalize = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"canonicalize", r"(Lokio/Path;)Lokio/Path;");

  /// from: public okio.Path canonicalize(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Path canonicalize(
    Path path,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_canonicalize,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_metadataOrNull = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"metadataOrNull", r"(Lokio/Path;)Lokio/FileMetadata;");

  /// from: public okio.FileMetadata metadataOrNull(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileMetadata metadataOrNull(
    Path path,
  ) {
    return const $FileMetadataType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_metadataOrNull,
            jni.JniCallType.objectType, [path.reference]).object);
  }

  static final _id_openReadOnly = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"openReadOnly", r"(Lokio/Path;)Lokio/FileHandle;");

  /// from: public okio.FileHandle openReadOnly(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileHandle openReadOnly(
    Path path,
  ) {
    return const $FileHandleType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openReadOnly,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_openReadWrite = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"openReadWrite", r"(Lokio/Path;ZZ)Lokio/FileHandle;");

  /// from: public okio.FileHandle openReadWrite(okio.Path path, boolean z, boolean z1)
  /// The returned object must be released after use, by calling the [release] method.
  FileHandle openReadWrite(
    Path path,
    bool z,
    bool z1,
  ) {
    return const $FileHandleType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openReadWrite,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0, z1 ? 1 : 0]).object);
  }

  static final _id_list = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"list", r"(Lokio/Path;)Ljava/util/List;");

  /// from: public java.util.List list(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Path> list(
    Path path,
  ) {
    return const jni.JListType($PathType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_list, jni.JniCallType.objectType,
            [path.reference]).object);
  }

  static final _id_listOrNull = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"listOrNull", r"(Lokio/Path;)Ljava/util/List;");

  /// from: public java.util.List listOrNull(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Path> listOrNull(
    Path path,
  ) {
    return const jni.JListType($PathType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_listOrNull,
            jni.JniCallType.objectType, [path.reference]).object);
  }

  static final _id_source = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"source", r"(Lokio/Path;)Lokio/Source;");

  /// from: public okio.Source source(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Source source(
    Path path,
  ) {
    return const $SourceType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_source,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_sink = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sink", r"(Lokio/Path;Z)Lokio/Sink;");

  /// from: public okio.Sink sink(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Sink sink(
    Path path,
    bool z,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sink,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_appendingSink = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"appendingSink", r"(Lokio/Path;Z)Lokio/Sink;");

  /// from: public okio.Sink appendingSink(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Sink appendingSink(
    Path path,
    bool z,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_appendingSink,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_createDirectory = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"createDirectory", r"(Lokio/Path;Z)V");

  /// from: public void createDirectory(okio.Path path, boolean z)
  void createDirectory(
    Path path,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_createDirectory,
        jni.JniCallType.voidType, [path.reference, z ? 1 : 0]).check();
  }

  static final _id_atomicMove = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"atomicMove", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public void atomicMove(okio.Path path, okio.Path path1)
  void atomicMove(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_atomicMove,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }

  static final _id_delete = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"delete", r"(Lokio/Path;Z)V");

  /// from: public void delete(okio.Path path, boolean z)
  void delete(
    Path path,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_delete,
        jni.JniCallType.voidType, [path.reference, z ? 1 : 0]).check();
  }

  static final _id_createSymlink = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"createSymlink", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public void createSymlink(okio.Path path, okio.Path path1)
  void createSymlink(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_createSymlink,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }
}

final class $ZipFileSystemType extends jni.JObjType<ZipFileSystem> {
  const $ZipFileSystemType();

  @override
  String get signature => r"Lokio/ZipFileSystem;";

  @override
  ZipFileSystem fromRef(jni.JObjectPtr ref) => ZipFileSystem.fromRef(ref);

  @override
  jni.JObjType get superType => const $FileSystemType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($ZipFileSystemType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZipFileSystemType) &&
        other is $ZipFileSystemType;
  }
}

/// from: okio._JvmPlatformKt
class _JvmPlatformKt extends jni.JObject {
  @override
  late final jni.JObjType<_JvmPlatformKt> $type = type;

  _JvmPlatformKt.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/_JvmPlatformKt");

  /// The type which includes information such as the signature of this class.
  static const type = $_JvmPlatformKtType();
  static final _id_toUtf8String = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"toUtf8String", r"([B)Ljava/lang/String;");

  /// from: static public final java.lang.String toUtf8String(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString toUtf8String(
    jni.JArray<jni.jbyte> bs,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_toUtf8String,
            jni.JniCallType.objectType, [bs.reference]).object);
  }

  static final _id_asUtf8ToByteArray = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"asUtf8ToByteArray", r"(Ljava/lang/String;)[B");

  /// from: static public final byte[] asUtf8ToByteArray(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jbyte> asUtf8ToByteArray(
    jni.JString string,
  ) {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_asUtf8ToByteArray,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_newLock = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"newLock",
      r"()Ljava/util/concurrent/locks/ReentrantLock;");

  /// from: static public final java.util.concurrent.locks.ReentrantLock newLock()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newLock() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_newLock,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_withLock = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"withLock",
      r"(Ljava/util/concurrent/locks/ReentrantLock;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;");

  /// from: static public final T withLock(java.util.concurrent.locks.ReentrantLock reentrantLock, kotlin.jvm.functions.Function0 function0)
  /// The returned object must be released after use, by calling the [release] method.
  static $T withLock<$T extends jni.JObject>(
    jni.JObject reentrantLock,
    jni.JObject function0, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_withLock,
        jni.JniCallType.objectType,
        [reentrantLock.reference, function0.reference]).object);
  }
}

final class $_JvmPlatformKtType extends jni.JObjType<_JvmPlatformKt> {
  const $_JvmPlatformKtType();

  @override
  String get signature => r"Lokio/_JvmPlatformKt;";

  @override
  _JvmPlatformKt fromRef(jni.JObjectPtr ref) => _JvmPlatformKt.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($_JvmPlatformKtType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($_JvmPlatformKtType) &&
        other is $_JvmPlatformKtType;
  }
}

/// from: okio.internal.FixedLengthSource
class FixedLengthSource extends ForwardingSource {
  @override
  late final jni.JObjType<FixedLengthSource> $type = type;

  FixedLengthSource.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/internal/FixedLengthSource");

  /// The type which includes information such as the signature of this class.
  static const type = $FixedLengthSourceType();
  static final _id_new1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Lokio/Source;JZ)V");

  /// from: public void <init>(okio.Source source, long j, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  factory FixedLengthSource.new1(
    Source source,
    int j,
    bool z,
  ) {
    return FixedLengthSource.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new1, [source.reference, j, z ? 1 : 0]).object);
  }

  static final _id_read = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"read", r"(Lokio/Buffer;J)J");

  /// from: public long read(okio.Buffer buffer, long j)
  int read(
    Buffer buffer,
    int j,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_read,
        jni.JniCallType.longType, [buffer.reference, j]).long;
  }
}

final class $FixedLengthSourceType extends jni.JObjType<FixedLengthSource> {
  const $FixedLengthSourceType();

  @override
  String get signature => r"Lokio/internal/FixedLengthSource;";

  @override
  FixedLengthSource fromRef(jni.JObjectPtr ref) =>
      FixedLengthSource.fromRef(ref);

  @override
  jni.JObjType get superType => const $ForwardingSourceType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($FixedLengthSourceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FixedLengthSourceType) &&
        other is $FixedLengthSourceType;
  }
}

/// from: okio.internal.ResourceFileSystem
class ResourceFileSystem extends FileSystem {
  @override
  late final jni.JObjType<ResourceFileSystem> $type = type;

  ResourceFileSystem.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/internal/ResourceFileSystem");

  /// The type which includes information such as the signature of this class.
  static const type = $ResourceFileSystemType();
  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Ljava/lang/ClassLoader;ZLokio/FileSystem;)V");

  /// from: public void <init>(java.lang.ClassLoader classLoader, boolean z, okio.FileSystem fileSystem)
  /// The returned object must be released after use, by calling the [release] method.
  factory ResourceFileSystem.new1(
    jni.JObject classLoader,
    bool z,
    FileSystem fileSystem,
  ) {
    return ResourceFileSystem.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new1,
        [classLoader.reference, z ? 1 : 0, fileSystem.reference]).object);
  }

  static final _id_new2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(Ljava/lang/ClassLoader;ZLokio/FileSystem;ILkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(java.lang.ClassLoader classLoader, boolean z, okio.FileSystem fileSystem, int i, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory ResourceFileSystem.new2(
    jni.JObject classLoader,
    bool z,
    FileSystem fileSystem,
    int i,
    jni.JObject defaultConstructorMarker,
  ) {
    return ResourceFileSystem.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new2, [
      classLoader.reference,
      z ? 1 : 0,
      fileSystem.reference,
      jni.JValueInt(i),
      defaultConstructorMarker.reference
    ]).object);
  }

  static final _id_canonicalize = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"canonicalize", r"(Lokio/Path;)Lokio/Path;");

  /// from: public okio.Path canonicalize(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Path canonicalize(
    Path path,
  ) {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_canonicalize,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_list = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"list", r"(Lokio/Path;)Ljava/util/List;");

  /// from: public java.util.List list(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Path> list(
    Path path,
  ) {
    return const jni.JListType($PathType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_list, jni.JniCallType.objectType,
            [path.reference]).object);
  }

  static final _id_listOrNull = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"listOrNull", r"(Lokio/Path;)Ljava/util/List;");

  /// from: public java.util.List listOrNull(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Path> listOrNull(
    Path path,
  ) {
    return const jni.JListType($PathType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_listOrNull,
            jni.JniCallType.objectType, [path.reference]).object);
  }

  static final _id_openReadOnly = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"openReadOnly", r"(Lokio/Path;)Lokio/FileHandle;");

  /// from: public okio.FileHandle openReadOnly(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileHandle openReadOnly(
    Path path,
  ) {
    return const $FileHandleType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openReadOnly,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_openReadWrite = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"openReadWrite", r"(Lokio/Path;ZZ)Lokio/FileHandle;");

  /// from: public okio.FileHandle openReadWrite(okio.Path path, boolean z, boolean z1)
  /// The returned object must be released after use, by calling the [release] method.
  FileHandle openReadWrite(
    Path path,
    bool z,
    bool z1,
  ) {
    return const $FileHandleType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openReadWrite,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0, z1 ? 1 : 0]).object);
  }

  static final _id_metadataOrNull = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"metadataOrNull", r"(Lokio/Path;)Lokio/FileMetadata;");

  /// from: public okio.FileMetadata metadataOrNull(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  FileMetadata metadataOrNull(
    Path path,
  ) {
    return const $FileMetadataType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_metadataOrNull,
            jni.JniCallType.objectType, [path.reference]).object);
  }

  static final _id_source = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"source", r"(Lokio/Path;)Lokio/Source;");

  /// from: public okio.Source source(okio.Path path)
  /// The returned object must be released after use, by calling the [release] method.
  Source source(
    Path path,
  ) {
    return const $SourceType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_source,
        jni.JniCallType.objectType,
        [path.reference]).object);
  }

  static final _id_sink = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sink", r"(Lokio/Path;Z)Lokio/Sink;");

  /// from: public okio.Sink sink(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Sink sink(
    Path path,
    bool z,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sink,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_appendingSink = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"appendingSink", r"(Lokio/Path;Z)Lokio/Sink;");

  /// from: public okio.Sink appendingSink(okio.Path path, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Sink appendingSink(
    Path path,
    bool z,
  ) {
    return const $SinkType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_appendingSink,
        jni.JniCallType.objectType,
        [path.reference, z ? 1 : 0]).object);
  }

  static final _id_createDirectory = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"createDirectory", r"(Lokio/Path;Z)V");

  /// from: public void createDirectory(okio.Path path, boolean z)
  void createDirectory(
    Path path,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_createDirectory,
        jni.JniCallType.voidType, [path.reference, z ? 1 : 0]).check();
  }

  static final _id_atomicMove = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"atomicMove", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public void atomicMove(okio.Path path, okio.Path path1)
  void atomicMove(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_atomicMove,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }

  static final _id_delete = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"delete", r"(Lokio/Path;Z)V");

  /// from: public void delete(okio.Path path, boolean z)
  void delete(
    Path path,
    bool z,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_delete,
        jni.JniCallType.voidType, [path.reference, z ? 1 : 0]).check();
  }

  static final _id_createSymlink = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"createSymlink", r"(Lokio/Path;Lokio/Path;)V");

  /// from: public void createSymlink(okio.Path path, okio.Path path1)
  void createSymlink(
    Path path,
    Path path1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_createSymlink,
        jni.JniCallType.voidType, [path.reference, path1.reference]).check();
  }
}

final class $ResourceFileSystemType extends jni.JObjType<ResourceFileSystem> {
  const $ResourceFileSystemType();

  @override
  String get signature => r"Lokio/internal/ResourceFileSystem;";

  @override
  ResourceFileSystem fromRef(jni.JObjectPtr ref) =>
      ResourceFileSystem.fromRef(ref);

  @override
  jni.JObjType get superType => const $FileSystemType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($ResourceFileSystemType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResourceFileSystemType) &&
        other is $ResourceFileSystemType;
  }
}

/// from: okio.internal.ZipEntry
class ZipEntry extends jni.JObject {
  @override
  late final jni.JObjType<ZipEntry> $type = type;

  ZipEntry.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/internal/ZipEntry");

  /// The type which includes information such as the signature of this class.
  static const type = $ZipEntryType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lokio/Path;ZLjava/lang/String;JJJILjava/lang/Long;J)V");

  /// from: public void <init>(okio.Path path, boolean z, java.lang.String string, long j, long j1, long j2, int i, java.lang.Long long, long j3)
  /// The returned object must be released after use, by calling the [release] method.
  factory ZipEntry(
    Path path,
    bool z,
    jni.JString string,
    int j,
    int j1,
    int j2,
    int i,
    jni.JLong long,
    int j3,
  ) {
    return ZipEntry.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new0, [
      path.reference,
      z ? 1 : 0,
      string.reference,
      j,
      j1,
      j2,
      jni.JValueInt(i),
      long.reference,
      j3
    ]).object);
  }

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(Lokio/Path;ZLjava/lang/String;JJJILjava/lang/Long;JILkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(okio.Path path, boolean z, java.lang.String string, long j, long j1, long j2, int i, java.lang.Long long, long j3, int i1, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory ZipEntry.new1(
    Path path,
    bool z,
    jni.JString string,
    int j,
    int j1,
    int j2,
    int i,
    jni.JLong long,
    int j3,
    int i1,
    jni.JObject defaultConstructorMarker,
  ) {
    return ZipEntry.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new1, [
      path.reference,
      z ? 1 : 0,
      string.reference,
      j,
      j1,
      j2,
      jni.JValueInt(i),
      long.reference,
      j3,
      jni.JValueInt(i1),
      defaultConstructorMarker.reference
    ]).object);
  }

  static final _id_getCanonicalPath = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getCanonicalPath", r"()Lokio/Path;");

  /// from: public final okio.Path getCanonicalPath()
  /// The returned object must be released after use, by calling the [release] method.
  Path getCanonicalPath() {
    return const $PathType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getCanonicalPath,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_isDirectory =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isDirectory", r"()Z");

  /// from: public final boolean isDirectory()
  bool isDirectory() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isDirectory, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_getComment = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getComment", r"()Ljava/lang/String;");

  /// from: public final java.lang.String getComment()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getComment() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getComment, jni.JniCallType.objectType, []).object);
  }

  static final _id_getCrc =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getCrc", r"()J");

  /// from: public final long getCrc()
  int getCrc() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getCrc, jni.JniCallType.longType, []).long;
  }

  static final _id_getCompressedSize = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getCompressedSize", r"()J");

  /// from: public final long getCompressedSize()
  int getCompressedSize() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getCompressedSize, jni.JniCallType.longType, []).long;
  }

  static final _id_getSize =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getSize", r"()J");

  /// from: public final long getSize()
  int getSize() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getSize, jni.JniCallType.longType, []).long;
  }

  static final _id_getCompressionMethod = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getCompressionMethod", r"()I");

  /// from: public final int getCompressionMethod()
  int getCompressionMethod() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getCompressionMethod, jni.JniCallType.intType, []).integer;
  }

  static final _id_getLastModifiedAtMillis = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getLastModifiedAtMillis", r"()Ljava/lang/Long;");

  /// from: public final java.lang.Long getLastModifiedAtMillis()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JLong getLastModifiedAtMillis() {
    return const jni.JLongType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getLastModifiedAtMillis,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getOffset =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getOffset", r"()J");

  /// from: public final long getOffset()
  int getOffset() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getOffset, jni.JniCallType.longType, []).long;
  }

  static final _id_getChildren = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getChildren", r"()Ljava/util/List;");

  /// from: public final java.util.List getChildren()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Path> getChildren() {
    return const jni.JListType($PathType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_getChildren, jni.JniCallType.objectType, []).object);
  }
}

final class $ZipEntryType extends jni.JObjType<ZipEntry> {
  const $ZipEntryType();

  @override
  String get signature => r"Lokio/internal/ZipEntry;";

  @override
  ZipEntry fromRef(jni.JObjectPtr ref) => ZipEntry.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ZipEntryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZipEntryType) && other is $ZipEntryType;
  }
}

/// from: okio.internal.ZipFilesKt
class ZipFilesKt extends jni.JObject {
  @override
  late final jni.JObjType<ZipFilesKt> $type = type;

  ZipFilesKt.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/internal/ZipFilesKt");

  /// The type which includes information such as the signature of this class.
  static const type = $ZipFilesKtType();

  /// from: static public final int COMPRESSION_METHOD_DEFLATED
  static const COMPRESSION_METHOD_DEFLATED = 8;

  /// from: static public final int COMPRESSION_METHOD_STORED
  static const COMPRESSION_METHOD_STORED = 0;
  static final _id_openZip = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"openZip",
      r"(Lokio/Path;Lokio/FileSystem;Lkotlin/jvm/functions/Function1;)Lokio/ZipFileSystem;");

  /// from: static public final okio.ZipFileSystem openZip(okio.Path path, okio.FileSystem fileSystem, kotlin.jvm.functions.Function1 function1)
  /// The returned object must be released after use, by calling the [release] method.
  static ZipFileSystem openZip(
    Path path,
    FileSystem fileSystem,
    jni.JObject function1,
  ) {
    return const $ZipFileSystemType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference, _id_openZip, jni.JniCallType.objectType, [
      path.reference,
      fileSystem.reference,
      function1.reference
    ]).object);
  }

  static final _id_readEntry = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"readEntry",
      r"(Lokio/BufferedSource;)Lokio/internal/ZipEntry;");

  /// from: static public final okio.internal.ZipEntry readEntry(okio.BufferedSource bufferedSource)
  /// The returned object must be released after use, by calling the [release] method.
  static ZipEntry readEntry(
    BufferedSource bufferedSource,
  ) {
    return const $ZipEntryType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_readEntry,
            jni.JniCallType.objectType, [bufferedSource.reference]).object);
  }

  static final _id_skipLocalHeader = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"skipLocalHeader", r"(Lokio/BufferedSource;)V");

  /// from: static public final void skipLocalHeader(okio.BufferedSource bufferedSource)
  static void skipLocalHeader(
    BufferedSource bufferedSource,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_skipLocalHeader,
        jni.JniCallType.voidType,
        [bufferedSource.reference]).check();
  }

  static final _id_readLocalHeader = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"readLocalHeader",
      r"(Lokio/BufferedSource;Lokio/FileMetadata;)Lokio/FileMetadata;");

  /// from: static public final okio.FileMetadata readLocalHeader(okio.BufferedSource bufferedSource, okio.FileMetadata fileMetadata)
  /// The returned object must be released after use, by calling the [release] method.
  static FileMetadata readLocalHeader(
    BufferedSource bufferedSource,
    FileMetadata fileMetadata,
  ) {
    return const $FileMetadataType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_readLocalHeader,
            jni.JniCallType.objectType,
            [bufferedSource.reference, fileMetadata.reference]).object);
  }
}

final class $ZipFilesKtType extends jni.JObjType<ZipFilesKt> {
  const $ZipFilesKtType();

  @override
  String get signature => r"Lokio/internal/ZipFilesKt;";

  @override
  ZipFilesKt fromRef(jni.JObjectPtr ref) => ZipFilesKt.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ZipFilesKtType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZipFilesKtType) && other is $ZipFilesKtType;
  }
}

/// from: okio.internal._Utf8Kt
class _Utf8Kt extends jni.JObject {
  @override
  late final jni.JObjType<_Utf8Kt> $type = type;

  _Utf8Kt.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okio/internal/_Utf8Kt");

  /// The type which includes information such as the signature of this class.
  static const type = $_Utf8KtType();
  static final _id_commonToUtf8String = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"commonToUtf8String", r"([BII)Ljava/lang/String;");

  /// from: static public final java.lang.String commonToUtf8String(byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString commonToUtf8String(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_commonToUtf8String,
            jni.JniCallType.objectType,
            [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);
  }

  static final _id_commonAsUtf8ToByteArray = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"commonAsUtf8ToByteArray",
          r"(Ljava/lang/String;)[B");

  /// from: static public final byte[] commonAsUtf8ToByteArray(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jbyte> commonAsUtf8ToByteArray(
    jni.JString string,
  ) {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_commonAsUtf8ToByteArray,
            jni.JniCallType.objectType, [string.reference]).object);
  }
}

final class $_Utf8KtType extends jni.JObjType<_Utf8Kt> {
  const $_Utf8KtType();

  @override
  String get signature => r"Lokio/internal/_Utf8Kt;";

  @override
  _Utf8Kt fromRef(jni.JObjectPtr ref) => _Utf8Kt.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($_Utf8KtType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($_Utf8KtType) && other is $_Utf8KtType;
  }
}

/// from: okhttp3.OkHttpClient$Builder
class OkHttpClient_Builder extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient_Builder> $type = type;

  OkHttpClient_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/OkHttpClient$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClient_BuilderType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient_Builder() {
    return OkHttpClient_Builder.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_new1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Lokhttp3/OkHttpClient;)V");

  /// from: public void <init>(okhttp3.OkHttpClient okHttpClient)
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient_Builder.new1(
    OkHttpClient okHttpClient,
  ) {
    return OkHttpClient_Builder.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new1, [okHttpClient.reference]).object);
  }

  static final _id_dispatcher = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"dispatcher",
      r"(Lokhttp3/Dispatcher;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder dispatcher(okhttp3.Dispatcher dispatcher)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder dispatcher(
    jni.JObject dispatcher,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_dispatcher,
            jni.JniCallType.objectType, [dispatcher.reference]).object);
  }

  static final _id_connectionPool = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"connectionPool",
      r"(Lokhttp3/ConnectionPool;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder connectionPool(okhttp3.ConnectionPool connectionPool)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectionPool(
    jni.JObject connectionPool,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectionPool,
            jni.JniCallType.objectType, [connectionPool.reference]).object);
  }

  static final _id_interceptors = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"interceptors", r"()Ljava/util/List;");

  /// from: public final java.util.List interceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> interceptors() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_interceptors,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_addInterceptor = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addInterceptor",
      r"(Lokhttp3/Interceptor;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder addInterceptor(okhttp3.Interceptor interceptor)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addInterceptor(
    jni.JObject interceptor,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_addInterceptor,
            jni.JniCallType.objectType, [interceptor.reference]).object);
  }

  static final _id__addInterceptor = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-addInterceptor",
      r"(Lkotlin/jvm/functions/Function1;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder -addInterceptor(kotlin.jvm.functions.Function1 function1)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder _addInterceptor(
    jni.JObject function1,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id__addInterceptor,
            jni.JniCallType.objectType, [function1.reference]).object);
  }

  static final _id_networkInterceptors = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"networkInterceptors", r"()Ljava/util/List;");

  /// from: public final java.util.List networkInterceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> networkInterceptors() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_networkInterceptors,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_addNetworkInterceptor = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addNetworkInterceptor",
      r"(Lokhttp3/Interceptor;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder addNetworkInterceptor(okhttp3.Interceptor interceptor)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addNetworkInterceptor(
    jni.JObject interceptor,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_addNetworkInterceptor,
            jni.JniCallType.objectType, [interceptor.reference]).object);
  }

  static final _id__addNetworkInterceptor = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-addNetworkInterceptor",
      r"(Lkotlin/jvm/functions/Function1;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder -addNetworkInterceptor(kotlin.jvm.functions.Function1 function1)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder _addNetworkInterceptor(
    jni.JObject function1,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id__addNetworkInterceptor,
            jni.JniCallType.objectType, [function1.reference]).object);
  }

  static final _id_eventListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"eventListener",
      r"(Lokhttp3/EventListener;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder eventListener(okhttp3.EventListener eventListener)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder eventListener(
    jni.JObject eventListener,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_eventListener,
            jni.JniCallType.objectType, [eventListener.reference]).object);
  }

  static final _id_eventListenerFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"eventListenerFactory",
      r"(Lokhttp3/EventListener$Factory;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder eventListenerFactory(okhttp3.EventListener$Factory factory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder eventListenerFactory(
    jni.JObject factory0,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_eventListenerFactory,
            jni.JniCallType.objectType, [factory0.reference]).object);
  }

  static final _id_retryOnConnectionFailure = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"retryOnConnectionFailure",
      r"(Z)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder retryOnConnectionFailure(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder retryOnConnectionFailure(
    bool z,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_retryOnConnectionFailure,
            jni.JniCallType.objectType, [z ? 1 : 0]).object);
  }

  static final _id_authenticator = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"authenticator",
      r"(Lokhttp3/Authenticator;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder authenticator(okhttp3.Authenticator authenticator)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder authenticator(
    jni.JObject authenticator,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_authenticator,
            jni.JniCallType.objectType, [authenticator.reference]).object);
  }

  static final _id_followRedirects = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"followRedirects",
      r"(Z)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder followRedirects(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder followRedirects(
    bool z,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_followRedirects,
            jni.JniCallType.objectType, [z ? 1 : 0]).object);
  }

  static final _id_followSslRedirects = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"followSslRedirects",
      r"(Z)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder followSslRedirects(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder followSslRedirects(
    bool z,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_followSslRedirects,
            jni.JniCallType.objectType, [z ? 1 : 0]).object);
  }

  static final _id_cookieJar = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"cookieJar", r"(Lokhttp3/CookieJar;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder cookieJar(okhttp3.CookieJar cookieJar)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder cookieJar(
    jni.JObject cookieJar,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_cookieJar,
            jni.JniCallType.objectType, [cookieJar.reference]).object);
  }

  static final _id_cache = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"cache", r"(Lokhttp3/Cache;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder cache(okhttp3.Cache cache)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder cache(
    jni.JObject cache,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_cache, jni.JniCallType.objectType,
            [cache.reference]).object);
  }

  static final _id_dns = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"dns", r"(Lokhttp3/Dns;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder dns(okhttp3.Dns dns)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder dns(
    jni.JObject dns,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_dns, jni.JniCallType.objectType,
            [dns.reference]).object);
  }

  static final _id_proxy = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"proxy", r"(Ljava/net/Proxy;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder proxy(java.net.Proxy proxy)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxy(
    jni.JObject proxy,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_proxy, jni.JniCallType.objectType,
            [proxy.reference]).object);
  }

  static final _id_proxySelector = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"proxySelector",
      r"(Ljava/net/ProxySelector;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder proxySelector(java.net.ProxySelector proxySelector)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxySelector(
    jni.JObject proxySelector,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_proxySelector,
            jni.JniCallType.objectType, [proxySelector.reference]).object);
  }

  static final _id_proxyAuthenticator = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"proxyAuthenticator",
      r"(Lokhttp3/Authenticator;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder proxyAuthenticator(okhttp3.Authenticator authenticator)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxyAuthenticator(
    jni.JObject authenticator,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_proxyAuthenticator,
            jni.JniCallType.objectType, [authenticator.reference]).object);
  }

  static final _id_socketFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"socketFactory",
      r"(Ljavax/net/SocketFactory;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder socketFactory(javax.net.SocketFactory socketFactory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder socketFactory(
    jni.JObject socketFactory,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_socketFactory,
            jni.JniCallType.objectType, [socketFactory.reference]).object);
  }

  static final _id_sslSocketFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"sslSocketFactory",
      r"(Ljavax/net/ssl/SSLSocketFactory;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder sslSocketFactory(javax.net.ssl.SSLSocketFactory sSLSocketFactory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder sslSocketFactory(
    jni.JObject sSLSocketFactory,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_sslSocketFactory,
            jni.JniCallType.objectType, [sSLSocketFactory.reference]).object);
  }

  static final _id_sslSocketFactory1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"sslSocketFactory",
      r"(Ljavax/net/ssl/SSLSocketFactory;Ljavax/net/ssl/X509TrustManager;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder sslSocketFactory(javax.net.ssl.SSLSocketFactory sSLSocketFactory, javax.net.ssl.X509TrustManager x509TrustManager)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder sslSocketFactory1(
    jni.JObject sSLSocketFactory,
    jni.JObject x509TrustManager,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_sslSocketFactory1,
            jni.JniCallType.objectType,
            [sSLSocketFactory.reference, x509TrustManager.reference]).object);
  }

  static final _id_connectionSpecs = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"connectionSpecs",
      r"(Ljava/util/List;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder connectionSpecs(java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectionSpecs(
    jni.JList<jni.JObject> list,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectionSpecs,
            jni.JniCallType.objectType, [list.reference]).object);
  }

  static final _id_protocols = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"protocols", r"(Ljava/util/List;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder protocols(java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder protocols(
    jni.JList<jni.JObject> list,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_protocols,
            jni.JniCallType.objectType, [list.reference]).object);
  }

  static final _id_hostnameVerifier = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"hostnameVerifier",
      r"(Ljavax/net/ssl/HostnameVerifier;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder hostnameVerifier(javax.net.ssl.HostnameVerifier hostnameVerifier)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder hostnameVerifier(
    jni.JObject hostnameVerifier,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_hostnameVerifier,
            jni.JniCallType.objectType, [hostnameVerifier.reference]).object);
  }

  static final _id_certificatePinner = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"certificatePinner",
      r"(Lokhttp3/CertificatePinner;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder certificatePinner(okhttp3.CertificatePinner certificatePinner)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder certificatePinner(
    jni.JObject certificatePinner,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_certificatePinner,
            jni.JniCallType.objectType, [certificatePinner.reference]).object);
  }

  static final _id_callTimeout = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"callTimeout",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder callTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder callTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_callTimeout,
            jni.JniCallType.objectType, [j, timeUnit.reference]).object);
  }

  static final _id_callTimeout1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"callTimeout",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder callTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder callTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_callTimeout1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_connectTimeout = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"connectTimeout",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder connectTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectTimeout,
            jni.JniCallType.objectType, [j, timeUnit.reference]).object);
  }

  static final _id_connectTimeout1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"connectTimeout",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder connectTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectTimeout1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_readTimeout = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readTimeout",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder readTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder readTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readTimeout,
            jni.JniCallType.objectType, [j, timeUnit.reference]).object);
  }

  static final _id_readTimeout1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readTimeout",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder readTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder readTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readTimeout1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_writeTimeout = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeTimeout",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder writeTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder writeTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeTimeout,
            jni.JniCallType.objectType, [j, timeUnit.reference]).object);
  }

  static final _id_writeTimeout1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeTimeout",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder writeTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder writeTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeTimeout1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_pingInterval = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"pingInterval",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder pingInterval(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder pingInterval(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_pingInterval,
            jni.JniCallType.objectType, [j, timeUnit.reference]).object);
  }

  static final _id_pingInterval1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"pingInterval",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder pingInterval(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder pingInterval1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_pingInterval1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_minWebSocketMessageToCompress = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"minWebSocketMessageToCompress",
          r"(J)Lokhttp3/OkHttpClient$Builder;");

  /// from: public final okhttp3.OkHttpClient$Builder minWebSocketMessageToCompress(long j)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder minWebSocketMessageToCompress(
    int j,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_minWebSocketMessageToCompress,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_build = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"build", r"()Lokhttp3/OkHttpClient;");

  /// from: public final okhttp3.OkHttpClient build()
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient build() {
    return const $OkHttpClientType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_build, jni.JniCallType.objectType, []).object);
  }
}

final class $OkHttpClient_BuilderType
    extends jni.JObjType<OkHttpClient_Builder> {
  const $OkHttpClient_BuilderType();

  @override
  String get signature => r"Lokhttp3/OkHttpClient$Builder;";

  @override
  OkHttpClient_Builder fromRef(jni.JObjectPtr ref) =>
      OkHttpClient_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClient_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClient_BuilderType) &&
        other is $OkHttpClient_BuilderType;
  }
}

/// from: okhttp3.OkHttpClient$Companion
class OkHttpClient_Companion extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient_Companion> $type = type;

  OkHttpClient_Companion.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/OkHttpClient$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClient_CompanionType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return OkHttpClient_Companion.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [defaultConstructorMarker.reference]).object);
  }
}

final class $OkHttpClient_CompanionType
    extends jni.JObjType<OkHttpClient_Companion> {
  const $OkHttpClient_CompanionType();

  @override
  String get signature => r"Lokhttp3/OkHttpClient$Companion;";

  @override
  OkHttpClient_Companion fromRef(jni.JObjectPtr ref) =>
      OkHttpClient_Companion.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClient_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClient_CompanionType) &&
        other is $OkHttpClient_CompanionType;
  }
}

/// from: okhttp3.OkHttpClient
class OkHttpClient extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient> $type = type;

  OkHttpClient.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/OkHttpClient");

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClientType();
  static final _id_Companion = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Companion",
    r"Lokhttp3/OkHttpClient$Companion;",
  );

  /// from: static public final okhttp3.OkHttpClient$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static OkHttpClient_Companion get Companion =>
      const $OkHttpClient_CompanionType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_Companion, jni.JniCallType.objectType)
          .object);

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Lokhttp3/OkHttpClient$Builder;)V");

  /// from: public void <init>(okhttp3.OkHttpClient$Builder builder)
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient(
    OkHttpClient_Builder builder,
  ) {
    return OkHttpClient.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [builder.reference]).object);
  }

  static final _id_dispatcher = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"dispatcher", r"()Lokhttp3/Dispatcher;");

  /// from: public final okhttp3.Dispatcher dispatcher()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dispatcher() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_dispatcher, jni.JniCallType.objectType, []).object);
  }

  static final _id_connectionPool = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"connectionPool", r"()Lokhttp3/ConnectionPool;");

  /// from: public final okhttp3.ConnectionPool connectionPool()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject connectionPool() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_connectionPool, jni.JniCallType.objectType, []).object);
  }

  static final _id_interceptors = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"interceptors", r"()Ljava/util/List;");

  /// from: public final java.util.List interceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> interceptors() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_interceptors,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_networkInterceptors = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"networkInterceptors", r"()Ljava/util/List;");

  /// from: public final java.util.List networkInterceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> networkInterceptors() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_networkInterceptors,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_eventListenerFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"eventListenerFactory",
      r"()Lokhttp3/EventListener$Factory;");

  /// from: public final okhttp3.EventListener$Factory eventListenerFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject eventListenerFactory() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_eventListenerFactory,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_retryOnConnectionFailure = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"retryOnConnectionFailure", r"()Z");

  /// from: public final boolean retryOnConnectionFailure()
  bool retryOnConnectionFailure() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_retryOnConnectionFailure, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_authenticator = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"authenticator", r"()Lokhttp3/Authenticator;");

  /// from: public final okhttp3.Authenticator authenticator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject authenticator() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_authenticator, jni.JniCallType.objectType, []).object);
  }

  static final _id_followRedirects = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"followRedirects", r"()Z");

  /// from: public final boolean followRedirects()
  bool followRedirects() {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_followRedirects,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_followSslRedirects = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"followSslRedirects", r"()Z");

  /// from: public final boolean followSslRedirects()
  bool followSslRedirects() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_followSslRedirects, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_cookieJar = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"cookieJar", r"()Lokhttp3/CookieJar;");

  /// from: public final okhttp3.CookieJar cookieJar()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cookieJar() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cookieJar, jni.JniCallType.objectType, []).object);
  }

  static final _id_cache = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"cache", r"()Lokhttp3/Cache;");

  /// from: public final okhttp3.Cache cache()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cache() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cache, jni.JniCallType.objectType, []).object);
  }

  static final _id_dns = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dns", r"()Lokhttp3/Dns;");

  /// from: public final okhttp3.Dns dns()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dns() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_dns, jni.JniCallType.objectType, []).object);
  }

  static final _id_proxy = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"proxy", r"()Ljava/net/Proxy;");

  /// from: public final java.net.Proxy proxy()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxy() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_proxy, jni.JniCallType.objectType, []).object);
  }

  static final _id_proxySelector = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"proxySelector", r"()Ljava/net/ProxySelector;");

  /// from: public final java.net.ProxySelector proxySelector()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxySelector() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_proxySelector, jni.JniCallType.objectType, []).object);
  }

  static final _id_proxyAuthenticator = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"proxyAuthenticator", r"()Lokhttp3/Authenticator;");

  /// from: public final okhttp3.Authenticator proxyAuthenticator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxyAuthenticator() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_proxyAuthenticator,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_socketFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"socketFactory", r"()Ljavax/net/SocketFactory;");

  /// from: public final javax.net.SocketFactory socketFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject socketFactory() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_socketFactory, jni.JniCallType.objectType, []).object);
  }

  static final _id_sslSocketFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"sslSocketFactory",
      r"()Ljavax/net/ssl/SSLSocketFactory;");

  /// from: public final javax.net.ssl.SSLSocketFactory sslSocketFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject sslSocketFactory() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sslSocketFactory,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_x509TrustManager = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"x509TrustManager",
      r"()Ljavax/net/ssl/X509TrustManager;");

  /// from: public final javax.net.ssl.X509TrustManager x509TrustManager()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject x509TrustManager() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_x509TrustManager,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_connectionSpecs = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"connectionSpecs", r"()Ljava/util/List;");

  /// from: public final java.util.List connectionSpecs()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> connectionSpecs() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectionSpecs,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_protocols = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protocols", r"()Ljava/util/List;");

  /// from: public final java.util.List protocols()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> protocols() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_protocols, jni.JniCallType.objectType, []).object);
  }

  static final _id_hostnameVerifier = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"hostnameVerifier",
      r"()Ljavax/net/ssl/HostnameVerifier;");

  /// from: public final javax.net.ssl.HostnameVerifier hostnameVerifier()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject hostnameVerifier() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_hostnameVerifier,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_certificatePinner = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"certificatePinner", r"()Lokhttp3/CertificatePinner;");

  /// from: public final okhttp3.CertificatePinner certificatePinner()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject certificatePinner() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_certificatePinner,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_certificateChainCleaner = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"certificateChainCleaner",
      r"()Lokhttp3/internal/tls/CertificateChainCleaner;");

  /// from: public final okhttp3.internal.tls.CertificateChainCleaner certificateChainCleaner()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject certificateChainCleaner() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_certificateChainCleaner,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_callTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"callTimeoutMillis", r"()I");

  /// from: public final int callTimeoutMillis()
  int callTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_callTimeoutMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_connectTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"connectTimeoutMillis", r"()I");

  /// from: public final int connectTimeoutMillis()
  int connectTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_connectTimeoutMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_readTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readTimeoutMillis", r"()I");

  /// from: public final int readTimeoutMillis()
  int readTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readTimeoutMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_writeTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeTimeoutMillis", r"()I");

  /// from: public final int writeTimeoutMillis()
  int writeTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_writeTimeoutMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_pingIntervalMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"pingIntervalMillis", r"()I");

  /// from: public final int pingIntervalMillis()
  int pingIntervalMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_pingIntervalMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_minWebSocketMessageToCompress = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"minWebSocketMessageToCompress", r"()J");

  /// from: public final long minWebSocketMessageToCompress()
  int minWebSocketMessageToCompress() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_minWebSocketMessageToCompress, jni.JniCallType.longType, []).long;
  }

  static final _id_getRouteDatabase = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getRouteDatabase",
      r"()Lokhttp3/internal/connection/RouteDatabase;");

  /// from: public final okhttp3.internal.connection.RouteDatabase getRouteDatabase()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getRouteDatabase() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getRouteDatabase,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_new1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient.new1() {
    return OkHttpClient.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new1, []).object);
  }

  static final _id_newCall = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newCall", r"(Lokhttp3/Request;)Lokhttp3/Call;");

  /// from: public okhttp3.Call newCall(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Call newCall(
    Request request,
  ) {
    return const $CallType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_newCall,
        jni.JniCallType.objectType,
        [request.reference]).object);
  }

  static final _id_newWebSocket = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"newWebSocket",
      r"(Lokhttp3/Request;Lokhttp3/WebSocketListener;)Lokhttp3/WebSocket;");

  /// from: public okhttp3.WebSocket newWebSocket(okhttp3.Request request, okhttp3.WebSocketListener webSocketListener)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject newWebSocket(
    Request request,
    jni.JObject webSocketListener,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_newWebSocket,
        jni.JniCallType.objectType,
        [request.reference, webSocketListener.reference]).object);
  }

  static final _id_newBuilder = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newBuilder", r"()Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder newBuilder() {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_newBuilder, jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_dispatcher = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_dispatcher", r"()Lokhttp3/Dispatcher;");

  /// from: public final okhttp3.Dispatcher -deprecated_dispatcher()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_dispatcher() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_dispatcher,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_connectionPool = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_connectionPool",
      r"()Lokhttp3/ConnectionPool;");

  /// from: public final okhttp3.ConnectionPool -deprecated_connectionPool()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_connectionPool() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_connectionPool,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_interceptors = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_interceptors", r"()Ljava/util/List;");

  /// from: public final java.util.List -deprecated_interceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> _deprecated_interceptors() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id__deprecated_interceptors,
            jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_networkInterceptors = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_networkInterceptors",
          r"()Ljava/util/List;");

  /// from: public final java.util.List -deprecated_networkInterceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> _deprecated_networkInterceptors() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id__deprecated_networkInterceptors,
            jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_eventListenerFactory = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_eventListenerFactory",
          r"()Lokhttp3/EventListener$Factory;");

  /// from: public final okhttp3.EventListener$Factory -deprecated_eventListenerFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_eventListenerFactory() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_eventListenerFactory,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_retryOnConnectionFailure = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"-deprecated_retryOnConnectionFailure", r"()Z");

  /// from: public final boolean -deprecated_retryOnConnectionFailure()
  bool _deprecated_retryOnConnectionFailure() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_retryOnConnectionFailure,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id__deprecated_authenticator = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_authenticator",
      r"()Lokhttp3/Authenticator;");

  /// from: public final okhttp3.Authenticator -deprecated_authenticator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_authenticator() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_authenticator,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_followRedirects = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_followRedirects", r"()Z");

  /// from: public final boolean -deprecated_followRedirects()
  bool _deprecated_followRedirects() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_followRedirects,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id__deprecated_followSslRedirects = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"-deprecated_followSslRedirects", r"()Z");

  /// from: public final boolean -deprecated_followSslRedirects()
  bool _deprecated_followSslRedirects() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_followSslRedirects,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id__deprecated_cookieJar = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_cookieJar", r"()Lokhttp3/CookieJar;");

  /// from: public final okhttp3.CookieJar -deprecated_cookieJar()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_cookieJar() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_cookieJar,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_cache = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_cache", r"()Lokhttp3/Cache;");

  /// from: public final okhttp3.Cache -deprecated_cache()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_cache() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_cache,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_dns = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_dns", r"()Lokhttp3/Dns;");

  /// from: public final okhttp3.Dns -deprecated_dns()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_dns() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id__deprecated_dns, jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_proxy = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_proxy", r"()Ljava/net/Proxy;");

  /// from: public final java.net.Proxy -deprecated_proxy()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_proxy() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_proxy,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_proxySelector = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_proxySelector",
      r"()Ljava/net/ProxySelector;");

  /// from: public final java.net.ProxySelector -deprecated_proxySelector()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_proxySelector() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_proxySelector,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_proxyAuthenticator = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_proxyAuthenticator",
          r"()Lokhttp3/Authenticator;");

  /// from: public final okhttp3.Authenticator -deprecated_proxyAuthenticator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_proxyAuthenticator() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_proxyAuthenticator,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_socketFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_socketFactory",
      r"()Ljavax/net/SocketFactory;");

  /// from: public final javax.net.SocketFactory -deprecated_socketFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_socketFactory() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_socketFactory,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_sslSocketFactory = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_sslSocketFactory",
          r"()Ljavax/net/ssl/SSLSocketFactory;");

  /// from: public final javax.net.ssl.SSLSocketFactory -deprecated_sslSocketFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_sslSocketFactory() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_sslSocketFactory,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_connectionSpecs = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_connectionSpecs",
          r"()Ljava/util/List;");

  /// from: public final java.util.List -deprecated_connectionSpecs()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> _deprecated_connectionSpecs() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id__deprecated_connectionSpecs,
            jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_protocols = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_protocols", r"()Ljava/util/List;");

  /// from: public final java.util.List -deprecated_protocols()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> _deprecated_protocols() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id__deprecated_protocols,
            jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_hostnameVerifier = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_hostnameVerifier",
          r"()Ljavax/net/ssl/HostnameVerifier;");

  /// from: public final javax.net.ssl.HostnameVerifier -deprecated_hostnameVerifier()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_hostnameVerifier() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_hostnameVerifier,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_certificatePinner = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_certificatePinner",
          r"()Lokhttp3/CertificatePinner;");

  /// from: public final okhttp3.CertificatePinner -deprecated_certificatePinner()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_certificatePinner() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_certificatePinner,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_callTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"-deprecated_callTimeoutMillis", r"()I");

  /// from: public final int -deprecated_callTimeoutMillis()
  int _deprecated_callTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id__deprecated_callTimeoutMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id__deprecated_connectTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"-deprecated_connectTimeoutMillis", r"()I");

  /// from: public final int -deprecated_connectTimeoutMillis()
  int _deprecated_connectTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_connectTimeoutMillis,
        jni.JniCallType.intType, []).integer;
  }

  static final _id__deprecated_readTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"-deprecated_readTimeoutMillis", r"()I");

  /// from: public final int -deprecated_readTimeoutMillis()
  int _deprecated_readTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id__deprecated_readTimeoutMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id__deprecated_writeTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"-deprecated_writeTimeoutMillis", r"()I");

  /// from: public final int -deprecated_writeTimeoutMillis()
  int _deprecated_writeTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_writeTimeoutMillis,
        jni.JniCallType.intType, []).integer;
  }

  static final _id__deprecated_pingIntervalMillis = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"-deprecated_pingIntervalMillis", r"()I");

  /// from: public final int -deprecated_pingIntervalMillis()
  int _deprecated_pingIntervalMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_pingIntervalMillis,
        jni.JniCallType.intType, []).integer;
  }

  static final _id_clone = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clone", r"()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject clone() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clone, jni.JniCallType.objectType, []).object);
  }
}

final class $OkHttpClientType extends jni.JObjType<OkHttpClient> {
  const $OkHttpClientType();

  @override
  String get signature => r"Lokhttp3/OkHttpClient;";

  @override
  OkHttpClient fromRef(jni.JObjectPtr ref) => OkHttpClient.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClientType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClientType) &&
        other is $OkHttpClientType;
  }
}

/// from: okhttp3.Request$Builder
class Request_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Request_Builder> $type = type;

  Request_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Request$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $Request_BuilderType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Request_Builder() {
    return Request_Builder.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_new1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Lokhttp3/Request;)V");

  /// from: public void <init>(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  factory Request_Builder.new1(
    Request request,
  ) {
    return Request_Builder.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new1, [request.reference]).object);
  }

  static final _id_url = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"url", r"(Lokhttp3/HttpUrl;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder url(okhttp3.HttpUrl httpUrl)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url(
    HttpUrl httpUrl,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_url, jni.JniCallType.objectType,
            [httpUrl.reference]).object);
  }

  static final _id_url1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"url", r"(Ljava/lang/String;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder url(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url1(
    jni.JString string,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_url1, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_url2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"url", r"(Ljava/net/URL;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder url(java.net.URL uRL)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url2(
    jni.JObject uRL,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_url2, jni.JniCallType.objectType,
            [uRL.reference]).object);
  }

  static final _id_header = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"header",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder header(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_header, jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_addHeader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addHeader",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder addHeader(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder addHeader(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_addHeader,
            jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_removeHeader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"removeHeader",
      r"(Ljava/lang/String;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder removeHeader(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder removeHeader(
    jni.JString string,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_removeHeader,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_headers = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"headers", r"(Lokhttp3/Headers;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder headers(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder headers(
    jni.JObject headers,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_headers, jni.JniCallType.objectType,
            [headers.reference]).object);
  }

  static final _id_cacheControl = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"cacheControl",
      r"(Lokhttp3/CacheControl;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder cacheControl(okhttp3.CacheControl cacheControl)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder cacheControl(
    jni.JObject cacheControl,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_cacheControl,
            jni.JniCallType.objectType, [cacheControl.reference]).object);
  }

  static final _id_get0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"get", r"()Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder get()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder get0() {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_get0, jni.JniCallType.objectType, []).object);
  }

  static final _id_head = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"head", r"()Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder head()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder head() {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_head, jni.JniCallType.objectType, []).object);
  }

  static final _id_post = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"post", r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder post(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder post(
    jni.JObject requestBody,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_post, jni.JniCallType.objectType,
            [requestBody.reference]).object);
  }

  static final _id_delete = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"delete", r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder delete(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder delete(
    jni.JObject requestBody,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_delete, jni.JniCallType.objectType,
            [requestBody.reference]).object);
  }

  static final _id_put = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"put", r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder put(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder put(
    jni.JObject requestBody,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_put, jni.JniCallType.objectType,
            [requestBody.reference]).object);
  }

  static final _id_patch = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"patch", r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder patch(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder patch(
    jni.JObject requestBody,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_patch, jni.JniCallType.objectType,
            [requestBody.reference]).object);
  }

  static final _id_method = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"method",
      r"(Ljava/lang/String;Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder method(java.lang.String string, okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder method(
    jni.JString string,
    jni.JObject requestBody,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_method, jni.JniCallType.objectType,
            [string.reference, requestBody.reference]).object);
  }

  static final _id_tag = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"tag", r"(Ljava/lang/Object;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder tag(java.lang.Object object)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder tag(
    jni.JObject object,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_tag, jni.JniCallType.objectType,
            [object.reference]).object);
  }

  static final _id_tag1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"tag",
      r"(Ljava/lang/Class;Ljava/lang/Object;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request$Builder tag(java.lang.Class class, T object)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder tag1<$T extends jni.JObject>(
    jni.JObject class0,
    $T object, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      object.$type,
    ]) as jni.JObjType<$T>;
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_tag1, jni.JniCallType.objectType,
            [class0.reference, object.reference]).object);
  }

  static final _id_build = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"build", r"()Lokhttp3/Request;");

  /// from: public okhttp3.Request build()
  /// The returned object must be released after use, by calling the [release] method.
  Request build() {
    return const $RequestType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_build, jni.JniCallType.objectType, []).object);
  }

  static final _id_delete1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"delete", r"()Lokhttp3/Request$Builder;");

  /// from: public final okhttp3.Request$Builder delete()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder delete1() {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_delete1, jni.JniCallType.objectType, []).object);
  }
}

final class $Request_BuilderType extends jni.JObjType<Request_Builder> {
  const $Request_BuilderType();

  @override
  String get signature => r"Lokhttp3/Request$Builder;";

  @override
  Request_Builder fromRef(jni.JObjectPtr ref) => Request_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Request_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Request_BuilderType) &&
        other is $Request_BuilderType;
  }
}

/// from: okhttp3.Request
class Request extends jni.JObject {
  @override
  late final jni.JObjType<Request> $type = type;

  Request.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Request");

  /// The type which includes information such as the signature of this class.
  static const type = $RequestType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(Lokhttp3/HttpUrl;Ljava/lang/String;Lokhttp3/Headers;Lokhttp3/RequestBody;Ljava/util/Map;)V");

  /// from: public void <init>(okhttp3.HttpUrl httpUrl, java.lang.String string, okhttp3.Headers headers, okhttp3.RequestBody requestBody, java.util.Map map)
  /// The returned object must be released after use, by calling the [release] method.
  factory Request(
    HttpUrl httpUrl,
    jni.JString string,
    jni.JObject headers,
    jni.JObject requestBody,
    jni.JMap<jni.JObject, jni.JObject> map,
  ) {
    return Request.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new0, [
      httpUrl.reference,
      string.reference,
      headers.reference,
      requestBody.reference,
      map.reference
    ]).object);
  }

  static final _id_url = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"url", r"()Lokhttp3/HttpUrl;");

  /// from: public final okhttp3.HttpUrl url()
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl url() {
    return const $HttpUrlType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_url, jni.JniCallType.objectType, []).object);
  }

  static final _id_method = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"method", r"()Ljava/lang/String;");

  /// from: public final java.lang.String method()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString method() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_method, jni.JniCallType.objectType, []).object);
  }

  static final _id_headers = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"headers", r"()Lokhttp3/Headers;");

  /// from: public final okhttp3.Headers headers()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject headers() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_headers, jni.JniCallType.objectType, []).object);
  }

  static final _id_body = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"body", r"()Lokhttp3/RequestBody;");

  /// from: public final okhttp3.RequestBody body()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject body() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_body, jni.JniCallType.objectType, []).object);
  }

  static final _id_isHttps =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isHttps", r"()Z");

  /// from: public final boolean isHttps()
  bool isHttps() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isHttps, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_header = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"header", r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public final java.lang.String header(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header(
    jni.JString string,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_header,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_headers1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"headers", r"(Ljava/lang/String;)Ljava/util/List;");

  /// from: public final java.util.List headers(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> headers1(
    jni.JString string,
  ) {
    return const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_headers1, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_tag = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"tag", r"()Ljava/lang/Object;");

  /// from: public final java.lang.Object tag()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject tag() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_tag, jni.JniCallType.objectType, []).object);
  }

  static final _id_tag1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"tag", r"(Ljava/lang/Class;)Ljava/lang/Object;");

  /// from: public final T tag(java.lang.Class class)
  /// The returned object must be released after use, by calling the [release] method.
  $T tag1<$T extends jni.JObject>(
    jni.JObject class0, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jni.Jni.accessors.callMethodWithArgs(reference, _id_tag1,
        jni.JniCallType.objectType, [class0.reference]).object);
  }

  static final _id_newBuilder = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newBuilder", r"()Lokhttp3/Request$Builder;");

  /// from: public final okhttp3.Request$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder newBuilder() {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_newBuilder, jni.JniCallType.objectType, []).object);
  }

  static final _id_cacheControl = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"cacheControl", r"()Lokhttp3/CacheControl;");

  /// from: public final okhttp3.CacheControl cacheControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cacheControl() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cacheControl, jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_url = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_url", r"()Lokhttp3/HttpUrl;");

  /// from: public final okhttp3.HttpUrl -deprecated_url()
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl _deprecated_url() {
    return const $HttpUrlType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id__deprecated_url, jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_method = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_method", r"()Ljava/lang/String;");

  /// from: public final java.lang.String -deprecated_method()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString _deprecated_method() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_method,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_headers = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_headers", r"()Lokhttp3/Headers;");

  /// from: public final okhttp3.Headers -deprecated_headers()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_headers() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_headers,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_body = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_body", r"()Lokhttp3/RequestBody;");

  /// from: public final okhttp3.RequestBody -deprecated_body()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_body() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_body,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_cacheControl = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_cacheControl",
      r"()Lokhttp3/CacheControl;");

  /// from: public final okhttp3.CacheControl -deprecated_cacheControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_cacheControl() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_cacheControl,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }
}

final class $RequestType extends jni.JObjType<Request> {
  const $RequestType();

  @override
  String get signature => r"Lokhttp3/Request;";

  @override
  Request fromRef(jni.JObjectPtr ref) => Request.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RequestType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestType) && other is $RequestType;
  }
}

/// from: okhttp3.Response$Builder
class Response_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Response_Builder> $type = type;

  Response_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Response$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $Response_BuilderType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Response_Builder() {
    return Response_Builder.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_new1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(Lokhttp3/Response;)V");

  /// from: public void <init>(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  factory Response_Builder.new1(
    Response response,
  ) {
    return Response_Builder.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new1, [response.reference]).object);
  }

  static final _id_request = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"request", r"(Lokhttp3/Request;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder request(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder request(
    Request request,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_request, jni.JniCallType.objectType,
            [request.reference]).object);
  }

  static final _id_protocol = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"protocol", r"(Lokhttp3/Protocol;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder protocol(okhttp3.Protocol protocol)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder protocol(
    jni.JObject protocol,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_protocol, jni.JniCallType.objectType,
            [protocol.reference]).object);
  }

  static final _id_code = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"code", r"(I)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder code(int i)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder code(
    int i,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_code, jni.JniCallType.objectType,
            [jni.JValueInt(i)]).object);
  }

  static final _id_message = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"message", r"(Ljava/lang/String;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder message(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder message(
    jni.JString string,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_message, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_handshake = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"handshake", r"(Lokhttp3/Handshake;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder handshake(okhttp3.Handshake handshake)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder handshake(
    jni.JObject handshake,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_handshake,
            jni.JniCallType.objectType, [handshake.reference]).object);
  }

  static final _id_header = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"header",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder header(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_header, jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_addHeader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addHeader",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder addHeader(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder addHeader(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_addHeader,
            jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_removeHeader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"removeHeader",
      r"(Ljava/lang/String;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder removeHeader(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder removeHeader(
    jni.JString string,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_removeHeader,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_headers = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"headers", r"(Lokhttp3/Headers;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder headers(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder headers(
    jni.JObject headers,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_headers, jni.JniCallType.objectType,
            [headers.reference]).object);
  }

  static final _id_body = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"body", r"(Lokhttp3/ResponseBody;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder body(okhttp3.ResponseBody responseBody)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder body(
    ResponseBody responseBody,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_body, jni.JniCallType.objectType,
            [responseBody.reference]).object);
  }

  static final _id_networkResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"networkResponse",
      r"(Lokhttp3/Response;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder networkResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder networkResponse(
    Response response,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_networkResponse,
            jni.JniCallType.objectType, [response.reference]).object);
  }

  static final _id_cacheResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"cacheResponse",
      r"(Lokhttp3/Response;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder cacheResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder cacheResponse(
    Response response,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_cacheResponse,
            jni.JniCallType.objectType, [response.reference]).object);
  }

  static final _id_priorResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"priorResponse",
      r"(Lokhttp3/Response;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder priorResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder priorResponse(
    Response response,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_priorResponse,
            jni.JniCallType.objectType, [response.reference]).object);
  }

  static final _id_sentRequestAtMillis = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"sentRequestAtMillis",
      r"(J)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder sentRequestAtMillis(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder sentRequestAtMillis(
    int j,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_sentRequestAtMillis,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_receivedResponseAtMillis = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"receivedResponseAtMillis",
      r"(J)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response$Builder receivedResponseAtMillis(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder receivedResponseAtMillis(
    int j,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_receivedResponseAtMillis,
            jni.JniCallType.objectType, [j]).object);
  }

  static final _id_build = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"build", r"()Lokhttp3/Response;");

  /// from: public okhttp3.Response build()
  /// The returned object must be released after use, by calling the [release] method.
  Response build() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_build, jni.JniCallType.objectType, []).object);
  }
}

final class $Response_BuilderType extends jni.JObjType<Response_Builder> {
  const $Response_BuilderType();

  @override
  String get signature => r"Lokhttp3/Response$Builder;";

  @override
  Response_Builder fromRef(jni.JObjectPtr ref) => Response_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Response_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Response_BuilderType) &&
        other is $Response_BuilderType;
  }
}

/// from: okhttp3.Response
class Response extends jni.JObject {
  @override
  late final jni.JObjType<Response> $type = type;

  Response.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Response");

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(Lokhttp3/Request;Lokhttp3/Protocol;Ljava/lang/String;ILokhttp3/Handshake;Lokhttp3/Headers;Lokhttp3/ResponseBody;Lokhttp3/Response;Lokhttp3/Response;Lokhttp3/Response;JJLokhttp3/internal/connection/Exchange;)V");

  /// from: public void <init>(okhttp3.Request request, okhttp3.Protocol protocol, java.lang.String string, int i, okhttp3.Handshake handshake, okhttp3.Headers headers, okhttp3.ResponseBody responseBody, okhttp3.Response response, okhttp3.Response response1, okhttp3.Response response2, long j, long j1, okhttp3.internal.connection.Exchange exchange)
  /// The returned object must be released after use, by calling the [release] method.
  factory Response(
    Request request,
    jni.JObject protocol,
    jni.JString string,
    int i,
    jni.JObject handshake,
    jni.JObject headers,
    ResponseBody responseBody,
    Response response,
    Response response1,
    Response response2,
    int j,
    int j1,
    jni.JObject exchange,
  ) {
    return Response.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new0, [
      request.reference,
      protocol.reference,
      string.reference,
      jni.JValueInt(i),
      handshake.reference,
      headers.reference,
      responseBody.reference,
      response.reference,
      response1.reference,
      response2.reference,
      j,
      j1,
      exchange.reference
    ]).object);
  }

  static final _id_request = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"request", r"()Lokhttp3/Request;");

  /// from: public final okhttp3.Request request()
  /// The returned object must be released after use, by calling the [release] method.
  Request request() {
    return const $RequestType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_request, jni.JniCallType.objectType, []).object);
  }

  static final _id_protocol = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protocol", r"()Lokhttp3/Protocol;");

  /// from: public final okhttp3.Protocol protocol()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject protocol() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protocol, jni.JniCallType.objectType, []).object);
  }

  static final _id_message = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"message", r"()Ljava/lang/String;");

  /// from: public final java.lang.String message()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString message() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_message, jni.JniCallType.objectType, []).object);
  }

  static final _id_code =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"code", r"()I");

  /// from: public final int code()
  int code() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_code, jni.JniCallType.intType, []).integer;
  }

  static final _id_handshake = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"handshake", r"()Lokhttp3/Handshake;");

  /// from: public final okhttp3.Handshake handshake()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject handshake() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_handshake, jni.JniCallType.objectType, []).object);
  }

  static final _id_headers = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"headers", r"()Lokhttp3/Headers;");

  /// from: public final okhttp3.Headers headers()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject headers() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_headers, jni.JniCallType.objectType, []).object);
  }

  static final _id_body = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"body", r"()Lokhttp3/ResponseBody;");

  /// from: public final okhttp3.ResponseBody body()
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody body() {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_body, jni.JniCallType.objectType, []).object);
  }

  static final _id_networkResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"networkResponse", r"()Lokhttp3/Response;");

  /// from: public final okhttp3.Response networkResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response networkResponse() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_networkResponse, jni.JniCallType.objectType, []).object);
  }

  static final _id_cacheResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"cacheResponse", r"()Lokhttp3/Response;");

  /// from: public final okhttp3.Response cacheResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response cacheResponse() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cacheResponse, jni.JniCallType.objectType, []).object);
  }

  static final _id_priorResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"priorResponse", r"()Lokhttp3/Response;");

  /// from: public final okhttp3.Response priorResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response priorResponse() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_priorResponse, jni.JniCallType.objectType, []).object);
  }

  static final _id_sentRequestAtMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sentRequestAtMillis", r"()J");

  /// from: public final long sentRequestAtMillis()
  int sentRequestAtMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_sentRequestAtMillis, jni.JniCallType.longType, []).long;
  }

  static final _id_receivedResponseAtMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"receivedResponseAtMillis", r"()J");

  /// from: public final long receivedResponseAtMillis()
  int receivedResponseAtMillis() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_receivedResponseAtMillis, jni.JniCallType.longType, []).long;
  }

  static final _id_exchange = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"exchange", r"()Lokhttp3/internal/connection/Exchange;");

  /// from: public final okhttp3.internal.connection.Exchange exchange()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject exchange() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_exchange, jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_request = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_request", r"()Lokhttp3/Request;");

  /// from: public final okhttp3.Request -deprecated_request()
  /// The returned object must be released after use, by calling the [release] method.
  Request _deprecated_request() {
    return const $RequestType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_request,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_protocol = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_protocol", r"()Lokhttp3/Protocol;");

  /// from: public final okhttp3.Protocol -deprecated_protocol()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_protocol() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_protocol,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_code = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_code", r"()I");

  /// from: public final int -deprecated_code()
  int _deprecated_code() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id__deprecated_code, jni.JniCallType.intType, []).integer;
  }

  static final _id_isSuccessful = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isSuccessful", r"()Z");

  /// from: public final boolean isSuccessful()
  bool isSuccessful() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isSuccessful, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id__deprecated_message = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_message", r"()Ljava/lang/String;");

  /// from: public final java.lang.String -deprecated_message()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString _deprecated_message() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_message,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_handshake = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_handshake", r"()Lokhttp3/Handshake;");

  /// from: public final okhttp3.Handshake -deprecated_handshake()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_handshake() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_handshake,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_headers1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"headers", r"(Ljava/lang/String;)Ljava/util/List;");

  /// from: public final java.util.List headers(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> headers1(
    jni.JString string,
  ) {
    return const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_headers1, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_header = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"header", r"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public final java.lang.String header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header(
    jni.JString string,
    jni.JString string1,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_header,
        jni.JniCallType.objectType,
        [string.reference, string1.reference]).object);
  }

  static final _id__deprecated_headers = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_headers", r"()Lokhttp3/Headers;");

  /// from: public final okhttp3.Headers -deprecated_headers()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_headers() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_headers,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_trailers = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"trailers", r"()Lokhttp3/Headers;");

  /// from: public final okhttp3.Headers trailers()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject trailers() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_trailers, jni.JniCallType.objectType, []).object);
  }

  static final _id_peekBody = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"peekBody", r"(J)Lokhttp3/ResponseBody;");

  /// from: public final okhttp3.ResponseBody peekBody(long j)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody peekBody(
    int j,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_peekBody, jni.JniCallType.objectType, [j]).object);
  }

  static final _id__deprecated_body = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_body", r"()Lokhttp3/ResponseBody;");

  /// from: public final okhttp3.ResponseBody -deprecated_body()
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody _deprecated_body() {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id__deprecated_body,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_newBuilder = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newBuilder", r"()Lokhttp3/Response$Builder;");

  /// from: public final okhttp3.Response$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder newBuilder() {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_newBuilder, jni.JniCallType.objectType, []).object);
  }

  static final _id_isRedirect =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isRedirect", r"()Z");

  /// from: public final boolean isRedirect()
  bool isRedirect() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isRedirect, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id__deprecated_networkResponse = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_networkResponse",
          r"()Lokhttp3/Response;");

  /// from: public final okhttp3.Response -deprecated_networkResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response _deprecated_networkResponse() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_networkResponse,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_cacheResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_cacheResponse", r"()Lokhttp3/Response;");

  /// from: public final okhttp3.Response -deprecated_cacheResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response _deprecated_cacheResponse() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_cacheResponse,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_priorResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_priorResponse", r"()Lokhttp3/Response;");

  /// from: public final okhttp3.Response -deprecated_priorResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response _deprecated_priorResponse() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_priorResponse,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_challenges = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"challenges", r"()Ljava/util/List;");

  /// from: public final java.util.List challenges()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> challenges() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_challenges, jni.JniCallType.objectType, []).object);
  }

  static final _id_cacheControl = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"cacheControl", r"()Lokhttp3/CacheControl;");

  /// from: public final okhttp3.CacheControl cacheControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cacheControl() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cacheControl, jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_cacheControl = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_cacheControl",
      r"()Lokhttp3/CacheControl;");

  /// from: public final okhttp3.CacheControl -deprecated_cacheControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_cacheControl() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_cacheControl,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_sentRequestAtMillis = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"-deprecated_sentRequestAtMillis", r"()J");

  /// from: public final long -deprecated_sentRequestAtMillis()
  int _deprecated_sentRequestAtMillis() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id__deprecated_sentRequestAtMillis, jni.JniCallType.longType, []).long;
  }

  static final _id__deprecated_receivedResponseAtMillis = jni.Jni.accessors
      .getMethodIDOf(
          _class.reference, r"-deprecated_receivedResponseAtMillis", r"()J");

  /// from: public final long -deprecated_receivedResponseAtMillis()
  int _deprecated_receivedResponseAtMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_receivedResponseAtMillis,
        jni.JniCallType.longType, []).long;
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id_header1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"header", r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public final java.lang.String header(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header1(
    jni.JString string,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_header1,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }
}

final class $ResponseType extends jni.JObjType<Response> {
  const $ResponseType();

  @override
  String get signature => r"Lokhttp3/Response;";

  @override
  Response fromRef(jni.JObjectPtr ref) => Response.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseType) && other is $ResponseType;
  }
}

/// from: okhttp3.ResponseBody$BomAwareReader
class ResponseBody_BomAwareReader extends jni.JObject {
  @override
  late final jni.JObjType<ResponseBody_BomAwareReader> $type = type;

  ResponseBody_BomAwareReader.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"okhttp3/ResponseBody$BomAwareReader");

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseBody_BomAwareReaderType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lokio/BufferedSource;Ljava/nio/charset/Charset;)V");

  /// from: public void <init>(okio.BufferedSource bufferedSource, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  factory ResponseBody_BomAwareReader(
    BufferedSource bufferedSource,
    jni.JObject charset,
  ) {
    return ResponseBody_BomAwareReader.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0,
            [bufferedSource.reference, charset.reference]).object);
  }

  static final _id_read =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"read", r"([CII)I");

  /// from: public int read(char[] cs, int i, int i1)
  int read(
    jni.JArray<jni.jchar> cs,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_read,
        jni.JniCallType.intType,
        [cs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).integer;
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }
}

final class $ResponseBody_BomAwareReaderType
    extends jni.JObjType<ResponseBody_BomAwareReader> {
  const $ResponseBody_BomAwareReaderType();

  @override
  String get signature => r"Lokhttp3/ResponseBody$BomAwareReader;";

  @override
  ResponseBody_BomAwareReader fromRef(jni.JObjectPtr ref) =>
      ResponseBody_BomAwareReader.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseBody_BomAwareReaderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseBody_BomAwareReaderType) &&
        other is $ResponseBody_BomAwareReaderType;
  }
}

/// from: okhttp3.ResponseBody$Companion
class ResponseBody_Companion extends jni.JObject {
  @override
  late final jni.JObjType<ResponseBody_Companion> $type = type;

  ResponseBody_Companion.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/ResponseBody$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseBody_CompanionType();
  static final _id_create = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"create",
      r"(Ljava/lang/String;Lokhttp3/MediaType;)Lokhttp3/ResponseBody;");

  /// from: public final okhttp3.ResponseBody create(java.lang.String string, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create(
    jni.JString string,
    jni.JObject mediaType,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_create, jni.JniCallType.objectType,
            [string.reference, mediaType.reference]).object);
  }

  static final _id_create1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"create", r"([BLokhttp3/MediaType;)Lokhttp3/ResponseBody;");

  /// from: public final okhttp3.ResponseBody create(byte[] bs, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create1(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_create1, jni.JniCallType.objectType,
            [bs.reference, mediaType.reference]).object);
  }

  static final _id_create2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokio/ByteString;Lokhttp3/MediaType;)Lokhttp3/ResponseBody;");

  /// from: public final okhttp3.ResponseBody create(okio.ByteString byteString, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create2(
    ByteString byteString,
    jni.JObject mediaType,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_create2, jni.JniCallType.objectType,
            [byteString.reference, mediaType.reference]).object);
  }

  static final _id_create3 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokio/BufferedSource;Lokhttp3/MediaType;J)Lokhttp3/ResponseBody;");

  /// from: public final okhttp3.ResponseBody create(okio.BufferedSource bufferedSource, okhttp3.MediaType mediaType, long j)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create3(
    BufferedSource bufferedSource,
    jni.JObject mediaType,
    int j,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_create3, jni.JniCallType.objectType,
            [bufferedSource.reference, mediaType.reference, j]).object);
  }

  static final _id_create4 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;Ljava/lang/String;)Lokhttp3/ResponseBody;");

  /// from: public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create4(
    jni.JObject mediaType,
    jni.JString string,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_create4, jni.JniCallType.objectType,
            [mediaType.reference, string.reference]).object);
  }

  static final _id_create5 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"create", r"(Lokhttp3/MediaType;[B)Lokhttp3/ResponseBody;");

  /// from: public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create5(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_create5, jni.JniCallType.objectType,
            [mediaType.reference, bs.reference]).object);
  }

  static final _id_create6 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;Lokio/ByteString;)Lokhttp3/ResponseBody;");

  /// from: public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create6(
    jni.JObject mediaType,
    ByteString byteString,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_create6, jni.JniCallType.objectType,
            [mediaType.reference, byteString.reference]).object);
  }

  static final _id_create7 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;JLokio/BufferedSource;)Lokhttp3/ResponseBody;");

  /// from: public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, long j, okio.BufferedSource bufferedSource)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create7(
    jni.JObject mediaType,
    int j,
    BufferedSource bufferedSource,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_create7, jni.JniCallType.objectType,
            [mediaType.reference, j, bufferedSource.reference]).object);
  }

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory ResponseBody_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return ResponseBody_Companion.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [defaultConstructorMarker.reference]).object);
  }
}

final class $ResponseBody_CompanionType
    extends jni.JObjType<ResponseBody_Companion> {
  const $ResponseBody_CompanionType();

  @override
  String get signature => r"Lokhttp3/ResponseBody$Companion;";

  @override
  ResponseBody_Companion fromRef(jni.JObjectPtr ref) =>
      ResponseBody_Companion.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseBody_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseBody_CompanionType) &&
        other is $ResponseBody_CompanionType;
  }
}

/// from: okhttp3.ResponseBody
class ResponseBody extends jni.JObject {
  @override
  late final jni.JObjType<ResponseBody> $type = type;

  ResponseBody.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/ResponseBody");

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseBodyType();
  static final _id_Companion = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Companion",
    r"Lokhttp3/ResponseBody$Companion;",
  );

  /// from: static public final okhttp3.ResponseBody$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody_Companion get Companion =>
      const $ResponseBody_CompanionType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_Companion, jni.JniCallType.objectType)
          .object);

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory ResponseBody() {
    return ResponseBody.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_contentType = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"contentType", r"()Lokhttp3/MediaType;");

  /// from: public abstract okhttp3.MediaType contentType()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject contentType() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_contentType, jni.JniCallType.objectType, []).object);
  }

  static final _id_contentLength = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"contentLength", r"()J");

  /// from: public abstract long contentLength()
  int contentLength() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_contentLength, jni.JniCallType.longType, []).long;
  }

  static final _id_byteStream = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"byteStream", r"()Ljava/io/InputStream;");

  /// from: public final java.io.InputStream byteStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject byteStream() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_byteStream, jni.JniCallType.objectType, []).object);
  }

  static final _id_source = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"source", r"()Lokio/BufferedSource;");

  /// from: public abstract okio.BufferedSource source()
  /// The returned object must be released after use, by calling the [release] method.
  BufferedSource source() {
    return const $BufferedSourceType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_source, jni.JniCallType.objectType, []).object);
  }

  static final _id_bytes =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"bytes", r"()[B");

  /// from: public final byte[] bytes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> bytes() {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_bytes, jni.JniCallType.objectType, []).object);
  }

  static final _id_byteString = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"byteString", r"()Lokio/ByteString;");

  /// from: public final okio.ByteString byteString()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString byteString() {
    return const $ByteStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_byteString, jni.JniCallType.objectType, []).object);
  }

  static final _id_charStream = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"charStream", r"()Ljava/io/Reader;");

  /// from: public final java.io.Reader charStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject charStream() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_charStream, jni.JniCallType.objectType, []).object);
  }

  static final _id_string = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"string", r"()Ljava/lang/String;");

  /// from: public final java.lang.String string()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString string() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_string, jni.JniCallType.objectType, []).object);
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_create = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Ljava/lang/String;Lokhttp3/MediaType;)Lokhttp3/ResponseBody;");

  /// from: static public final okhttp3.ResponseBody create(java.lang.String string, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create(
    jni.JString string,
    jni.JObject mediaType,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create,
            jni.JniCallType.objectType,
            [string.reference, mediaType.reference]).object);
  }

  static final _id_create1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"([BLokhttp3/MediaType;)Lokhttp3/ResponseBody;");

  /// from: static public final okhttp3.ResponseBody create(byte[] bs, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create1(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create1,
            jni.JniCallType.objectType,
            [bs.reference, mediaType.reference]).object);
  }

  static final _id_create2 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokio/ByteString;Lokhttp3/MediaType;)Lokhttp3/ResponseBody;");

  /// from: static public final okhttp3.ResponseBody create(okio.ByteString byteString, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create2(
    ByteString byteString,
    jni.JObject mediaType,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create2,
            jni.JniCallType.objectType,
            [byteString.reference, mediaType.reference]).object);
  }

  static final _id_create3 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokio/BufferedSource;Lokhttp3/MediaType;J)Lokhttp3/ResponseBody;");

  /// from: static public final okhttp3.ResponseBody create(okio.BufferedSource bufferedSource, okhttp3.MediaType mediaType, long j)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create3(
    BufferedSource bufferedSource,
    jni.JObject mediaType,
    int j,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create3,
            jni.JniCallType.objectType,
            [bufferedSource.reference, mediaType.reference, j]).object);
  }

  static final _id_create4 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;Ljava/lang/String;)Lokhttp3/ResponseBody;");

  /// from: static public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create4(
    jni.JObject mediaType,
    jni.JString string,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create4,
            jni.JniCallType.objectType,
            [mediaType.reference, string.reference]).object);
  }

  static final _id_create5 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;[B)Lokhttp3/ResponseBody;");

  /// from: static public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create5(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create5,
            jni.JniCallType.objectType,
            [mediaType.reference, bs.reference]).object);
  }

  static final _id_create6 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;Lokio/ByteString;)Lokhttp3/ResponseBody;");

  /// from: static public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create6(
    jni.JObject mediaType,
    ByteString byteString,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create6,
            jni.JniCallType.objectType,
            [mediaType.reference, byteString.reference]).object);
  }

  static final _id_create7 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;JLokio/BufferedSource;)Lokhttp3/ResponseBody;");

  /// from: static public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, long j, okio.BufferedSource bufferedSource)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create7(
    jni.JObject mediaType,
    int j,
    BufferedSource bufferedSource,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create7,
            jni.JniCallType.objectType,
            [mediaType.reference, j, bufferedSource.reference]).object);
  }
}

final class $ResponseBodyType extends jni.JObjType<ResponseBody> {
  const $ResponseBodyType();

  @override
  String get signature => r"Lokhttp3/ResponseBody;";

  @override
  ResponseBody fromRef(jni.JObjectPtr ref) => ResponseBody.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseBodyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseBodyType) &&
        other is $ResponseBodyType;
  }
}

/// from: okhttp3.HttpUrl$Builder$Companion
class HttpUrl_Builder_Companion extends jni.JObject {
  @override
  late final jni.JObjType<HttpUrl_Builder_Companion> $type = type;

  HttpUrl_Builder_Companion.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"okhttp3/HttpUrl$Builder$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $HttpUrl_Builder_CompanionType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory HttpUrl_Builder_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return HttpUrl_Builder_Companion.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0,
            [defaultConstructorMarker.reference]).object);
  }
}

final class $HttpUrl_Builder_CompanionType
    extends jni.JObjType<HttpUrl_Builder_Companion> {
  const $HttpUrl_Builder_CompanionType();

  @override
  String get signature => r"Lokhttp3/HttpUrl$Builder$Companion;";

  @override
  HttpUrl_Builder_Companion fromRef(jni.JObjectPtr ref) =>
      HttpUrl_Builder_Companion.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($HttpUrl_Builder_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($HttpUrl_Builder_CompanionType) &&
        other is $HttpUrl_Builder_CompanionType;
  }
}

/// from: okhttp3.HttpUrl$Builder
class HttpUrl_Builder extends jni.JObject {
  @override
  late final jni.JObjType<HttpUrl_Builder> $type = type;

  HttpUrl_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/HttpUrl$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $HttpUrl_BuilderType();
  static final _id_Companion = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Companion",
    r"Lokhttp3/HttpUrl$Builder$Companion;",
  );

  /// from: static public final okhttp3.HttpUrl$Builder$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static HttpUrl_Builder_Companion get Companion =>
      const $HttpUrl_Builder_CompanionType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_Companion, jni.JniCallType.objectType)
          .object);

  static final _id_INVALID_HOST = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"INVALID_HOST",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String INVALID_HOST
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INVALID_HOST =>
      const jni.JStringType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_INVALID_HOST, jni.JniCallType.objectType)
          .object);

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory HttpUrl_Builder() {
    return HttpUrl_Builder.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_scheme = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"scheme", r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder scheme(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder scheme(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_scheme, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_username = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"username", r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder username(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder username(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_username, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_encodedUsername = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"encodedUsername",
      r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder encodedUsername(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder encodedUsername(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_encodedUsername,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_password = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"password", r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder password(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder password(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_password, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_encodedPassword = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"encodedPassword",
      r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder encodedPassword(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder encodedPassword(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_encodedPassword,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_host = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"host", r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder host(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder host(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_host, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_port = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"port", r"(I)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder port(int i)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder port(
    int i,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_port, jni.JniCallType.objectType,
            [jni.JValueInt(i)]).object);
  }

  static final _id_addPathSegment = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addPathSegment",
      r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder addPathSegment(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder addPathSegment(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_addPathSegment,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_addPathSegments = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addPathSegments",
      r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder addPathSegments(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder addPathSegments(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_addPathSegments,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_addEncodedPathSegment = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addEncodedPathSegment",
      r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder addEncodedPathSegment(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder addEncodedPathSegment(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_addEncodedPathSegment,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_addEncodedPathSegments = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addEncodedPathSegments",
      r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder addEncodedPathSegments(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder addEncodedPathSegments(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_addEncodedPathSegments,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_setPathSegment = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setPathSegment",
      r"(ILjava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder setPathSegment(int i, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder setPathSegment(
    int i,
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_setPathSegment,
            jni.JniCallType.objectType,
            [jni.JValueInt(i), string.reference]).object);
  }

  static final _id_setEncodedPathSegment = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setEncodedPathSegment",
      r"(ILjava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder setEncodedPathSegment(int i, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder setEncodedPathSegment(
    int i,
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_setEncodedPathSegment,
            jni.JniCallType.objectType,
            [jni.JValueInt(i), string.reference]).object);
  }

  static final _id_removePathSegment = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"removePathSegment", r"(I)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder removePathSegment(int i)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder removePathSegment(
    int i,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_removePathSegment,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);
  }

  static final _id_encodedPath = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"encodedPath",
      r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder encodedPath(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder encodedPath(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_encodedPath,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_query = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"query", r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder query(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder query(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_query, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_encodedQuery = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"encodedQuery",
      r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder encodedQuery(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder encodedQuery(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_encodedQuery,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_addQueryParameter = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addQueryParameter",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder addQueryParameter(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder addQueryParameter(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_addQueryParameter,
            jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_addEncodedQueryParameter = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addEncodedQueryParameter",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder addEncodedQueryParameter(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder addEncodedQueryParameter(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_addEncodedQueryParameter,
            jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_setQueryParameter = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setQueryParameter",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder setQueryParameter(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder setQueryParameter(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_setQueryParameter,
            jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_setEncodedQueryParameter = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setEncodedQueryParameter",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder setEncodedQueryParameter(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder setEncodedQueryParameter(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_setEncodedQueryParameter,
            jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_removeAllQueryParameters = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"removeAllQueryParameters",
      r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder removeAllQueryParameters(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder removeAllQueryParameters(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_removeAllQueryParameters,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_removeAllEncodedQueryParameters = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"removeAllEncodedQueryParameters",
          r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder removeAllEncodedQueryParameters(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder removeAllEncodedQueryParameters(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_removeAllEncodedQueryParameters,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_fragment = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"fragment", r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder fragment(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder fragment(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_fragment, jni.JniCallType.objectType,
            [string.reference]).object);
  }

  static final _id_encodedFragment = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"encodedFragment",
      r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder encodedFragment(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder encodedFragment(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_encodedFragment,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_build = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"build", r"()Lokhttp3/HttpUrl;");

  /// from: public final okhttp3.HttpUrl build()
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl build() {
    return const $HttpUrlType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_build, jni.JniCallType.objectType, []).object);
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }
}

final class $HttpUrl_BuilderType extends jni.JObjType<HttpUrl_Builder> {
  const $HttpUrl_BuilderType();

  @override
  String get signature => r"Lokhttp3/HttpUrl$Builder;";

  @override
  HttpUrl_Builder fromRef(jni.JObjectPtr ref) => HttpUrl_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($HttpUrl_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($HttpUrl_BuilderType) &&
        other is $HttpUrl_BuilderType;
  }
}

/// from: okhttp3.HttpUrl$Companion
class HttpUrl_Companion extends jni.JObject {
  @override
  late final jni.JObjType<HttpUrl_Companion> $type = type;

  HttpUrl_Companion.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/HttpUrl$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $HttpUrl_CompanionType();
  static final _id_defaultPort = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"defaultPort", r"(Ljava/lang/String;)I");

  /// from: public final int defaultPort(java.lang.String string)
  int defaultPort(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_defaultPort,
        jni.JniCallType.intType, [string.reference]).integer;
  }

  static final _id_get0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"get", r"(Ljava/lang/String;)Lokhttp3/HttpUrl;");

  /// from: public final okhttp3.HttpUrl get(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl get0(
    jni.JString string,
  ) {
    return const $HttpUrlType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get0,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_parse = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"parse", r"(Ljava/lang/String;)Lokhttp3/HttpUrl;");

  /// from: public final okhttp3.HttpUrl parse(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl parse(
    jni.JString string,
  ) {
    return const $HttpUrlType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_parse,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_get1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"get", r"(Ljava/net/URL;)Lokhttp3/HttpUrl;");

  /// from: public final okhttp3.HttpUrl get(java.net.URL uRL)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl get1(
    jni.JObject uRL,
  ) {
    return const $HttpUrlType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get1,
        jni.JniCallType.objectType,
        [uRL.reference]).object);
  }

  static final _id_get2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"get", r"(Ljava/net/URI;)Lokhttp3/HttpUrl;");

  /// from: public final okhttp3.HttpUrl get(java.net.URI uRI)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl get2(
    jni.JObject uRI,
  ) {
    return const $HttpUrlType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get2,
        jni.JniCallType.objectType,
        [uRI.reference]).object);
  }

  static final _id__deprecated_get = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_get",
      r"(Ljava/lang/String;)Lokhttp3/HttpUrl;");

  /// from: public final okhttp3.HttpUrl -deprecated_get(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl _deprecated_get(
    jni.JString string,
  ) {
    return const $HttpUrlType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_get,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id__deprecated_parse = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_parse",
      r"(Ljava/lang/String;)Lokhttp3/HttpUrl;");

  /// from: public final okhttp3.HttpUrl -deprecated_parse(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl _deprecated_parse(
    jni.JString string,
  ) {
    return const $HttpUrlType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_parse,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id__deprecated_get1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_get",
      r"(Ljava/net/URL;)Lokhttp3/HttpUrl;");

  /// from: public final okhttp3.HttpUrl -deprecated_get(java.net.URL uRL)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl _deprecated_get1(
    jni.JObject uRL,
  ) {
    return const $HttpUrlType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_get1,
        jni.JniCallType.objectType,
        [uRL.reference]).object);
  }

  static final _id__deprecated_get2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"-deprecated_get",
      r"(Ljava/net/URI;)Lokhttp3/HttpUrl;");

  /// from: public final okhttp3.HttpUrl -deprecated_get(java.net.URI uRI)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl _deprecated_get2(
    jni.JObject uRI,
  ) {
    return const $HttpUrlType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_get2,
        jni.JniCallType.objectType,
        [uRI.reference]).object);
  }

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"<init>", r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V");

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory HttpUrl_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return HttpUrl_Companion.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [defaultConstructorMarker.reference]).object);
  }
}

final class $HttpUrl_CompanionType extends jni.JObjType<HttpUrl_Companion> {
  const $HttpUrl_CompanionType();

  @override
  String get signature => r"Lokhttp3/HttpUrl$Companion;";

  @override
  HttpUrl_Companion fromRef(jni.JObjectPtr ref) =>
      HttpUrl_Companion.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($HttpUrl_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($HttpUrl_CompanionType) &&
        other is $HttpUrl_CompanionType;
  }
}

/// from: okhttp3.HttpUrl
class HttpUrl extends jni.JObject {
  @override
  late final jni.JObjType<HttpUrl> $type = type;

  HttpUrl.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/HttpUrl");

  /// The type which includes information such as the signature of this class.
  static const type = $HttpUrlType();
  static final _id_Companion = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"Companion",
    r"Lokhttp3/HttpUrl$Companion;",
  );

  /// from: static public final okhttp3.HttpUrl$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static HttpUrl_Companion get Companion =>
      const $HttpUrl_CompanionType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_Companion, jni.JniCallType.objectType)
          .object);

  static final _id_USERNAME_ENCODE_SET = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"USERNAME_ENCODE_SET",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String USERNAME_ENCODE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get USERNAME_ENCODE_SET =>
      const jni.JStringType().fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_USERNAME_ENCODE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_PASSWORD_ENCODE_SET = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PASSWORD_ENCODE_SET",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String PASSWORD_ENCODE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PASSWORD_ENCODE_SET =>
      const jni.JStringType().fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_PASSWORD_ENCODE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_PATH_SEGMENT_ENCODE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PATH_SEGMENT_ENCODE_SET",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String PATH_SEGMENT_ENCODE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PATH_SEGMENT_ENCODE_SET =>
      const jni.JStringType().fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_PATH_SEGMENT_ENCODE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_PATH_SEGMENT_ENCODE_SET_URI =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"PATH_SEGMENT_ENCODE_SET_URI",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String PATH_SEGMENT_ENCODE_SET_URI
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PATH_SEGMENT_ENCODE_SET_URI =>
      const jni.JStringType().fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_PATH_SEGMENT_ENCODE_SET_URI,
              jni.JniCallType.objectType)
          .object);

  static final _id_QUERY_ENCODE_SET = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"QUERY_ENCODE_SET",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String QUERY_ENCODE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_ENCODE_SET => const jni.JStringType().fromRef(jni
      .Jni.accessors
      .getStaticField(
          _class.reference, _id_QUERY_ENCODE_SET, jni.JniCallType.objectType)
      .object);

  static final _id_QUERY_COMPONENT_REENCODE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"QUERY_COMPONENT_REENCODE_SET",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String QUERY_COMPONENT_REENCODE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_COMPONENT_REENCODE_SET =>
      const jni.JStringType().fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_QUERY_COMPONENT_REENCODE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_QUERY_COMPONENT_ENCODE_SET =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"QUERY_COMPONENT_ENCODE_SET",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String QUERY_COMPONENT_ENCODE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_COMPONENT_ENCODE_SET =>
      const jni.JStringType().fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_QUERY_COMPONENT_ENCODE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_QUERY_COMPONENT_ENCODE_SET_URI =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"QUERY_COMPONENT_ENCODE_SET_URI",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String QUERY_COMPONENT_ENCODE_SET_URI
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get QUERY_COMPONENT_ENCODE_SET_URI =>
      const jni.JStringType().fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_QUERY_COMPONENT_ENCODE_SET_URI,
              jni.JniCallType.objectType)
          .object);

  static final _id_FORM_ENCODE_SET = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"FORM_ENCODE_SET",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String FORM_ENCODE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FORM_ENCODE_SET =>
      const jni.JStringType().fromRef(jni.Jni.accessors
          .getStaticField(
              _class.reference, _id_FORM_ENCODE_SET, jni.JniCallType.objectType)
          .object);

  static final _id_FRAGMENT_ENCODE_SET = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"FRAGMENT_ENCODE_SET",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String FRAGMENT_ENCODE_SET
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FRAGMENT_ENCODE_SET =>
      const jni.JStringType().fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_FRAGMENT_ENCODE_SET,
              jni.JniCallType.objectType)
          .object);

  static final _id_FRAGMENT_ENCODE_SET_URI =
      jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"FRAGMENT_ENCODE_SET_URI",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String FRAGMENT_ENCODE_SET_URI
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FRAGMENT_ENCODE_SET_URI =>
      const jni.JStringType().fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_FRAGMENT_ENCODE_SET_URI,
              jni.JniCallType.objectType)
          .object);

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"<init>",
      r"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;ILjava/util/List;Ljava/util/List;Ljava/lang/String;Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, int i, java.util.List list, java.util.List list1, java.lang.String string4, java.lang.String string5)
  /// The returned object must be released after use, by calling the [release] method.
  factory HttpUrl(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    int i,
    jni.JList<jni.JString> list,
    jni.JList<jni.JString> list1,
    jni.JString string4,
    jni.JString string5,
  ) {
    return HttpUrl.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new0, [
      string.reference,
      string1.reference,
      string2.reference,
      string3.reference,
      jni.JValueInt(i),
      list.reference,
      list1.reference,
      string4.reference,
      string5.reference
    ]).object);
  }

  static final _id_scheme = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"scheme", r"()Ljava/lang/String;");

  /// from: public final java.lang.String scheme()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString scheme() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_scheme, jni.JniCallType.objectType, []).object);
  }

  static final _id_username = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"username", r"()Ljava/lang/String;");

  /// from: public final java.lang.String username()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString username() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_username, jni.JniCallType.objectType, []).object);
  }

  static final _id_password = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"password", r"()Ljava/lang/String;");

  /// from: public final java.lang.String password()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString password() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_password, jni.JniCallType.objectType, []).object);
  }

  static final _id_host = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"host", r"()Ljava/lang/String;");

  /// from: public final java.lang.String host()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString host() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_host, jni.JniCallType.objectType, []).object);
  }

  static final _id_port =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"port", r"()I");

  /// from: public final int port()
  int port() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_port, jni.JniCallType.intType, []).integer;
  }

  static final _id_pathSegments = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"pathSegments", r"()Ljava/util/List;");

  /// from: public final java.util.List pathSegments()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> pathSegments() {
    return const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_pathSegments,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_fragment = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"fragment", r"()Ljava/lang/String;");

  /// from: public final java.lang.String fragment()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString fragment() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_fragment, jni.JniCallType.objectType, []).object);
  }

  static final _id_isHttps =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isHttps", r"()Z");

  /// from: public final boolean isHttps()
  bool isHttps() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isHttps, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_url = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"url", r"()Ljava/net/URL;");

  /// from: public final java.net.URL url()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject url() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_url, jni.JniCallType.objectType, []).object);
  }

  static final _id_uri = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"uri", r"()Ljava/net/URI;");

  /// from: public final java.net.URI uri()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject uri() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_uri, jni.JniCallType.objectType, []).object);
  }

  static final _id_encodedUsername = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"encodedUsername", r"()Ljava/lang/String;");

  /// from: public final java.lang.String encodedUsername()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString encodedUsername() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_encodedUsername, jni.JniCallType.objectType, []).object);
  }

  static final _id_encodedPassword = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"encodedPassword", r"()Ljava/lang/String;");

  /// from: public final java.lang.String encodedPassword()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString encodedPassword() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_encodedPassword, jni.JniCallType.objectType, []).object);
  }

  static final _id_pathSize =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"pathSize", r"()I");

  /// from: public final int pathSize()
  int pathSize() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_pathSize, jni.JniCallType.intType, []).integer;
  }

  static final _id_encodedPath = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"encodedPath", r"()Ljava/lang/String;");

  /// from: public final java.lang.String encodedPath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString encodedPath() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_encodedPath, jni.JniCallType.objectType, []).object);
  }

  static final _id_encodedPathSegments = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"encodedPathSegments", r"()Ljava/util/List;");

  /// from: public final java.util.List encodedPathSegments()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> encodedPathSegments() {
    return const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_encodedPathSegments,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_encodedQuery = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"encodedQuery", r"()Ljava/lang/String;");

  /// from: public final java.lang.String encodedQuery()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString encodedQuery() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_encodedQuery, jni.JniCallType.objectType, []).object);
  }

  static final _id_query = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"query", r"()Ljava/lang/String;");

  /// from: public final java.lang.String query()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString query() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_query, jni.JniCallType.objectType, []).object);
  }

  static final _id_querySize =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"querySize", r"()I");

  /// from: public final int querySize()
  int querySize() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_querySize, jni.JniCallType.intType, []).integer;
  }

  static final _id_queryParameter = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"queryParameter",
      r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public final java.lang.String queryParameter(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString queryParameter(
    jni.JString string,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_queryParameter,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_queryParameterNames = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"queryParameterNames", r"()Ljava/util/Set;");

  /// from: public final java.util.Set queryParameterNames()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JSet<jni.JString> queryParameterNames() {
    return const jni.JSetType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_queryParameterNames,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_queryParameterValues = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"queryParameterValues",
      r"(Ljava/lang/String;)Ljava/util/List;");

  /// from: public final java.util.List queryParameterValues(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> queryParameterValues(
    jni.JString string,
  ) {
    return const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_queryParameterValues,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_queryParameterName = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"queryParameterName", r"(I)Ljava/lang/String;");

  /// from: public final java.lang.String queryParameterName(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString queryParameterName(
    int i,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_queryParameterName,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_queryParameterValue = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"queryParameterValue", r"(I)Ljava/lang/String;");

  /// from: public final java.lang.String queryParameterValue(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString queryParameterValue(
    int i,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_queryParameterValue,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);
  }

  static final _id_encodedFragment = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"encodedFragment", r"()Ljava/lang/String;");

  /// from: public final java.lang.String encodedFragment()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString encodedFragment() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_encodedFragment, jni.JniCallType.objectType, []).object);
  }

  static final _id_redact = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"redact", r"()Ljava/lang/String;");

  /// from: public final java.lang.String redact()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString redact() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_redact, jni.JniCallType.objectType, []).object);
  }

  static final _id_resolve = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"resolve", r"(Ljava/lang/String;)Lokhttp3/HttpUrl;");

  /// from: public final okhttp3.HttpUrl resolve(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl resolve(
    jni.JString string,
  ) {
    return const $HttpUrlType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_resolve,
        jni.JniCallType.objectType,
        [string.reference]).object);
  }

  static final _id_newBuilder = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newBuilder", r"()Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder newBuilder() {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_newBuilder, jni.JniCallType.objectType, []).object);
  }

  static final _id_newBuilder1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"newBuilder",
      r"(Ljava/lang/String;)Lokhttp3/HttpUrl$Builder;");

  /// from: public final okhttp3.HttpUrl$Builder newBuilder(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  HttpUrl_Builder newBuilder1(
    jni.JString string,
  ) {
    return const $HttpUrl_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_newBuilder1,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_equals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"equals", r"(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [object.reference]).boolean;
  }

  static final _id_hashCode1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"hashCode", r"()I");

  /// from: public int hashCode()
  int hashCode1() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hashCode1, jni.JniCallType.intType, []).integer;
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id_topPrivateDomain = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"topPrivateDomain", r"()Ljava/lang/String;");

  /// from: public final java.lang.String topPrivateDomain()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString topPrivateDomain() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_topPrivateDomain,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_url = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_url", r"()Ljava/net/URL;");

  /// from: public final java.net.URL -deprecated_url()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_url() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id__deprecated_url, jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_uri = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_uri", r"()Ljava/net/URI;");

  /// from: public final java.net.URI -deprecated_uri()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject _deprecated_uri() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id__deprecated_uri, jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_scheme = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_scheme", r"()Ljava/lang/String;");

  /// from: public final java.lang.String -deprecated_scheme()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString _deprecated_scheme() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_scheme,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_encodedUsername = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_encodedUsername",
          r"()Ljava/lang/String;");

  /// from: public final java.lang.String -deprecated_encodedUsername()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString _deprecated_encodedUsername() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_encodedUsername,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_username = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_username", r"()Ljava/lang/String;");

  /// from: public final java.lang.String -deprecated_username()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString _deprecated_username() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_username,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_encodedPassword = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_encodedPassword",
          r"()Ljava/lang/String;");

  /// from: public final java.lang.String -deprecated_encodedPassword()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString _deprecated_encodedPassword() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_encodedPassword,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_password = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_password", r"()Ljava/lang/String;");

  /// from: public final java.lang.String -deprecated_password()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString _deprecated_password() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_password,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_host = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_host", r"()Ljava/lang/String;");

  /// from: public final java.lang.String -deprecated_host()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString _deprecated_host() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_host,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_port = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_port", r"()I");

  /// from: public final int -deprecated_port()
  int _deprecated_port() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id__deprecated_port, jni.JniCallType.intType, []).integer;
  }

  static final _id__deprecated_pathSize = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_pathSize", r"()I");

  /// from: public final int -deprecated_pathSize()
  int _deprecated_pathSize() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id__deprecated_pathSize, jni.JniCallType.intType, []).integer;
  }

  static final _id__deprecated_encodedPath = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_encodedPath", r"()Ljava/lang/String;");

  /// from: public final java.lang.String -deprecated_encodedPath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString _deprecated_encodedPath() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_encodedPath,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_encodedPathSegments = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_encodedPathSegments",
          r"()Ljava/util/List;");

  /// from: public final java.util.List -deprecated_encodedPathSegments()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> _deprecated_encodedPathSegments() {
    return const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id__deprecated_encodedPathSegments,
            jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_pathSegments = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_pathSegments", r"()Ljava/util/List;");

  /// from: public final java.util.List -deprecated_pathSegments()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> _deprecated_pathSegments() {
    return const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id__deprecated_pathSegments,
            jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_encodedQuery = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_encodedQuery", r"()Ljava/lang/String;");

  /// from: public final java.lang.String -deprecated_encodedQuery()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString _deprecated_encodedQuery() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_encodedQuery,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_query = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_query", r"()Ljava/lang/String;");

  /// from: public final java.lang.String -deprecated_query()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString _deprecated_query() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_query,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_querySize = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_querySize", r"()I");

  /// from: public final int -deprecated_querySize()
  int _deprecated_querySize() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id__deprecated_querySize, jni.JniCallType.intType, []).integer;
  }

  static final _id__deprecated_queryParameterNames = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_queryParameterNames",
          r"()Ljava/util/Set;");

  /// from: public final java.util.Set -deprecated_queryParameterNames()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JSet<jni.JString> _deprecated_queryParameterNames() {
    return const jni.JSetType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id__deprecated_queryParameterNames,
            jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_encodedFragment = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"-deprecated_encodedFragment",
          r"()Ljava/lang/String;");

  /// from: public final java.lang.String -deprecated_encodedFragment()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString _deprecated_encodedFragment() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_encodedFragment,
        jni.JniCallType.objectType, []).object);
  }

  static final _id__deprecated_fragment = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"-deprecated_fragment", r"()Ljava/lang/String;");

  /// from: public final java.lang.String -deprecated_fragment()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString _deprecated_fragment() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id__deprecated_fragment,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_defaultPort = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"defaultPort", r"(Ljava/lang/String;)I");

  /// from: static public final int defaultPort(java.lang.String string)
  static int defaultPort(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_defaultPort, jni.JniCallType.intType, [string.reference]).integer;
  }

  static final _id_get0 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"get", r"(Ljava/lang/String;)Lokhttp3/HttpUrl;");

  /// from: static public final okhttp3.HttpUrl get(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static HttpUrl get0(
    jni.JString string,
  ) {
    return const $HttpUrlType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_get0,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_parse = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"parse", r"(Ljava/lang/String;)Lokhttp3/HttpUrl;");

  /// from: static public final okhttp3.HttpUrl parse(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static HttpUrl parse(
    jni.JString string,
  ) {
    return const $HttpUrlType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_parse,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_get1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"get", r"(Ljava/net/URL;)Lokhttp3/HttpUrl;");

  /// from: static public final okhttp3.HttpUrl get(java.net.URL uRL)
  /// The returned object must be released after use, by calling the [release] method.
  static HttpUrl get1(
    jni.JObject uRL,
  ) {
    return const $HttpUrlType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_get1,
            jni.JniCallType.objectType, [uRL.reference]).object);
  }

  static final _id_get2 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"get", r"(Ljava/net/URI;)Lokhttp3/HttpUrl;");

  /// from: static public final okhttp3.HttpUrl get(java.net.URI uRI)
  /// The returned object must be released after use, by calling the [release] method.
  static HttpUrl get2(
    jni.JObject uRI,
  ) {
    return const $HttpUrlType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_get2,
            jni.JniCallType.objectType, [uRI.reference]).object);
  }
}

final class $HttpUrlType extends jni.JObjType<HttpUrl> {
  const $HttpUrlType();

  @override
  String get signature => r"Lokhttp3/HttpUrl;";

  @override
  HttpUrl fromRef(jni.JObjectPtr ref) => HttpUrl.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($HttpUrlType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($HttpUrlType) && other is $HttpUrlType;
  }
}

/// from: okhttp3.Call$Factory
class Call_Factory extends jni.JObject {
  @override
  late final jni.JObjType<Call_Factory> $type = type;

  Call_Factory.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Call$Factory");

  /// The type which includes information such as the signature of this class.
  static const type = $Call_FactoryType();
  static final _id_newCall = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newCall", r"(Lokhttp3/Request;)Lokhttp3/Call;");

  /// from: public abstract okhttp3.Call newCall(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Call newCall(
    Request request,
  ) {
    return const $CallType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_newCall,
        jni.JniCallType.objectType,
        [request.reference]).object);
  }
}

final class $Call_FactoryType extends jni.JObjType<Call_Factory> {
  const $Call_FactoryType();

  @override
  String get signature => r"Lokhttp3/Call$Factory;";

  @override
  Call_Factory fromRef(jni.JObjectPtr ref) => Call_Factory.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Call_FactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Call_FactoryType) &&
        other is $Call_FactoryType;
  }
}

/// from: okhttp3.Call
class Call extends jni.JObject {
  @override
  late final jni.JObjType<Call> $type = type;

  Call.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Call");

  /// The type which includes information such as the signature of this class.
  static const type = $CallType();
  static final _id_request = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"request", r"()Lokhttp3/Request;");

  /// from: public abstract okhttp3.Request request()
  /// The returned object must be released after use, by calling the [release] method.
  Request request() {
    return const $RequestType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_request, jni.JniCallType.objectType, []).object);
  }

  static final _id_execute = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"execute", r"()Lokhttp3/Response;");

  /// from: public abstract okhttp3.Response execute()
  /// The returned object must be released after use, by calling the [release] method.
  Response execute() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_execute, jni.JniCallType.objectType, []).object);
  }

  static final _id_enqueue = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"enqueue", r"(Lokhttp3/Callback;)V");

  /// from: public abstract void enqueue(okhttp3.Callback callback)
  void enqueue(
    jni.JObject callback,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_enqueue,
        jni.JniCallType.voidType, [callback.reference]).check();
  }

  static final _id_cancel =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"cancel", r"()V");

  /// from: public abstract void cancel()
  void cancel() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cancel, jni.JniCallType.voidType, []).check();
  }

  static final _id_isExecuted =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isExecuted", r"()Z");

  /// from: public abstract boolean isExecuted()
  bool isExecuted() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isExecuted, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isCanceled =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isCanceled", r"()Z");

  /// from: public abstract boolean isCanceled()
  bool isCanceled() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isCanceled, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_timeout = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"timeout", r"()Lokio/Timeout;");

  /// from: public abstract okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  Timeout timeout() {
    return const $TimeoutType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_timeout, jni.JniCallType.objectType, []).object);
  }

  static final _id_clone = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"clone", r"()Lokhttp3/Call;");

  /// from: public abstract okhttp3.Call clone()
  /// The returned object must be released after use, by calling the [release] method.
  Call clone() {
    return const $CallType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clone, jni.JniCallType.objectType, []).object);
  }
}

final class $CallType extends jni.JObjType<Call> {
  const $CallType();

  @override
  String get signature => r"Lokhttp3/Call;";

  @override
  Call fromRef(jni.JObjectPtr ref) => Call.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CallType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CallType) && other is $CallType;
  }
}
